#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{titlesec}

\def\bparskip{0.5\baselineskip}

\titlespacing{\paragraph}{%
  0pt}{%              left margin
  \bparskip}{% space before (vertical)
  1em}%               space after (horizontal)


% more compact itemize envs (enumitem module)
\setlist[itemize]{itemsep=0.2ex plus 0.5ex minus 0.5ex}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
theorems-ams-extended
theorems-sec
fixltx2e
fix-cm
enumitem
eqs-within-sections
figs-within-sections
tabs-within-sections
logicalmkup
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf2
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Data Structers I - lecture contents summary"
\pdf_author "Vladimír Čunát"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref page
\pdf_pdfusetitle true
\papersize a5paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.4cm
\topmargin 1.4cm
\rightmargin 1.4cm
\bottommargin 1.8cm
\columnsep 1cm
\secnumdepth 2
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\OO}{\mathcal{O}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\Opar}[1]{\OO\!\left(#1\right)}
{\OO\left(#1\right)}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Thpar}[1]{\Theta\!\left(#1\right)}
{\Theta\left(#1\right)}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Bi}{\mathrm{Bi}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Exp}[2][]{\mathrm{E}_{#1}\left[#2\right]}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\Var}[1]{\mathrm{Var}\left[#1\right]}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\interval}[2]{\left\langle #1,#2\right\rangle }
\end_inset


\end_layout

\begin_layout Title
Data structures I -- NTIN066
\end_layout

\begin_layout Section*
Prerequisites
\end_layout

\begin_layout Standard
None of these should be any issue for anyone who finished 
\emph on
our
\emph default
 CS bachelor.
\end_layout

\begin_layout Paragraph
Asymptotic notation.
\end_layout

\begin_layout Standard
We will use it extensively and perform computations in it.
 We use the master theorem in a proof or two, but I think it might be even
 enough to read about that on Wikipedia.
\end_layout

\begin_layout Paragraph
Basic data structures.
\end_layout

\begin_layout Standard
It is essential to understand basics such as linked lists, arrays, stacks
 (LIFO) and FIFO queues.
\end_layout

\begin_layout Paragraph
Combinatorial basics,
\end_layout

\begin_layout Standard
mainly to understand properties of binomial numbers (computations in proofs).
\end_layout

\begin_layout Paragraph
More for hashing.
\end_layout

\begin_layout Standard
In Part
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "part:Hashing"

\end_inset

 we will use basic 
\emph on
probability theory
\emph default
, mainly expected values, variances, (in)dependence, properties of binomial
 distribution, and likely Markov and Chebychev inequalities (I can state
 those anyway, perhaps without proof).
 In a hashing proof we will also likely use some basic properties from (linear)
 
\emph on
algebra
\emph default
, such as modular arithmetic and invertibility of regular matrices over
 (finite) fields (but again, understanding 
\emph on
why
\emph default
 they are invertible is not needed to understand the proof).
\end_layout

\begin_layout Section*
Tentative plan for winter 2014
\end_layout

\begin_layout Enumerate
Trees (representing ordered sets): 
\begin_inset Formula $(a,b)$
\end_inset

-trees, splay trees, overview of other solutions.
\end_layout

\begin_layout Enumerate
Heaps (priority queues): regular, binomial and Fibonacci heaps.
\end_layout

\begin_layout Enumerate
Memory hierarchies: modelling I/O, cache-oblivious and cache-aware techniques.
\end_layout

\begin_layout Enumerate
Hashing (representing unordered sets): collisions, choice of hash function,
 universal hashing, cuckoo hashing.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Trees
\end_layout

\begin_layout Section
Common
\end_layout

\begin_layout Subsubsection
Comparison-based dictionary
\end_layout

\begin_layout Standard
In this part we suppose an arbitrary 
\emph on
universe set
\emph default
 
\begin_inset Formula $U$
\end_inset

 and focus on representing a subset 
\begin_inset Formula $S\subseteq U$
\end_inset

.
 We call elements of 
\begin_inset Formula $S$
\end_inset

 
\emph on
keys
\emph default
, and denote 
\begin_inset Formula $n:=|S|$
\end_inset

.
\end_layout

\begin_layout Standard
We require that 
\begin_inset Formula $U$
\end_inset

 is 
\emph on
totally ordered
\emph default
, i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset

for any pair of keys we can decide whether they are equal or either is smaller.
 Elements of 
\begin_inset Formula $U$
\end_inset

 are 
\emph on
opaque
\emph default
 to us; we only read, write or compare pairs, e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

we use no arithmetics on 
\begin_inset Formula $U$
\end_inset

 like in hashing.
\end_layout

\begin_layout Standard
The keys can also have some data associated with them.
 We will not discuss this extension because it is simple to extend the opaque
 keys with data or a pointer to them, and the change does not affect how
 the structures behave.
\end_layout

\begin_layout Standard
All the common representations use rooted trees with ordered children.
 
\end_layout

\begin_layout Subsubsection
Supported operations
\end_layout

\begin_layout Standard
The basic operations supported by all tree types:
\end_layout

\begin_layout Itemize

\noun on
insert
\noun default

\begin_inset Formula $(T,x)$
\end_inset

 and 
\noun on
delete
\noun default

\begin_inset Formula $(T,x)$
\end_inset

 to modify the set (and also creating a representation of the empty set);
\end_layout

\begin_layout Itemize

\noun on
member
\noun default

\begin_inset Formula $(T,x)$
\end_inset

 which is often called 
\noun on
find
\noun default
 in the usual case when we are interested in the attached data, and e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

also predecessor/successor queries;
\end_layout

\begin_layout Itemize

\noun on
min
\noun default

\begin_inset Formula $(T)$
\end_inset

 and 
\noun on
max
\noun default

\begin_inset Formula $(T)$
\end_inset

 and various interval queries;
\end_layout

\begin_layout Itemize
building in 
\begin_inset Formula $\OO(n)$
\end_inset

 time from a sorted sequence of keys.
\end_layout

\begin_layout Standard
Trees can be augmented to support these queries (for example):
\end_layout

\begin_layout Itemize

\noun on
ord
\noun default

\begin_inset Formula $(T,k)$
\end_inset

 finds the 
\begin_inset Formula $k$
\end_inset

-th smallest key in 
\begin_inset Formula $T$
\end_inset

 (notation: counting from zero);
\end_layout

\begin_layout Itemize

\noun on
rank
\noun default

\begin_inset Formula $(T,x)$
\end_inset

 returns the number of keys less than 
\begin_inset Formula $x$
\end_inset

 (an inverse query to 
\noun on
ord
\noun default
).
\end_layout

\begin_layout Standard
Some trees also support fast splitting and joining, which is mostly useful
 for representing key-less string-like sequences.
\end_layout

\begin_layout Itemize

\noun on
split
\noun default

\begin_inset Formula $(T,x)$
\end_inset

 splits the represented set by 
\begin_inset Formula $x$
\end_inset

 into two trees 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

.
 The resulting trees contain the keys from 
\begin_inset Formula $T$
\end_inset

 that are less than 
\begin_inset Formula $x$
\end_inset

 or greater than 
\begin_inset Formula $x$
\end_inset

, respectively.
\end_layout

\begin_layout Itemize

\noun on
join2
\noun default

\begin_inset Formula $(T_{1},T_{2})$
\end_inset

 and 
\noun on
join3
\noun default

\begin_inset Formula $(T_{1},x,T_{2})$
\end_inset

 are the inverse operations to 
\noun on
split
\noun default
.
 We require that 
\begin_inset Formula $\mbox{\textsc{max}}\left(T_{1}\right)<\mbox{\textsc{min}}\left(T_{2}\right)$
\end_inset

 and the result is a tree that represents all the keys from 
\begin_inset Formula $T_{1}$
\end_inset

, 
\begin_inset Formula $T_{2}$
\end_inset

 and also 
\begin_inset Formula $x$
\end_inset

 in the case of 
\noun on
join3
\noun default
.
 In various structures we only show the simpler of the operations and the
 other one can be simulated by adding an extra insertion or deletion.
\end_layout

\begin_layout Section
(a,b)-trees
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $(a,b)$
\end_inset

-trees are rooted trees where:
\end_layout

\begin_layout Itemize
all leaves are in the same depth, one for each represented key;
\end_layout

\begin_layout Itemize
inner nodes have between 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 child nodes (inclusively), and
\end_layout

\begin_layout Itemize
the root node has between 2 and 
\begin_inset Formula $b$
\end_inset

 child nodes (unless the tree is a single leaf).
\end_layout

\begin_layout Remark*
\begin_inset ERT
status open

\begin_layout Plain Layout

[practice, caches]
\end_layout

\end_inset

In practice we might rather represent between 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 keys in one leaf node, but that is an easy modification of the structure.
 Good choice of the constants depends on the particular use case, and they
 will typically grow with relative cost of random access (which is high
 e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

for rotating disks).
\end_layout

\begin_layout Subsubsection
Literature
\end_layout

\begin_layout Standard
Here we study general 
\begin_inset Formula $\left(a,b\right)$
\end_inset

-trees.
 In literature one can rather find variants of 
\begin_inset Formula $B$
\end_inset

-trees instead, but the principles are always the same.
 Some basic treatment of 
\begin_inset Formula $B$
\end_inset

-trees is present in practically any data-structural textbook, including
 
\emph on
Handbook of Data Structures and Applications
\emph default
 and 
\emph on
Introduction to Algorithms
\emph default
.
\end_layout

\begin_layout Standard
Standard 
\begin_inset Formula $B$
\end_inset

-trees also use our splitter positions for keys, which slightly complicates
 the structure and typically worsens performance on disks, because the inner
 nodes need more space due to additional data attached to the keys.
 The standard 
\begin_inset Formula $B^{+}$
\end_inset

-trees are leaf-oriented as our 
\begin_inset Formula $\left(a,b\right)$
\end_inset

-trees, and moreover they add level-links on the leaf level (we get more
 from level-links in the finger-tree section 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "ab-trees/finger-trees"

\end_inset

).
\end_layout

\begin_layout Lemma*
The depth of any 
\begin_inset Formula $(a,b)$
\end_inset

-tree with 
\begin_inset Formula $n$
\end_inset

 leaves is between 
\begin_inset Formula $\log_{b}n$
\end_inset

 and 
\begin_inset Formula $1+\log_{a}\frac{n}{2}$
\end_inset

.
 That is, the depth is 
\begin_inset Formula $\Theta(\log n)$
\end_inset

.
\end_layout

\begin_layout Proof
Obviously, the number of leaves of an 
\begin_inset Formula $(a,b)$
\end_inset

-tree of height 
\begin_inset Formula $h$
\end_inset

 is between 
\begin_inset Formula $2a^{h-1}$
\end_inset

 and 
\begin_inset Formula $b^{h}$
\end_inset

.
 By taking logarithms we get the claimed inequalities.
\end_layout

\begin_layout Lemma*
The tree uses less than 
\begin_inset Formula $n$
\end_inset

 nonleaf nodes, so it needs space is 
\begin_inset Formula $\Thpar n$
\end_inset

.
\end_layout

\begin_layout Proof
On every level above leaves the number of nodes gets halved at least, so
 it is at most 
\begin_inset Formula $\sum_{i=1}^{\mathrm{depth}}n/2^{i}<n\sum_{i=1}^{\infty}1/2^{i}=n$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\end_layout

\end_inset

 Every nonleaf node 
\begin_inset Formula $v$
\end_inset

 of the tree consists of the following fields:
\end_layout

\begin_layout Itemize
\begin_inset Formula $p(v)$
\end_inset

 is the number of child nodes of 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{v}\left[1\dots p(v)\right]$
\end_inset

 is an array of pointers to child nodes.
\end_layout

\begin_layout Itemize
\begin_inset Formula $H_{v}\left[1\dots p(v)-1\right]$
\end_inset

 is an array of splitters.
 They are keys such that 
\noun on

\begin_inset Formula $\forall i$
\end_inset

 max
\noun default

\begin_inset Formula $\left(S_{v}[i]\right)\leq H_{v}[i]<$
\end_inset


\noun on
min
\begin_inset Formula $\left(S_{v}[i+1]\right)$
\end_inset


\noun default
.
 Note that the 
\begin_inset Formula $H_{v}$
\end_inset

 values in the tree recursively and unambiguously split the whole universe
 set into intervals, which are 1-to-1 mapped to leaves.
\end_layout

\begin_layout Standard
In the usual variant of 
\begin_inset Formula $(a,b)$
\end_inset

-trees we need that 
\begin_inset Formula $a\ge2$
\end_inset

 and 
\begin_inset Formula $b\ge2a-1$
\end_inset

.
 However, it is recommended to have 
\begin_inset Formula $b\geq2a$
\end_inset

, which significantly decreases the total number of needed modifications
 in long operation sequences.
\end_layout

\begin_layout Subsection
Standard algorithms
\end_layout

\begin_layout Standard
The algorithms for 
\noun on
member
\noun default
, 
\noun on
insert
\noun default
 and 
\noun on
delete
\noun default
 always do at most constant amount of work on every level of the tree, bounding
 the asymptotic complexities by 
\begin_inset Formula $\Opar{\log n}$
\end_inset

.
\end_layout

\begin_layout Paragraph*

\noun on
Member
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset


\end_layout

\begin_layout Standard
We start in the root and repeatedly choose the correct child to go down
 (by the values of 
\begin_inset Formula $H_{v}$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset

).
 In the leaf we compare the key with
\begin_inset space ~
\end_inset


\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Paragraph

\noun on
Insert
\begin_inset Formula $\left(T,x\right)$
\end_inset


\end_layout

\begin_layout Standard
We find the correct leaf to insert after and check that 
\begin_inset Formula $x$
\end_inset

 is not represented by 
\begin_inset Formula $T$
\end_inset

 yet.
 Adding a new leaf can overfill the parent; in that case we split it in
 halves, which results into adding a new child of the grandparent, etc.
 Note that during the node split we move one splitter to the parent.
 The splitting can cascade up to the root, whose splitting would increase
 the depth of the tree.
 Note that 
\begin_inset Formula $b\ge2a-1$
\end_inset

 ensures exactly that the split nodes always have enough children.
\end_layout

\begin_layout Paragraph

\noun on
Delete
\begin_inset Formula $\left(T,x\right)$
\end_inset


\end_layout

\begin_layout Standard
We find the leaf to be deleted and remove reference to it from the parent
 node.
 Whenever a nonroot node is only left with 
\begin_inset Formula $a-1$
\end_inset

 children, we merge it with its brother.
 If the resulting node has more than 
\begin_inset Formula $b$
\end_inset

 children, we re-split it in halves.
 Then we correct the common parent of the nodes, possibly resulting into
 a cascade of merges.
 If the root node is only left with one child, we make the child the new
 root (decreasing the depth of the tree).
\end_layout

\begin_layout Exercise*
Start with an empty 
\begin_inset Formula $2,3$
\end_inset

-tree and succesively perform the following operations.
 Insert 7, 2, 3, 0, 6.
 Then delete 
\begin_inset Formula $2$
\end_inset

, insert 4 and 8, and delete 0, 6,
\begin_inset space ~
\end_inset

7.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Splitting and joining
\end_layout

\begin_layout Paragraph

\noun on
Join2
\begin_inset Formula $\left(T_{1},T_{2}\right)$
\end_inset


\end_layout

\begin_layout Standard
We take the lower of 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

, and merge its root with the adjacent border node in the correct depth
 of the other tree, so the leaves are in the same depth.
 Then we fix the node the same way as after insertion.
 If we know a splitter to put between the two trees and we know their depth
 difference, it is enough to work on as many levels, resulting into 
\begin_inset Formula $\Opar{\left|h\left(T_{1}\right)-h\left(T_{2}\right)\right|+1}$
\end_inset

 complexity.
\end_layout

\begin_layout Paragraph

\noun on
Split
\begin_inset Formula $\left(T,x\right)$
\end_inset


\end_layout

\begin_layout Standard
We start with two empty stacks for left and right subtrees, 
\begin_inset Formula $S_{1}$
\end_inset

 and 
\begin_inset Formula $S_{2}$
\end_inset

.
 Then we proceed like in 
\noun on
member
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset

, but we split every node according to the chosen child into the left and
 right fragment (one of those can be empty), pushing them on the corresponding
 stacks.
 Finally we repeatedly 
\noun on
join2
\noun default
 the top trees on the left stack which creates 
\begin_inset Formula $T_{1}$
\end_inset

; 
\begin_inset Formula $T_{2}$
\end_inset

 is created from the right stack the same way.
\end_layout

\begin_layout Standard
It remains to prove joining each stack only takes 
\begin_inset Formula $\Opar{\log n}$
\end_inset

 time.
 Note that the heights of the fragments pushed onto each stack strictly
 decrease, and they are correct 
\begin_inset Formula $\left(a,b\right)$
\end_inset

-trees, except that some fragments can have a root with a single child.
 That violation does not affect the 
\noun on
join2
\noun default
 operations, and we can easily delete the degenerate root after joining
 the whole stack.
\end_layout

\begin_layout Standard
Note that 
\noun on
join2
\begin_inset Formula $\left(T_{L},T_{R}\right)$
\end_inset


\noun default
 can only create a tree of depth 
\begin_inset Formula $\max\left\{ h\left(T_{L}\right),h\left(T_{R}\right)\right\} $
\end_inset

 or one level higher.
 Let 
\begin_inset Formula $h_{1}<h_{2}<\dotsb<h_{k}$
\end_inset

 denote the heights of trees on the stack and let 
\begin_inset Formula $h'_{i}$
\end_inset

 denote the resulting height after joining together the first 
\begin_inset Formula $i$
\end_inset

 trees.
 Notice that 
\begin_inset Formula $h'_{i}\leq h_{i}+1$
\end_inset

, by induction:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $h'_{1}=h_{1}$
\end_inset

 by definition;
\end_layout

\begin_layout Enumerate
for 
\begin_inset Formula $i>1$
\end_inset

, 
\begin_inset Formula $h'_{i}\leq\max\left\{ h'_{i-1},h_{i}\right\} +1\leq\max\left\{ h_{i-1}+1,h_{i}\right\} +1\leq h_{i}+1$
\end_inset


\end_layout

\begin_layout Standard
The total work of joining a stack is bounded by 
\begin_inset Formula $W\le\sum_{i=1}^{k-1}\Opar{\left|h_{i+1}-h'_{i}\right|+1}$
\end_inset

.
 Since 
\begin_inset Formula $h_{i+1}\ge h_{i}+1\ge h'_{i}$
\end_inset

, we can remove the absolute value and get 
\begin_inset Formula 
\[
W\,\lesssim\,\sum_{i=1}^{k-1}h_{i+1}-\sum_{i=1}^{k-1}h'_{i}+k-1\,\le\,\sum_{i=2}^{k-1}h_{i}+h_{k}-\sum_{i=2}^{k-1}h'_{i}+k.
\]

\end_inset

It trivially holds that 
\begin_inset Formula $h'_{i}\ge h_{i}$
\end_inset

, so the sums cancel out and we get 
\begin_inset Formula $W\le\Opar{\log n}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Order statistics
\end_layout

\begin_layout Standard
To suport the 
\noun on
ord
\noun default
 and 
\noun on
rank
\noun default
 operations, we need to add a field 
\begin_inset Formula $N_{v}\left[1\dots p(v)-1\right]$
\end_inset

 into every node, where 
\begin_inset Formula $N_{v}[i]$
\end_inset

 is 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
the number of leaves in the
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $S_{v}[i]$
\end_inset

 subtree.
 It is quite clear how to change the mentioned operations to also maintain
 the 
\begin_inset Formula $N_{v}$
\end_inset

 values, especially note that we can reconstruct the values in a node from
 the values in its children in constant time (if the children are already
 correct).
\end_layout

\begin_layout Paragraph

\noun on
rank
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset


\end_layout

\begin_layout Standard
We proceed like in 
\noun on
member
\noun default

\begin_inset Formula $(T,x)$
\end_inset

, but we also accumulate all the 
\begin_inset Formula $N_{v}$
\end_inset

 values to the left of the chosen path.
\end_layout

\begin_layout Paragraph

\noun on
ord
\noun default

\begin_inset Formula $\left(T,k\right)$
\end_inset


\end_layout

\begin_layout Standard
We find 
\begin_inset Formula $\max\left\{ i\in\left\{ 1\dots p(root)\right\} \mid\sum_{j=1}^{i-1}N_{root}[j]<k\right\} $
\end_inset

 and we continue as in 
\noun on
ord
\noun default

\begin_inset Formula $\left(S[i],k-\sum_{j=1}^{i-1}N_{root}[j]\right)$
\end_inset

.
\end_layout

\begin_layout Remark*
This augmentation can be generalized in a stragihtforward way.
 We showed the case of accumulating 1-values assigned to every leaf, combined
 by addition.
 Every leaf can have any value selected on insertion, and we may allow to
 modify it.
 For meaningful 
\noun on
rank
\noun default
 we only need that the chosen combining operator is associative.
 For unambiguous selection with 
\noun on
ord
\noun default
 according to a predicate, we need that the predicate can not be turned
 from true to false by accumulating more values by the operator.
\end_layout

\begin_layout Remark*
We can also easily keep more independent order statistics at once.
 The generalizations get more useful for finger-tree variant without keys
 (see pg.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "ab-trees/finger-trees"

\end_inset

).
\end_layout

\begin_layout Subsection
Top-down balancing
\end_layout

\begin_layout Standard
The stated insertion and deletion algorithms are not suitable for parallel
 execution.
 They might have to lock the root during the whole operation, because we
 do not know for sure if it will be modified.
 Note that this uncertainty only happens when the node is 
\emph on
critical
\emph default
, i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset

when it has 
\begin_inset Formula $b$
\end_inset

 children on insertion or 
\begin_inset Formula $a$
\end_inset

 children on deletion.
\end_layout

\begin_layout Standard
We can shorten the locks by 
\emph on
top-down balancing
\emph default
: whenever we pass through a critical node, we split/merge it to be safe
 (before continuing down).
 Since the update can not propagate above a non-critical node, we can release
 a lock on its parent before continuing down.
 That way each updating thread at any time only locks one node and optionally
 its parent.
\end_layout

\begin_layout Standard
We need 
\begin_inset Formula $b\ge2a$
\end_inset

 to maintain the invariant, and it is recommended to have 
\begin_inset Formula $b\ge2a+2$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Finger trees 
\begin_inset CommandInset label
LatexCommand label
name "ab-trees/finger-trees"

\end_inset


\end_layout

\begin_layout Standard
It is common for ordered-set data structures to support some efficient way
 of accessing elements near to a known location.
 Such structure variants are usually called finger trees.
 Now we show how to modify 
\begin_inset Formula $(a,b)$
\end_inset

-trees to support finger operations.
\end_layout

\begin_layout Standard
For a tree 
\begin_inset Formula $T$
\end_inset

 and finger 
\begin_inset Formula $f$
\end_inset

 we aim for operation complexities proportional to 
\begin_inset Formula $\log(|$
\end_inset


\noun on
ord
\noun default

\begin_inset Formula $\left(T,f\right)-$
\end_inset


\noun on
ord
\noun default

\begin_inset Formula $\left(T,x\right)|+2)$
\end_inset

.
 That is asymptotically at most the previous 
\begin_inset Formula $\log n$
\end_inset

, but it can be much less if 
\begin_inset Formula $f$
\end_inset

 points 
\begin_inset Quotes eld
\end_inset

near 
\begin_inset Formula $x$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard

\emph on
Finger
\emph default
 will be just a pointer to an arbitrary leaf.
 For easy access from there we need to add some pointers to every node of
 the tree: parent-node pointer, and pointers to the previous and following
 node on the same level.
 All modifying operations can be easily adapted to maintain these additional
 pointers without worsening the asymptotic time or space.
\end_layout

\begin_layout Paragraph
Operations
\end_layout

\begin_layout Standard

\noun on
memFrom
\noun default

\begin_inset Formula $\left(f,x\right)$
\end_inset

, 
\noun on
delFrom
\noun default

\begin_inset Formula $\left(f,x\right)$
\end_inset

 and 
\noun on
insFrom
\noun default

\begin_inset Formula $\left(f,x\right)$
\end_inset

 work almost the same as their non-finger counterparts.
 The main difference is in finding the correct leaf
\begin_inset space ~
\end_inset

-- we start from the finger 
\begin_inset Formula $f$
\end_inset

 and always alternate one step on the same level towards 
\begin_inset Formula $x$
\end_inset

 with one step up (into the parent), until we skip over the value of 
\begin_inset Formula $x$
\end_inset

.
 Then we go down just like when searching for 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Standard
Observe that the 
\begin_inset Formula $i$
\end_inset

-th level-step skips at least 
\begin_inset Formula $a^{i-1}$
\end_inset

 leaves.
 As a consequence the time to find the leaf is proportional to 
\begin_inset Formula $\log_{a}(|$
\end_inset


\noun on
ord
\noun default

\begin_inset Formula $\left(T,f\right)-$
\end_inset


\noun on
ord
\noun default

\begin_inset Formula $\left(T,x\right)|+2)$
\end_inset

.
 In the modifying operations we also have to handle node spliting or merging,
 which does not change the situation much (without detailed proof here).
\end_layout

\begin_layout Exercise*
Explain why we needed to add the level pointers.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\end_layout

\end_inset

 Fingers help navigate the tree fast, but modifying operations can generally
 cascade up to the root.
 The following shows the work will amortize on series of operations.
\end_layout

\begin_layout Theorem*
Let 
\begin_inset Formula $b\ge2a$
\end_inset

, 
\begin_inset Formula $a\ge2$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

 be a (finger) 
\begin_inset Formula $(a,b)$
\end_inset

-tree representing a set of size at most 
\begin_inset Formula $n$
\end_inset

 during a series of lookups, insertions and deletions.
 Then the total time needed to apply the series on T is 
\begin_inset Formula $\OO\left(\log n+\mbox{time needed for searching}\right)$
\end_inset

.
\end_layout

\begin_layout Remark*

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset ERT
status open

\begin_layout Plain Layout

[dictionaries without keys]
\end_layout

\end_inset

 Surprisingly, in many use cases it makes sense to use trees without keys,
 only representing sequences of values (stored in leaves for the case of
 
\begin_inset Formula $(a,b)$
\end_inset

-trees).
 A typical programming example is 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
string
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 of values.
 Then the ordering is given implicitly by the operations
\begin_inset space ~
\end_inset

-- searching by key makes no sense, and most operations need a finger pointing
 to the exact place where the insertion/deletion/splitting/rank should happen.
 Note that splitters in inner nodes would also make no sense anymore.
 It is useful to combine this with order (or other) statistics.
 For example, such structures are important building blocks for representations
 of dynamic graphs, such as ET-trees and ST-trees.
\end_layout

\begin_layout Subsection
A-sort 
\begin_inset CommandInset label
LatexCommand label
name "sub:A-sort"

\end_inset


\end_layout

\begin_layout Standard
A-sort is a sorting algorithm that is efficient for almost sorted sequences.
 It uses an 
\begin_inset Formula $\left(a,b\right)$
\end_inset

-tree with parent pointers.
 We start with an empty tree and successively insert all elements.
 We always search for the position from the rightmost leaf (we have a finger
 there).
 Finally we walk through the leaves and output them in order (in linear
 time).
\end_layout

\begin_layout Standard
Note that the number leaves skipped on 
\begin_inset Formula $i$
\end_inset

-th insertion is equal to the number of inversions of the 
\begin_inset Formula $i$
\end_inset

-th element.
 That is defined as the number of preceding elements that are smaller, i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset


\begin_inset Formula $f_{i}:=\left|\left\{ j:\, j>i\,\wedge\, x_{j}<x_{i}\right\} \right|$
\end_inset

.
 For the total number of inversions 
\begin_inset Formula $F:=\sum_{i}f_{i}$
\end_inset

 we know 
\begin_inset Formula $0\le F\le{n \choose 2}$
\end_inset

.
\end_layout

\begin_layout Standard
The total work spent on node splitting is 
\begin_inset Formula $\OO(n)$
\end_inset

, because we only do insertions, and splitting a node increases the number
 of nodes by one, and the final number of nodes is 
\begin_inset Formula $\OO(n)$
\end_inset

.
 The time spent on searching is proportional to 
\begin_inset Formula $\sum_{i}\log\left(f_{i}+2\right)=\log\prod_{i}\left(f_{i}+2\right)=n\log\left[\prod_{i}\left(f_{i}+2\right)\right]^{1/n}$
\end_inset

.
 Since 
\begin_inset Formula $\left[\prod_{i=1}^{n}\alpha_{i}\right]^{1/n}\leq\frac{1}{n}\sum_{i=1}^{n}\alpha_{i}$
\end_inset

 (geometric vs.
\begin_inset space ~
\end_inset

arithmetic mean of nonnegative values), we get total time bound 
\begin_inset Formula $\Opar{n\log\left(2+F/n\right)}$
\end_inset

.
 Note that this is 
\begin_inset Formula $\OO(n\log n)$
\end_inset

 in the worst case, but it can be much better if the sequence is partially
 sorted.
 The authors also show that the time bound is asymptotically optimal w.r.t.
\begin_inset space ~
\end_inset


\begin_inset Formula $F$
\end_inset

: they compute the number of permutations for given 
\begin_inset Formula $F$
\end_inset

 and use the decision-tree technique described 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:sorting-decision-trees"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Binary search trees 
\begin_inset CommandInset label
LatexCommand label
name "sec:BST"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\key}{\mathsf{key}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\l}{\mathsf{l}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\r}{\mathsf{r}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\h}{\mathsf{height}}
\end_inset

 
\begin_inset FormulaMacro
\newcommand{\b}{\mathsf{bal}}
\end_inset


\end_layout

\begin_layout Standard
We define BSTs as rooted trees with the following properties:
\end_layout

\begin_layout Itemize
Every nonleaf 
\begin_inset Formula $v$
\end_inset

 has (exactly) two child nodes 
\begin_inset Formula $\l(v)$
\end_inset

, 
\begin_inset Formula $\r(v)$
\end_inset

 and it is uniquely assigned to an element 
\begin_inset Formula $\key(v)$
\end_inset

 of the represented set.
\end_layout

\begin_layout Itemize
Leaves carry no information.
 In practice they would not be present, i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset

pointers to leaves are typically 
\emph on
null
\emph default
 pointers.
\end_layout

\begin_layout Itemize
The keys are in infix ordering, i.
\begin_inset space \thinspace{}
\end_inset

e.
 all keys in subtree of 
\begin_inset Formula $\l(v)$
\end_inset

 are less than 
\begin_inset Formula $\key(v)$
\end_inset

 and all keys in 
\begin_inset Formula $\r(v)$
\end_inset

 are greater.
\begin_inset Foot
status open

\begin_layout Plain Layout
We may want to allow equality in subtrees to support multiple values with
 the same key.
 That often makes sense in practice, but we do not complicate the descriptions
 here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note again that every vertex covers an open interval from the ordered universe
 set
\begin_inset space ~
\end_inset

-- the root starts with the whole universe, then the subtrees always split
 the parent interval according to the key, and the leaves exactly correspond
 to all intervals between the represented elements.
\end_layout

\begin_layout Corollary
BST representing 
\begin_inset Formula $n$
\end_inset

 keys contains one nonleaf vertex for every key and 
\begin_inset Formula $n+1$
\end_inset

 leaves, so it needs 
\begin_inset Formula $\Theta(n)$
\end_inset

 space.
\end_layout

\begin_layout Subsubsection
Literature
\end_layout

\begin_layout Standard

\emph on
Handbook of Data Structures and Applications
\emph default
 covers in detail all we do and more, including AVL trees.
\end_layout

\begin_layout Standard

\emph on
Introduction to Algorithms
\emph default
, second or third edition, explains BSTs without balancing and red-black
 trees.
 Splitting, joining, and splay trees are omitted.
\end_layout

\begin_layout Subsection
BSTs without balancing
\end_layout

\begin_layout Subsubsection*
Operations:
\end_layout

\begin_layout Paragraph

\noun on
member/find
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset

 
\end_layout

\begin_layout Standard
We start from the root, always compare the key and either return success
 or continue down the correct child node.
\end_layout

\begin_layout Paragraph

\noun on
min
\noun default

\begin_inset Formula $(T)$
\end_inset


\begin_inset space ~
\end_inset


\series medium
and
\series default

\begin_inset space ~
\end_inset


\noun on
max
\noun default

\begin_inset Formula $(T)$
\end_inset

 
\end_layout

\begin_layout Standard
We just find the leftmost or rightmost non-leaf node.
\end_layout

\begin_layout Paragraph

\noun on
insert
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset

 
\end_layout

\begin_layout Standard
We start the same as 
\noun on
member
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset

.
 If we find 
\begin_inset Formula $x$
\end_inset

, we exit.
 Otherwise we replace the leaf that we ended in with a new node (having
 key 
\begin_inset Formula $x$
\end_inset

 and two leaf children).
\end_layout

\begin_layout Paragraph

\noun on
delete
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset


\end_layout

\begin_layout Standard
We first find the node 
\begin_inset Formula $u$
\end_inset

 with 
\begin_inset Formula $\key(u)=x$
\end_inset

 or we fail.
 If both children of 
\begin_inset Formula $u$
\end_inset

 are leaves, we just replace 
\begin_inset Formula $u$
\end_inset

 with a leaf node.
 Similarly if only one child is non-leaf, we replace 
\begin_inset Formula $u$
\end_inset

 with it.
 Otherwise we find 
\begin_inset Formula $v$
\end_inset

 that contains the left neigbour key in the ordering.
 That is the rightmost non-leaf node in the subtree of 
\begin_inset Formula $\l\left(u\right)$
\end_inset

.
 We move 
\begin_inset Formula $\key(v)$
\end_inset

 to 
\begin_inset Formula $u$
\end_inset

 and remove 
\begin_inset Formula $v$
\end_inset

 instead, which is simple because 
\begin_inset Formula $\r(v)$
\end_inset

 has to be a leaf.
\end_layout

\begin_layout Paragraph

\noun on
join3
\noun default

\begin_inset Formula $\left(T_{1},x,T_{2}\right)$
\end_inset

 
\end_layout

\begin_layout Standard
is trivial exercise.
\end_layout

\begin_layout Paragraph

\noun on
split
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset


\end_layout

\begin_layout Standard
We proceed like in 
\noun on
member
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset

 building 
\begin_inset Formula $T_{L}$
\end_inset

 and 
\begin_inset Formula $T_{R}$
\end_inset

 along the way, similarly to 
\begin_inset Formula $\left(a,b\right)$
\end_inset

-trees.
 We maintain pointers to the rigtmost leaf of 
\begin_inset Formula $T_{L}$
\end_inset

 and leftmost leaf of 
\begin_inset Formula $T_{R}$
\end_inset

.
 We always replace these leaves by the left or right subtrees that we cut
 along the way down in 
\begin_inset Formula $T$
\end_inset

.
 When we reach leaf, we have distributed all vertices in 
\begin_inset Formula $T_{L}$
\end_inset

 and 
\begin_inset Formula $T_{R}$
\end_inset

.
\end_layout

\begin_layout Paragraph

\noun on
rank
\noun default

\begin_inset Formula $\left(T,x\right)$
\end_inset


\begin_inset space ~
\end_inset


\series medium
and
\series default

\begin_inset space ~
\end_inset


\noun on
ord
\noun default

\begin_inset Formula $\left(T,k\right)$
\end_inset


\end_layout

\begin_layout Standard
We do the same as in 
\begin_inset Formula $\left(a,b\right)$
\end_inset

-trees.
 We also need to add a counter of keys present in every subtree.
\end_layout

\begin_layout Exercise*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
easy
\end_layout

\end_inset

 Find linear algorithms for building a perfectly balanced tree from a sorted
 array or list, and for printing all represented keys in sorted order.
\end_layout

\begin_layout Subsubsection
Keeping BSTs fast
\end_layout

\begin_layout Standard
Note that again the complexity of any operation is proportional to the depth
 of the tree.
 The depth is expected to be logarithmic, assuming uniformly random distribution
 of arguments to modifying operations, but that is a very unrealistic assumption.
 There are many modifications that strive to bound the complexities in various
 ways:
\end_layout

\begin_layout Itemize

\emph on
Balancing
\emph default
 the tree ensures 
\begin_inset Formula $\OO\left(\log n\right)$
\end_inset

 depth.
 We cover Red-black trees 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:RB-trees"

\end_inset

.
 AVL trees are skipped now, but still described 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:AVL-trees"

\end_inset

.
\end_layout

\begin_layout Itemize

\emph on
Randomizing
\emph default
 the modifying operations to make the expected complexities 
\emph on
independent
\emph default
 of the sequence of modifications performed on the tree (covered in DSII
 course).
 The approach is alike to universal hashing, described 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Universal-hashing"

\end_inset

.
\end_layout

\begin_layout Itemize

\emph on
Self-modify
\emph default
 the tree to optimize for some operation patterns.
 We cover Splay trees.
\end_layout

\begin_layout Paragraph
Balancing
\end_layout

\begin_layout Standard
BSTs can be balanced by edge 
\emph on
rotations
\emph default
.
 A
\begin_inset space ~
\end_inset

single rotation reverses the direction of one edge.
 There is only one way of doing it, because we must not disturb the infix
 order of the nodes.
 Let WLOG rotate the edge 
\begin_inset Formula $\l(v)=u$
\end_inset

.
 After the rotation, 
\begin_inset Formula $u$
\end_inset

 takes the place of 
\begin_inset Formula $v$
\end_inset

 (from the perspective of the parent), and we have 
\begin_inset Formula $\r(u)=v$
\end_inset

.
 Also, the right subtree of 
\begin_inset Formula $u$
\end_inset

 becomes the left subtree of 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Subsection
Red-black trees 
\begin_inset CommandInset label
LatexCommand label
name "sub:RB-trees"

\end_inset


\end_layout

\begin_layout Standard
RB-trees are BSTs where every vertex is either red or black, and the following
 conditions hold:
\end_layout

\begin_layout Enumerate
leaves and the root are black,
\end_layout

\begin_layout Enumerate
red vertex always has a black parent, and
\end_layout

\begin_layout Enumerate
all paths from root to a leaf contain the same amount of black vertices.
\end_layout

\begin_layout Standard
Now we show how these conditions bound the height of the tree.
 We consider the shortest and longest root-to-leaf paths possible in one
 RB-tree.
 They have the same number of black vertices, all start and end in a black
 vertex, and at most every other vertex can be red.
 Thus the ratio of the longest to the shorterst path is at most 
\begin_inset Formula $2$
\end_inset

.
 If we combine it with the following lemma, we get that the 
\emph on
depth is bounded by 
\begin_inset Formula $2\log\left(n+2\right)$
\end_inset


\emph default
.
\begin_inset Foot
status open

\begin_layout Plain Layout
All logarithms are binary, unless specified otherwise.
\end_layout

\end_inset


\end_layout

\begin_layout Lemma*
The shortest root-to-leaf path in a tree with 
\begin_inset Formula $n$
\end_inset

 nonleaf vertices has less than 
\begin_inset Formula $\log\left(n+2\right)$
\end_inset

 edges.
\end_layout

\begin_deeper
\begin_layout Proof
For the sake of contradiction suppose that all paths have length at least
 
\begin_inset Formula $\log\left(n+2\right)$
\end_inset

.
 Then there is no leaf up to the depth 
\begin_inset Formula $\left\lceil \log\left(n+2\right)\right\rceil -1$
\end_inset

 (inclusive), so the number of nonleaf vertices is at least 
\begin_inset Formula $\sum_{i=0}^{\left\lceil \log\left(n+2\right)\right\rceil -1}2^{i}=2^{\left\lceil \log\left(n+2\right)\right\rceil }-1\ge n+1>n.$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Non-modifying operations are the same as in BSTs without balancing.
 In 
\noun on
insert
\noun default
 and 
\noun on
delete
\noun default
 we just perform some rebalancing at the end of the operation to restore
 the RB conditions.
\end_layout

\begin_layout Subsubsection

\noun on
Insert
\end_layout

\begin_layout Standard
The BST algorithm always replaces a leaf with a new vertex which we make
 red.
 This can create a 
\series bold
2-partial
\series default
 RB-tree, where all conditions hold except for one red-red edge.
 Let us denote the edge 
\begin_inset Formula $\left(u\rightarrow v\right)$
\end_inset

; WLOG 
\begin_inset Formula $v=\r(u)$
\end_inset

, as the other case is just mirrored.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $u$
\end_inset

 is the root, we just color it black and we are done.
 Otherwise let 
\begin_inset Formula $t$
\end_inset

 be the parent of 
\begin_inset Formula $u$
\end_inset

, and 
\begin_inset Formula $w$
\end_inset

 the sibling of 
\begin_inset Formula $u$
\end_inset

.
 We know that 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 are red; 
\begin_inset Formula $t$
\end_inset

 is black because 2-partial RB-tree only allows one red-red edge.
 Three cases follow; in each we do some rotations and/or recolorings that
 either fix the tree or make it 
\begin_inset Formula $2$
\end_inset

-partial where the broken edge is higher than before.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Case
\begin_inset Formula $w$
\end_inset

 is red.
 We recolor the siblings 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $w$
\end_inset

 to black, and change their parent 
\begin_inset Formula $t$
\end_inset

 to red.
 This may break the edge between 
\begin_inset Formula $t$
\end_inset

 and its parent, so we may have to continue there (two levels higher).
\end_layout

\begin_layout Case
\begin_inset Formula $w$
\end_inset

 is black and it is the left sibling of 
\begin_inset Formula $u$
\end_inset

.
 We rotate the 
\begin_inset Formula $\left(t\rightarrow u\right)$
\end_inset

 edge; then recolor 
\begin_inset Formula $t$
\end_inset

 to red and 
\begin_inset Formula $u$
\end_inset

 to black.
 We can stop here, because the root of the rotation remains black.
\end_layout

\begin_layout Case
\begin_inset Formula $w$
\end_inset

 is black and it is the right sibling of 
\begin_inset Formula $u$
\end_inset

.
 We double-rotate 
\begin_inset Formula $v$
\end_inset

 up, and recolor 
\begin_inset Formula $t$
\end_inset

 to red and 
\begin_inset Formula $v$
\end_inset

 to black.
 We can stop there, because the root of the rotation remains black, as in
 the previous case.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename rb-i1.dot
	lyxscale 50
	scale 50
	groupId RB-tree

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename rb-i2.dot
	lyxscale 50
	scale 50
	groupId RB-tree

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
RB insertion: Cases 1 and 2.
 Note that for Case
\begin_inset space ~
\end_inset

1 the subtrees of 
\begin_inset Formula $w$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 may look the other way around.
 As for all RB figures, the nodes can have larger subtrees which are not
 indicated here.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename rb-i3.dot
	lyxscale 50
	scale 50
	groupId RB-tree

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
RB insertion: Case 3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection

\noun on
Delete
\noun default
 (no details during the lecture)
\end_layout

\begin_layout Standard
The BST algorithm always ends with removal of a node that has (at least)
 one leaf child.
 If the removed node was black then we are left with a 
\series bold
3-partial
\series default
 RB-tree, where all conditions hold except that root-to-leaf paths through
 one vertex 
\begin_inset Formula $v$
\end_inset

 have one less black node than all the other root-to-leaf paths.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $v$
\end_inset

 is the root, we are done.
 Otherwise let 
\begin_inset Formula $u$
\end_inset

 be the parent of 
\begin_inset Formula $v$
\end_inset

, 
\begin_inset Formula $w$
\end_inset

 be the other child of 
\begin_inset Formula $u$
\end_inset

, and WLOG let 
\begin_inset Formula $v=\r(u)$
\end_inset

 (the other case is symmetrical).
 Five cases follow; in each we do some rotations and/or recolorings that
 either fix the tree or make it 
\begin_inset Formula $3$
\end_inset

-partial where the broken vertex is higher than before.
\end_layout

\begin_layout Case
\begin_inset Formula $v$
\end_inset

 is red.
 We just change 
\begin_inset Formula $v$
\end_inset

 to black, which fixes everything.
\end_layout

\begin_layout Case
the sibling 
\begin_inset Formula $w$
\end_inset

 is red (and thus all around are black).
 We rotate the 
\begin_inset Formula $\left(u\rightarrow w\right)$
\end_inset


\begin_inset space ~
\end_inset

edge, recolor 
\begin_inset Formula $u$
\end_inset

 to red and 
\begin_inset Formula $w$
\end_inset

 to black.
 The result is still 3-partial in 
\begin_inset Formula $v$
\end_inset

, but now its sibling is black and we continue with some of the following
 cases.
\end_layout

\begin_layout Case
the sibling 
\begin_inset Formula $w$
\end_inset

 and both its children are black.
 We recolor 
\begin_inset Formula $w$
\end_inset

 to red and set the parent 
\begin_inset Formula $u$
\end_inset

 to black.
 If 
\begin_inset Formula $u$
\end_inset

 was red, the problem is fixed (e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

always after Case
\begin_inset space ~
\end_inset

2); otherwise we now have a 3-partial tree in 
\begin_inset Formula $u$
\end_inset

 and continue one level higher.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename rb-d2.dot
	lyxscale 50
	scale 50
	groupId RB-tree

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename rb-d3.dot
	lyxscale 50
	scale 50
	groupId RB-tree

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
RB deletion: Cases 2 and 3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Case
the sibling 
\begin_inset Formula $w$
\end_inset

 and its right child are black, and 
\begin_inset Formula $w$
\end_inset

's left child 
\begin_inset Formula $x$
\end_inset

 is red.
 We rotate the 
\begin_inset Formula $\left(u\rightarrow w\right)$
\end_inset


\begin_inset space ~
\end_inset

edge, recolor 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $x$
\end_inset

 to black, and 
\begin_inset Formula $w$
\end_inset

 retains the former color of 
\begin_inset Formula $u$
\end_inset

.
 The tree is OK now.
\end_layout

\begin_layout Case
the sibling 
\begin_inset Formula $w$
\end_inset

 is black and its right child 
\begin_inset Formula $y$
\end_inset

 is red.
 We let 
\begin_inset Formula $y$
\end_inset

 double-rotate up and get the former color of 
\begin_inset Formula $u$
\end_inset

; 
\begin_inset Formula $u$
\end_inset

 gets black.
 The tree is OK now.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename rb-d4.dot
	lyxscale 50
	scale 50
	groupId RB-tree

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
RB deletion: Case 4.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename rb-d5.dot
	lyxscale 50
	scale 50
	groupId RB-tree

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
RB deletion: Case 5.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Exercise*
Verify that no operation can do more than three rotations (a double rotation
 equals two regular ones).
\end_layout

\begin_layout Subsubsection
Notes
\end_layout

\begin_layout Itemize
The 
\noun on
rank
\noun default
 and 
\noun on
ord
\noun default
 operations can be added the same way as in BSTs without balancing.
\end_layout

\begin_layout Itemize

\noun on
Join3
\noun default
 and 
\noun on
split
\noun default
 work like in 
\begin_inset Formula $\left(a,b\right)$
\end_inset

-trees, only the depth counts in black vertices.
 
\noun on
Join3
\begin_inset Formula $\left(T_{1},x,T_{2}\right)$
\end_inset


\noun default
 finds an edge of the deeper tree in correct black-depth, and makes 
\begin_inset Formula $x$
\end_inset

 subdivide the edge with the less deep tree as the other child.
\end_layout

\begin_layout Corollary*
The complexities of all operations on RB-trees are 
\begin_inset Formula $\Theta(\log n)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Comparison to AVL
\end_layout

\begin_layout Itemize
The worst-case depth (up to small additive constants) is 
\begin_inset Formula $\doteq1.4\log n$
\end_inset

 in AVL and 
\begin_inset Formula $2\log n$
\end_inset

 in RB, but on random data they are almost the same.
\end_layout

\begin_layout Itemize
RB typically do less work on modifications.
 In particular, they always do at most three rotations for any operation,
 whereas AVL deletion can do 
\begin_inset Formula $\Omega(\log n)$
\end_inset

 rotations.
 That gives RB-trees an advantage especially in applications with expensive
 rotations, e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

when much data is associated with nodes and need to be recomputed on restructuri
ng.
\end_layout

\begin_layout Itemize
RB seem to be the most popular solution for implementation of a dictionary
 in general-purpose programming libraries.
 That holds even in cases where only the basic operations are used, so e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

hash tables would be more efficient.
 Arguably, it is because there are more pitfalls in hashing, and 
\begin_inset Formula $\log n$
\end_inset

 is bounded by a not-too-large constant in practice (e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

we can hardly hope to ever store 
\begin_inset Formula $2^{100}$
\end_inset

 elements).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Amortized complexity 
\begin_inset CommandInset label
LatexCommand label
name "sec:amortized"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Up to now we have been concentrating on worst-case complexities except for
 the part about hashing where we were mainly interested in expected compexities
 taken over possible input data or random bits.
 We have already encountered the notion of amortization but now we will
 describe it properly.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Amortization is not a tree-specific topic; it is useful in all kinds of
 data structures, including the following subsection.
 You can find more detailed explanation e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

in 
\emph on
Handbook of Data Structures and Applications
\emph default
 or 
\emph on
Introduction to Algorithms
\emph default
.
\end_layout

\begin_layout Paragraph
Motivation:
\end_layout

\begin_layout Standard
Often we are not much interested in complexities of individual operations
 but rather complexities of their 
\emph on
sequences
\emph default
.
 Thus we may tolerate doing a lot of work once upon a time if we know that
 this has saved us at least that much work in the past.
 
\end_layout

\begin_layout Standard
During an amortized analysis we define an amortized complexity for each
 operation.
 The only real requirement is that for any sequence of operations starting
 from a well-defined state (e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

an
\begin_inset space ~
\end_inset

empty structure), the sum of actual work done is no larger than the sum
 of their declared amortized complexities.
\end_layout

\begin_layout Standard
Amortization resembles some kind of expected complexity for one operation,
 but note that there is 
\emph on
no probability
\emph default
 involved here.
 Also note that the operations in the sequence do not need to have the same
 amortized complexities.
\end_layout

\begin_layout Subsubsection
Analysis via potentials
\end_layout

\begin_layout Standard
Amortized complexity bounds are typically proven by a variation of the following
 method.
 We assign a 
\emph on
nonnegative
\emph default
 
\emph on
potential
\emph default
 to the whole structure.
 The potential represents how much of the allowed work has been saved for
 future, and it is often defined as the sum over potentials of all parts
 of the structure.
 (Sometimes it is imagined as savings in coins and called 
\emph on
banker's method
\emph default
.) In most cases the potential does not need to be explicitly stored in the
 structure, and it is only used to analyze the complexity.
\end_layout

\begin_layout Standard
Let us analyze some operation that transforms the structure from potential
 
\begin_inset Formula $\Phi_{i-1}$
\end_inset

 to potential 
\begin_inset Formula $\Phi_{i}$
\end_inset

 and needs at most 
\begin_inset Formula $W_{i}$
\end_inset

 real work at the moment.
 Then we want to have amortized complexity 
\begin_inset Formula $W_{i}^{A}$
\end_inset

 of the operation such that 
\begin_inset Formula $W_{i}+\Phi_{i}-\Phi_{i-1}\le W_{i}^{A}$
\end_inset

.
 (The potential is always scaled in some units of work.)
\end_layout

\begin_layout Standard
If we prove the above property, the desired bound is ensured.
 Take any sequence of 
\begin_inset Formula $k$
\end_inset

 operations where the potentials went from 
\begin_inset Formula $\Phi_{0}$
\end_inset

 to 
\begin_inset Formula $\Phi_{k}$
\end_inset

, and 
\begin_inset Formula $i$
\end_inset

-th operation needed 
\begin_inset Formula $W_{i}$
\end_inset

 real work and had 
\begin_inset Formula $W_{i}^{A}$
\end_inset

 amortized complexity.
 Then the total work is: 
\begin_inset Formula 
\[
\sum_{i=1}^{k}W_{i}\le\sum_{i=1}^{k}\left[W_{i}^{A}-\left(\Phi_{i}-\Phi_{i-1}\right)\right]=\sum_{i=1}^{k}W_{i}^{A}+\Phi_{0}-\Phi_{k}
\]

\end_inset

Since 
\begin_inset Formula $\Phi_{k}\ge0$
\end_inset

 and 
\begin_inset Formula $\Phi_{0}$
\end_inset

 is a constant (usually zero), we get the desired bound.
\end_layout

\begin_layout Standard
Trivial example: extending an array by doubling when full.
 We can choose potential as the number of occupied slots minus the number
 of free ones.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Splay trees
\end_layout

\begin_layout Itemize
Splay operation: rotates a given key to the root (in a specific way).
\end_layout

\begin_layout Itemize
All other operations are trivially converted to splaying.
\end_layout

\begin_layout Itemize
No explicit balancing; restructuring only by splaying the accessed nodes.
\end_layout

\begin_layout Itemize
Operations can take 
\begin_inset Formula $\Omega(n)$
\end_inset

, but they are all 
\begin_inset Formula $\OO(\log n)$
\end_inset

 amortized (starting from an empty tree) and even better for specific access
 patterns.
\end_layout

\begin_layout Itemize
Advantages: simple and automagically taking advantage of various kinds of
 access patterns.
\end_layout

\begin_layout Itemize
Disadvantages: very many rotations, even when seaching only, and thus slightly
 higher multiplicative constants.
\end_layout

\begin_layout Subsubsection*
Splay algorithm
\end_layout

\begin_layout Standard
When splaying vertex 
\begin_inset Formula $u$
\end_inset

, we repeat the following until 
\begin_inset Formula $u$
\end_inset

 is in root:
\end_layout

\begin_layout Case
\begin_inset Formula $u$
\end_inset

 has no grandparent.
 We just rotate the edge to the parent.
\end_layout

\begin_layout Case
(zig-zig) the key of 
\begin_inset Formula $u$
\end_inset

 is 
\emph on
not between
\emph default
 its parent's and grandparent's.
 We rotate the edge to the parent of 
\begin_inset Formula $u$
\end_inset

 and then the edge to its new parent.
 See Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand vref
reference "fig:splay-zig-zig"

\end_inset

.
\end_layout

\begin_layout Case
(zig-zag) Otherwise, we first rotate the edge between the parent and grandparent
 of 
\begin_inset Formula $u$
\end_inset

, and then rotate the edge to the new parent of 
\begin_inset Formula $u$
\end_inset

.
 See Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand vref
reference "fig:splay-zig-zag"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement bph
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename splay-2.dot
	scale 50
	groupId Splay

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:splay-zig-zig"

\end_inset

Splay step, Case
\begin_inset space ~
\end_inset

2 (called zig-zig).
 The case can also be mirrored.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename splay-3.dot
	scale 50
	groupId Splay

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:splay-zig-zag"

\end_inset

Splay step, Case
\begin_inset space ~
\end_inset

3 (called zig-zag).
 The case can also be mirrored.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Analysis of splaying
\end_layout

\begin_layout Itemize
For each key we choose a weight, in our case always equal to one.
\end_layout

\begin_layout Itemize
For each vertex 
\begin_inset Formula $u$
\end_inset

 we define rank 
\begin_inset Formula $r(u)$
\end_inset

 as the logarithm of the total weight in the subtree of 
\begin_inset Formula $u$
\end_inset

 (scaled to suitable units of work time).
\begin_inset Foot
status open

\begin_layout Plain Layout
The original definition from Tarjan used rounded integer ranks instead,
 but that unnecessarily complicates the analysis.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use the potential 
\begin_inset Formula $\Phi:=\sum_{u}r(u)$
\end_inset

.
 Note: it is always nonnegative.
\end_layout

\begin_layout Itemize
Aim show that the amortized cost of splaying 
\begin_inset Formula $u$
\end_inset

 is 
\begin_inset Formula $\apprle1+3\left(r(\mbox{root})-r(u)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Analyze each step of the algorithm separately; they telescope.
\end_layout

\begin_layout Itemize
Notation: splaying vertex 
\begin_inset Formula $u$
\end_inset

 with parent 
\begin_inset Formula $v$
\end_inset

 and (possibly) grandparent 
\begin_inset Formula $w$
\end_inset

.
 Let 
\begin_inset Formula $r'$
\end_inset

 be rank after the step and 
\begin_inset Formula $t$
\end_inset

 the amortized time of the step.
 
\end_layout

\begin_layout Itemize
Notes: weights and thus ranks can change only in those three vertices.
 Similarly, root of the (double) rotation preserves its rank.
 Any vertex has larger rank than any of its descendants.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Case
\begin_inset Formula $t\approx1+r'(u)-r(u)+r'(v)-r(v)\,=\,1-r(u)+r'(v)<1+r(\mbox{root})-r(u)$
\end_inset

.
\end_layout

\begin_layout Case
We count the rotations as two units of work and get:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\begin{aligned}t\,\approx\; & 2-r(u)+r'(v)-r(v)+r'(w)\;<\\
<\; & 2-r(u)+r'(u)-r(u)+r'(w)\;\le^{(*)}\;3r'(u)-3r(u).
\end{aligned}
\]

\end_inset

 
\end_layout

\begin_deeper
\begin_layout Claim*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
*
\end_layout

\end_inset


\begin_inset Formula $2+r(u)+r'(w)\le2r'(u)$
\end_inset

.
 First note that due to logarithm being concave, 
\begin_inset Formula $2\log(p+q)\,=\,2\log\frac{p+q}{2}+2\,\ge\,\log p+\log q$
\end_inset

.
\end_layout

\begin_layout Claim*
(Draw pictures.) Let us denote the subtree weights: 
\begin_inset Formula 
\begin{align*}
r(u) & =\log\left(|A|+|B|+1\right),\\
r'(w) & =\log\left(|C|+|D|+1\right).\\
\mbox{Now we have:}\\
2r'(u) & \,=\,2\log\left(|A|+|B|+1\,+\,|C|+|D|+1\,+1\right)\,\ge\\
 & \,\ge\,2+\log\left(|A|+|B|+1\right)+\log\left(|C|+|D|+1\right)\,=\\
 & \,=\,2+r(u)+r'(w).\qed
\end{align*}

\end_inset


\end_layout

\end_deeper
\begin_layout Case
It is similar to Case
\begin_inset space ~
\end_inset

2:
\begin_inset Formula 
\[
\begin{aligned}t\,\approx\; & 2-r(u)+r'(v)-r(v)+r'(w)\;<\\
<\; & 2-r(u)+r'(v)-r(u)+r'(w)\;\le^{(*)}\;2r'(u)-2r(u).
\end{aligned}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Claim*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
*
\end_layout

\end_inset


\begin_inset Formula $2+r'(v)+r'(w)\le2r'(u)$
\end_inset

.
\begin_inset Newline newline
\end_inset

Proof: analogous to the corresponding claim in Case
\begin_inset space ~
\end_inset

2.
\end_layout

\end_deeper
\begin_layout Standard
The cases together finish the splay analysis.
 With unit key weights, the ranks are between zero and 
\begin_inset Formula $\log n$
\end_inset

, so splay suffices with 
\begin_inset Formula $\OO(\log n)$
\end_inset

 amortized time.
\end_layout

\begin_layout Exercise*
Formulate algorithms for all operations, and prove their 
\begin_inset Formula $\OO(\log n)$
\end_inset

 amortized complexities thoroughly.
 Note that other actions than splaying can change the potential, which has
 to be accounted into the complexity.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
Properties and conjectures
\end_layout

\begin_layout Standard
Splay trees exhibit asymptotic optimality in many situations.
 The following properties are typically proven just by clever setting of
 the weights during the analysis (the structure itself is unchanged).
\end_layout

\begin_layout Paragraph
Sequences of operations
\end_layout

\begin_layout Standard
Consider a sequence of operations on a splay tree.
 If it starts on an empty tree, the starting potential is zero, so the real
 work is 
\begin_inset Formula $\apprle\sum_{i}\log n_{i}$
\end_inset

 where 
\begin_inset Formula $n_{i}$
\end_inset

 is the size after 
\begin_inset Formula $i$
\end_inset

-th operation.
 If the sequence starts with 
\emph on
any
\emph default
 state of the tree with 
\begin_inset Formula $n_{0}$
\end_inset

 elements, its potential is 
\begin_inset Formula $0\le\Phi\le n_{0}\log n_{0}$
\end_inset

; therefore, the real work on the sequence is 
\begin_inset Formula $\apprle n_{0}\log n_{0}+\sum_{i}\log n_{i}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Static optimality 
\end_layout

\begin_layout Standard
Splay trees are asymptotically at least as fast as the best static BST construct
ed for the query sequence given in advance, even though the splay trees
 do not know the access pattern in advance.
\end_layout

\begin_layout Paragraph
Static finger optimality
\end_layout

\begin_layout Standard
Imagine a finger 
\begin_inset Formula $f$
\end_inset

 on any static value from the key universe.
 Then accessing 
\begin_inset Formula $x$
\end_inset

 only needs the same amortized time as a finger tree would, i.
\begin_inset space \thinspace{}
\end_inset

e.
 
\begin_inset Formula $\apprle\log\left(1+\left|\mbox{\textsc{ord}}(x)-\mbox{\textsc{ord}}(f)\right|\right)$
\end_inset

.
 Note that again the splay tree is oblivious to the position of the imagined
 finger.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Add dynamic finger optimality: Tarjan's slides from madalgo12.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Working set theorem
\end_layout

\begin_layout Standard
If we accessed 
\begin_inset Formula $t_{x}$
\end_inset

 different elements since the last access to 
\begin_inset Formula $x$
\end_inset

, then the amortized time to access it again is 
\begin_inset Formula $\apprle\log\left(1+t_{x}\right)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Dynamic optimality conjecture
\end_layout

\begin_layout Standard
Informally: splay trees might be asymptotically optimal among any kind of
 binary search trees.
 This 
\emph on
conjecture
\emph default
 has been open for over thirty years, and it is not known to hold for any
 BST.
 There are specially crafted Tango trees, which are at most 
\begin_inset Formula $\OO(\log\log n)$
\end_inset

-times worse than the optimum.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Priority queues (heaps)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO: re-consider naming (priority, meld, join, etc.) and min/max explanation.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Common
\end_layout

\begin_layout Subsubsection
Priority queue interface
\end_layout

\begin_layout Standard
Priority queues, often called heaps, maintain a collection of some data
 where every element is assigned a 
\emph on
priority
\emph default
 (from a totally ordered universe 
\begin_inset Formula $U$
\end_inset

).
\end_layout

\begin_layout Standard
Basic operations we want to support:
\end_layout

\begin_layout Itemize

\noun on
insert
\noun default

\begin_inset Formula $\left(H,x\right)$
\end_inset

 adds an element with priority 
\begin_inset Formula $x$
\end_inset

 to 
\begin_inset Formula $H$
\end_inset

,
\end_layout

\begin_layout Itemize

\noun on
min
\noun default

\begin_inset Formula $\left(H\right)$
\end_inset

 returns an element with the smallest priority in 
\begin_inset Formula $H$
\end_inset

, and
\end_layout

\begin_layout Itemize

\noun on
delMin
\noun default

\begin_inset Formula $\left(H\right)$
\end_inset

 removes 
\noun on
min
\noun default

\begin_inset Formula $\left(H\right)$
\end_inset

 from 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Standard
PQs often also support some of the following operations:
\end_layout

\begin_layout Itemize

\noun on
delete
\noun default

\begin_inset Formula $\left(H,p\right)$
\end_inset

 removes from 
\begin_inset Formula $H$
\end_inset

 an element to which we have a pointer 
\begin_inset Formula $p$
\end_inset

,
\end_layout

\begin_layout Itemize

\noun on
increase
\noun default

\begin_inset Formula $\left(H,p,\delta\right)$
\end_inset

 and 
\noun on
decrease
\noun default

\begin_inset Formula $\left(H,p,\delta\right)$
\end_inset

 change priority of an element,
\end_layout

\begin_layout Itemize

\noun on
makeHeap
\noun default

\begin_inset Formula $\left(A\right)$
\end_inset

 creates a heap from an (unordered) list of elements (sometimes it is even
 
\emph on
asymptotically
\emph default
 faster than building by insertions), and
\end_layout

\begin_layout Itemize

\noun on
meld
\noun default

\begin_inset Formula $\left(H_{1},H_{2}\right)$
\end_inset

 merges two heaps into one that contains the (disjoint) union of the elements
 (no restriction on priorities like in 
\noun on
join
\noun default
 for BSTs).
\end_layout

\begin_layout Note*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
min/max
\end_layout

\end_inset

We will only consider min-heaps; you can surely imagine the reversed variants,
 and there are simple ways of converting heaps to support both sets of min-
 and max-oriented operations.
\end_layout

\begin_layout Subsubsection
Overview
\end_layout

\begin_layout Standard
The following sections describe increasingly complicated PQ data structures.
 As shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand vref
reference "tab:heaps"

\end_inset

, the later heaps improve asympotic complexities of some operations; on
 the other hand, the constant factors increase, and also the algorithms
 and analyses get more complicated.
 In practice the multiplicative constants are very important, so it is usually
 best to choose the simplest data structure from those that satisfy the
 best asymptotic behaviour on the frequently used operations.
\end_layout

\begin_layout Notation*
The current number of elements in the heap is denoted by 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Notation*
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
arraystretch}{1.5} 
\backslash
setlength{
\backslash
tabcolsep}{0.75em}
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="6">
<features rotate="0" tabularvalignment="middle">
<column alignment="right" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\noun on
insert
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\noun on
meld
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\noun on
del(Min)
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\noun on
increase
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\noun on
decrease
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\OO(1)$
\end_inset

-regular
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(n)$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
leftist*
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
binomial
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset

 | 
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log^{2}n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lazy binomial
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset

 | 
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log^{2}n$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fibonacci
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset

 | 
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\log n$
\end_inset

 | 
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset

 | 
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:heaps"

\end_inset

Comparison of 
\begin_inset Formula $\Theta$
\end_inset

-bounds on operation speeds of various heap types.
 Cells with two values show the amortized and real-time bound (if they differ).
\begin_inset Newline newline
\end_inset

(*) Leftist heaps are currently omitted from the lecture, but you can find
 them in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Leftist-heaps"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Literature? Probably both books have good descriptions of all (except leftist).
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Literature
\end_layout

\begin_layout Standard
Both 
\emph on
Handbook of Data Structures and Applications
\emph default
 and 
\emph on
Introduction to Algorithms
\emph default
 contain descriptions for all topics done in this part but for a few exceptions.
 Both only consider 
\begin_inset Formula $2$
\end_inset

-regular heaps instead of 
\begin_inset Formula $d$
\end_inset

-regular.
 The latter textbook removed binomial heaps in its third edition.
 The first one also contains leftist heaps, which are currently omitted
 from the lecture.
\end_layout

\begin_layout Section
Regular heaps
\end_layout

\begin_layout Subsubsection
Definition
\end_layout

\begin_layout Standard
For a parameter 
\begin_inset Formula $d\ge2$
\end_inset

, a 
\emph on

\begin_inset Formula $d$
\end_inset

-regular heap
\emph default
 is a 
\begin_inset Formula $d$
\end_inset

-ary rooted tree with 1-1 mapping between vertices and the stored elements.
 As a consequence the space is 
\begin_inset Formula $\Thpar n$
\end_inset

.
 The classic variant is 
\begin_inset Formula $d=2$
\end_inset

.
\end_layout

\begin_layout Standard
The heap condition: priority of any vertex is at least the priority of its
 parent.
 As a consequence the root contains an element with the smallest priority.
\end_layout

\begin_layout Standard
The shape of the tree: it is perfectly balanced, and the leaf level is aligned
 to the left.
 Note that the shape is 
\emph on
exactly determined
\emph default
 just by 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
Array implementation (storing vertices in one big contiguous array):
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Array implementation
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As the tree shape is clear, we store
\emph on
 no pointers
\emph default
: let the root have the index 
\begin_inset Formula $0$
\end_inset

; for a vertex of index 
\begin_inset Formula $i$
\end_inset

, we give its 
\begin_inset Formula $d$
\end_inset

 children the indices 
\begin_inset Formula $di+1,\dotsc,di+d$
\end_inset

.
 Consequently, index of the parent can be always computed by 
\begin_inset Formula $\left\lfloor (i-1)/d\right\rfloor $
\end_inset

.
\end_layout

\begin_layout Standard
We can verify that there are no 
\begin_inset Quotes eld
\end_inset

holes
\begin_inset Quotes erd
\end_inset

 between the levels, so the rule gives a 1-1 mapping to indices 
\begin_inset Formula $0,\dots,n-1$
\end_inset

.
 Via a simple induction on the indexing definition, the position of the
 first vertex in depth 
\begin_inset Formula $l$
\end_inset

 is 
\begin_inset Formula $\left(d^{l}-1\right)/(d-1)$
\end_inset

.
 That corresponds to the fact that there are 
\begin_inset Formula $d^{l}$
\end_inset

 elements on a full level 
\begin_inset Formula $l$
\end_inset

.
\end_layout

\begin_layout Standard
As a consequence, we see that the index of the last element 
\begin_inset Formula $=n-1\ge\left(d^{\mathrm{\, height}}-1\right)/(d-1)\ge d^{\mathrm{\, height}-1}$
\end_inset

, so 
\begin_inset Formula $\mbox{height}\le\left\lfloor \log_{d}n\right\rfloor +1$
\end_inset

 (assuming 
\begin_inset Formula $n\ge1$
\end_inset

).
\end_layout

\begin_layout Note*
The array implementation is very simple and significantly decreases multiplicati
ve constants in comparison to other heaps (which by default allocate one
 node per element or more).
 It is perhaps the strongest reason why the binary heaps are so popular
 in practice.
\end_layout

\begin_layout Subsection
Algorithms and running time
\end_layout

\begin_layout Standard
First we define auxiliary 
\noun on
up
\noun default
 and 
\noun on
down
\noun default
 operations.
\end_layout

\begin_layout Paragraph

\noun on
up
\noun default

\begin_inset Formula $\left(H,p\right)$
\end_inset

:
\end_layout

\begin_layout Standard
It applies if the priority on position 
\begin_inset Formula $p$
\end_inset

 got decreased (but otherwise the heap was OK).
 We start at 
\begin_inset Formula $p$
\end_inset

 and compare to its parent.
 We end if it is OK, otherwise we swap them and continue one level higher.
 Note that these swaps can not break the heap property with the other children
 of the parent.
 The needed time is obviously proportional to the depth of 
\begin_inset Formula $p$
\end_inset

 (in the worst case).
\end_layout

\begin_layout Paragraph

\noun on
down
\noun default

\begin_inset Formula $\left(H,p\right)$
\end_inset

:
\end_layout

\begin_layout Standard
It applies if the priority on position 
\begin_inset Formula $p$
\end_inset

 got increased (but otherwise the heap was OK).
 We start at 
\begin_inset Formula $p$
\end_inset

 and find a child 
\begin_inset Formula $c$
\end_inset

 with the 
\emph on
smallest
\emph default
 priority (among 
\begin_inset Formula $p$
\end_inset

's children).
 We end if 
\begin_inset Formula $p\le c$
\end_inset

, otherwise we swap 
\begin_inset Formula $p$
\end_inset

 with 
\begin_inset Formula $c$
\end_inset

 and continue from the former position of 
\begin_inset Formula $c$
\end_inset

.
 Note that these swaps restore the heap property in 
\begin_inset Formula $p$
\end_inset

.
 The needed time is obviously proportional to 
\begin_inset Formula $d\,\times$
\end_inset

 depth of 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Paragraph

\noun on
insert
\noun default

\begin_inset Formula $\left(H,x\right)$
\end_inset

:
\end_layout

\begin_layout Standard
The shape determines the place for any new element (end of array), so we
 put it there.
 Then we run 
\noun on
up
\noun default
 on it to restore the heap property.
\end_layout

\begin_layout Paragraph

\noun on
delete
\noun default

\begin_inset Formula $\left(H,p\right)$
\end_inset

:
\end_layout

\begin_layout Standard
The shape determines the element to be de-allocated, so we first switch
 it with 
\begin_inset Formula $p$
\end_inset

.
 Then we run 
\noun on
up
\noun default
 or 
\noun on
down
\noun default
 on the element to restore the heap property.
 (The priority on the place can increase or decrease.)
\end_layout

\begin_layout Paragraph

\noun on
delMin
\noun default

\begin_inset Formula $\left(H\right)$
\end_inset


\begin_inset space ~
\end_inset


\series medium
and
\series default

\begin_inset space ~
\end_inset


\noun on
min
\noun default
:
\end_layout

\begin_layout Standard
The first element of the array is an element with the smallest priority.
 We can delete it by the general algorithm.
\end_layout

\begin_layout Paragraph

\noun on
increase
\noun default

\begin_inset Formula $\left(H,p,\delta\right)$
\end_inset


\begin_inset space ~
\end_inset


\series medium
and
\series default

\begin_inset space ~
\end_inset


\noun on
decrease
\noun default

\begin_inset Formula $\left(H,p,\delta\right)$
\end_inset

:
\end_layout

\begin_layout Standard
We just change the priority and then fix the heap property by 
\noun on
down
\noun default

\begin_inset Formula $\left(H,p\right)$
\end_inset

 or 
\noun on
up
\noun default

\begin_inset Formula $\left(H,p\right)$
\end_inset

, respectively.
\end_layout

\begin_layout Paragraph

\noun on
makeHeap
\noun default

\begin_inset Formula $\left(A\right)$
\end_inset

:
\end_layout

\begin_layout Standard
We take the array as the heap.
 Then we run 
\noun on
down
\noun default
 on every nonleaf vertex, from the end of the array to the beginning (bottom-up).
 
\end_layout

\begin_layout Standard
Analysis: let 
\begin_inset Formula $h$
\end_inset

 denote the height of the heap.
 The 
\noun on
down
\noun default
 operations need less time in the lower part of the heap.
 We split away the time for running 
\noun on
down
\noun default
 on elements of level 
\begin_inset Formula $h-1$
\end_inset

 and bound the total time of 
\noun on
makeHeap
\noun default
 by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{aligned}\Opar n+\sum_{l=0}^{h-2}\left[d^{l}\cdot\Opar{d\left(h-l\right)}\right] & \;\overset{l':=h-2-l}{\lesssim} & n+\sum_{l'=0}^{h-2}d^{h-2-l'}d\left(l'+2\right) & \;\le\;\\
 & \;\overset{\hphantom{l':=h-2-l}}{\le} & n+d^{h-1}\sum_{l'=0}^{h-2}\left(l'+2\right)/d^{l'} & \;\lesssim\;\Opar n
\end{aligned}
\]

\end_inset

where the last inequality follows from 
\begin_inset Formula $n>d^{h-1}$
\end_inset

 and from the fact that the last sum is bounded by a constant independent
 of 
\begin_inset Formula $d$
\end_inset

 (
\begin_inset Formula $d\ge2$
\end_inset

, even if summed up to infinity).
\end_layout

\begin_layout Note*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
alternative asymptotic analysis
\end_layout

\end_inset

We can magine the process as a top-down recursion.
 First the two subtrees of the root are made correct heaps, and then the
 root is propagated down a path in either subtree.
 To simplify, assume the whole tree is complete, i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset

all leaves are in the same depth; that can only increase the time, and the
 resulting number of elements at most doubles to 
\begin_inset Formula $n'<2n$
\end_inset

.
 For the total time we have 
\begin_inset Formula $T(n')\le2T\left(n'/2\right)+\Thpar{d\log_{d}n'}$
\end_inset

, so by the 
\emph on
master theorem
\emph default
 (assuming 
\begin_inset Formula $d\in\Opar{n^{1-\epsilon}}$
\end_inset

 with 
\begin_inset Formula $\epsilon>0$
\end_inset

) we have 
\begin_inset Formula $T(n)\le T\left(n'\right)\le\Thpar{n'}=\Thpar n$
\end_inset

.
\end_layout

\begin_layout Corollary*
\begin_inset CommandInset label
LatexCommand label
name "complexity-heaps-regular"

\end_inset

 
\begin_inset Formula $d$
\end_inset

-regular heaps need 
\begin_inset Formula $\Thpar n$
\end_inset

 space; 
\noun on
makeHeap
\noun default
 needs 
\begin_inset Formula $\Thpar n$
\end_inset

 time; 
\noun on
insert
\noun default
 and 
\noun on
decrease
\noun default
 need 
\begin_inset Formula $\Thpar{\log_{d}n}$
\end_inset

 time.
 Operations 
\noun on
delMin
\noun default
, 
\noun on
delete
\noun default
 and 
\noun on
increase
\noun default
 need 
\begin_inset Formula $\Thpar{d\log_{d}n}$
\end_inset

 time.
\end_layout

\begin_layout Section
Towards Fibonacci heaps
\end_layout

\begin_layout Standard
The final target of the section are Fibonacci heaps, which will:
\end_layout

\begin_layout Itemize
speed up 
\noun on
decrease
\noun default
 to 
\begin_inset Formula $\Thpar 1$
\end_inset

! (amortized),
\end_layout

\begin_layout Itemize
improve 
\noun on
insert
\noun default
 and 
\noun on
meld
\noun default
 to 
\begin_inset Formula $\Thpar 1$
\end_inset

 (both worst-case and amortized), and
\end_layout

\begin_layout Itemize
otherwise keep the same amortized complexities, although the worst-case
 performance of some operations will degrade to 
\begin_inset Formula $\Thpar n$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
Deamortized Fibonacci-like heaps do exist, but they are significantly more
 complicated.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic ideas come from binomial heaps, constructed from binomial trees.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Binomial heaps
\end_layout

\begin_layout Definition*

\emph on
Binomial tree
\emph default
 of rank 
\begin_inset Formula $i$
\end_inset

, denoted 
\begin_inset Formula $H_{i}$
\end_inset

, is a tree where every node corresponds to one key, and it satisfies the
 heap ordering on the keys (priorities).
 
\begin_inset Formula $H_{0}$
\end_inset

 consists of a single node; 
\begin_inset Formula $H{}_{i+1}$
\end_inset

 can be created by adding the root of one 
\begin_inset Formula $H_{i}$
\end_inset

 as a new child under another 
\begin_inset Formula $H_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\end_layout

\end_inset

 Note some properties of binomial trees (easily proven by induction):
\end_layout

\begin_layout Itemize
\begin_inset Formula $H_{i}$
\end_inset

 contains 
\begin_inset Formula $2^{i}$
\end_inset

 vertices, has height 
\begin_inset Formula $i$
\end_inset

, and the root of 
\begin_inset Formula $H_{i}$
\end_inset

 has 
\begin_inset Formula $i$
\end_inset

 children.
\end_layout

\begin_layout Itemize
The 
\begin_inset Formula $i$
\end_inset

 child subtrees of an 
\begin_inset Formula $H_{i}$
\end_inset

 are isomorphic to 
\begin_inset Formula $H_{i-1},H_{i-2},\dotsc,H_{1},H_{0}$
\end_inset

.
\end_layout

\begin_layout Itemize
We have a simple way of joining two trees of the same rank
\begin_inset space ~
\end_inset


\begin_inset Formula $i$
\end_inset

, which creates a tree of rank 
\begin_inset Formula $i+1$
\end_inset

 (in constant time).
 We choose the order of joining by the priorities of the two roots to preserve
 the heap ordering.
\end_layout

\begin_layout Definition*

\emph on
Binomial heap
\emph default
 is a collection of binomial trees of 
\emph on
different
\emph default
 ranks.
\end_layout

\begin_layout Paragraph
Shape:
\end_layout

\begin_layout Standard
The heap is usually implemented as an array of binomial trees that is indexed
 by ranks.
 Note the correspondence to binary numbers: any binomial tree of rank 
\begin_inset Formula $i$
\end_inset

 can only represent a heap of size 
\begin_inset Formula $2^{i}$
\end_inset

, and no two trees of the same rank can occur, so the shape of a binomial
 heap containing 
\begin_inset Formula $n$
\end_inset

 elements is exactly given by the binary representation of the number 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Paragraph
Potential:
\end_layout

\begin_layout Standard
For amortized analysis we choose the potential as 
\emph on
the number of binomial trees
\emph default
 in the heap, which is between 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $\left\lceil \log n\right\rceil $
\end_inset

.
\end_layout

\begin_layout Paragraph

\noun on
Meld:
\end_layout

\begin_layout Standard
It works as an analogy to binary addition.
 We start from the lowest ranks, and whenever we encounter two trees of
 the same rank, we join them.
 Together it obviously takes 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 time where 
\begin_inset Formula $n:=n_{1}+n_{2}$
\end_inset

 is the size of the resulting heap.
 As the total potential can only change by 
\begin_inset Formula $\Opar{\log n}$
\end_inset

, we also have the amortized complexity 
\begin_inset Formula $\Opar{\log n}$
\end_inset

.
\end_layout

\begin_layout Paragraph

\series bold
\noun on
Insert:
\series default
\noun default
 
\end_layout

\begin_layout Standard
It can be done by 
\noun on
meld
\noun default
 with a tree of rank zero.
 Thus the worst-case complexity is 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

.
 We can easily prove that the amortized complexity of 
\noun on
insert
\noun default
 is 
\begin_inset Formula $\Thpar 1$
\end_inset

: we 
\begin_inset Quotes eld
\end_inset

flip some number of bits from one to zero and one bit from zero to one
\begin_inset Quotes erd
\end_inset

, so the decrease in potential pays for longer insertions.
 As a consequence we can asymptotically afford to build binomial heaps by
 insertions, as it only takes 
\begin_inset Formula $\Thpar n$
\end_inset

 time in the worst case.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Paragraph

\series bold
\noun on
DelMin:
\end_layout

\begin_layout Standard
We start by finding a tree that contains the smallest priority in the root,
 and we remove that tree.
 Children of its root form a collection of binomial trees, so we 
\noun on
meld
\noun default
 them with the rest of the heap, as if they were another binomial heap.
 Together 
\noun on
delMin
\noun default
 takes 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 both worst-case and amortized time.
\end_layout

\begin_layout Paragraph

\series bold
\noun on
Decrease
\series default
\noun default

\begin_inset space ~
\end_inset


\series medium
and
\series default

\begin_inset space ~
\end_inset


\series bold
\noun on
increase:
\end_layout

\begin_layout Standard
They can be done like in regular heaps by 
\noun on
up
\noun default
 and 
\noun on
down
\noun default
 operations.
 The length of any path is bounded by 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

.
 When going up, we only need constant work on every level, which gives us
 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 worst-case time bound.
 When going down, we need to choose a child with the smallest priority on
 every level, so the bound is 
\begin_inset Formula $\Thpar{\log^{2}n}$
\end_inset

.
 The potentials are not touched, so the amortized complexities are the same.
\end_layout

\begin_layout Paragraph

\noun on
Delete:
\end_layout

\begin_layout Standard
As in many heaps, deleting arbitrary element can be done by decreasing the
 priority to 
\begin_inset Quotes eld
\end_inset

minus infinity
\begin_inset Quotes erd
\end_inset

, and then removing this minimum.
 Here this approach needs 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 time, both worst-case and amortized.
\end_layout

\begin_layout Note*
As is usual in heaps, we can maintain a pointer to an element with the smallest
 priority without increasing asymptotic complexities of the operations.
\end_layout

\begin_layout Corollary*
Binomial heaps need 
\begin_inset Formula $\Thpar n$
\end_inset

 space.
 In the worst case we have all operations in 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 except for: 
\noun on
increase
\noun default
 in 
\begin_inset Formula $\Thpar{\log^{2}n}$
\end_inset

, 
\noun on
min
\noun default
 in 
\begin_inset Formula $\Thpar 1$
\end_inset

 and
\noun on
 makeHeap
\noun default
 in 
\begin_inset Formula $\Thpar n$
\end_inset

.
 Amortized bounds are asymptotically the same but for 
\begin_inset Formula $\Thpar 1$
\end_inset

 
\noun on
insert
\noun default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
To sum up, the asymptotic comlexities are almost the same as for leftist
 heaps.
 The only difference is amortized 
\begin_inset Formula $\Theta\left(1\right)$
\end_inset

 
\noun on
insert
\noun default
 (better) and 
\begin_inset Formula $\Theta\left(\log^{2}n\right)$
\end_inset

 
\noun on
increase
\noun default
 (worse).
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Lazy binomial heaps
\end_layout

\begin_layout Standard
Now we modify the operations to be lazy
\begin_inset space ~
\end_inset

-- we postpone as much work as possible and hope we can avoid most of it
 :-) As a result, work can accumulate and the worst-case complexities grow,
 but amortized complexities decrease for some operations.
\end_layout

\begin_layout Standard
We no longer require that the binomial trees have different ranks, so we
 have no bound on their number, and we store them in a list (often a doubly-link
ed circular list held by a minimal root).
\end_layout

\begin_layout Definition*
Lazy binomial heap is a doubly linked list of binomial trees.
\end_layout

\begin_layout Standard
We leave the amortization potential as the number trees in the heap.
 
\series bold
\noun on
Meld
\series default
\noun default
 just concatenates two lists and 
\series bold
\noun on
insert
\series default
\noun default
 adds one leaf to it, so both operations need 
\begin_inset Formula $\Theta\left(1\right)$
\end_inset

 both amortized and worst-case time.
 
\series bold
\noun on
decrease
\series default
\noun default
 and 
\series bold
\noun on
increase
\series default
\noun default
 operations are the same as in strict heaps.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection*
Finding a minimum
\end_layout

\begin_layout Standard
The problem is to find another minimum after we delete the old one
\begin_inset space ~
\end_inset

-- we have to walk through the whole list that can have length up to
\begin_inset space ~
\end_inset


\begin_inset Formula $n$
\end_inset

.
 When we do the work, we also 
\series bold
reorganize
\series default
 the list as follows.
\end_layout

\begin_layout Paragraph
Algorithm:
\end_layout

\begin_layout Standard
We create a temporary array indexed by tree ranks (we have a 
\begin_inset Formula $\log n$
\end_inset

 bound on ranks).
 Then we push the whole list into it, merging as many trees as possible,
 and finally we convert the array back into a linked list.
 
\end_layout

\begin_layout Paragraph
Analysis:
\end_layout

\begin_layout Standard
When we merge a tree under another vertex, we decrease the potential by
 one, which is enough to pay for all the work done with that tree, including
 that step in the linked list.
 At the end we have at most 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 trees which were unpaid for, so the amortized cost of reorganization is
 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Algorithm details:
\end_layout

\begin_layout Standard
If the implementation maintains a pointer to a minimum root, 
\series bold
\noun on
delMin
\series default
\noun default
 first cuts it, then 
\noun on
meld
\noun default
s its children into the list, reorganizes it, and finally finds a new minimum.
 Otherwise 
\noun on
delMin
\noun default
 first reorganizes, then finds the minimum, cuts it, and 
\noun on
meld
\noun default
s the children.
 In either case we do 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 work and a reorganization, which is 
\begin_inset Formula $\Thpar n$
\end_inset

 in the worst case but 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 amortized.
 General 
\series bold
\noun on
delete
\series default
\noun default
 again works like 
\noun on
decrease
\noun default
 and 
\noun on
delMin
\noun default
 combined, so it needs the same asymptotic time.
\end_layout

\begin_layout Corollary*
The complexities of lazy binomial heaps only differ (from strict ones) in
 worst-case time complexity of some operations: 
\noun on
delMin 
\noun default
and
\noun on
 delete
\noun default
 need 
\begin_inset Formula $\Thpar n$
\end_inset

 time, 
\noun on
insert
\noun default
 and 
\noun on
meld
\noun default
 need 
\begin_inset Formula $\Thpar 1$
\end_inset

.
 (Amortized complexities remain the same.)
\end_layout

\begin_layout Standard
Lazy binomial heaps do not seem to be an improvement, and they are rather
 an intermediate step towards the final structure.
 Our main long-term aim was to speed up 
\noun on
decrease
\noun default
, which is needed e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

for asymptotically fast Dijkstra's algorithm.
 We improve it to 
\begin_inset Formula $\OO(1)$
\end_inset

 in the following structure.
\end_layout

\begin_layout Subsection
Fibonacci heaps
\end_layout

\begin_layout Standard
Now we even drop the condition that the trees are binomial, so the shape
 is not explicitly defined.
 We guarantee that any vertex can only lose one child since the last moment
 it was in a root.
 We add an indicator into every vertex telling whether it has already lost
 a child or not, so we can maintain the property.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
Bounding vertex degrees
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "fibonacci-lemma-old-child"

\end_inset

Let 
\begin_inset Formula $v$
\end_inset

 be a vertex in a Fibonacci heap and let 
\begin_inset Formula $u$
\end_inset

 be its 
\begin_inset Formula $i$
\end_inset

-th oldest child.
 (Age counts from the moment a child is adopted by its current parent.) Then
 
\begin_inset Formula $u$
\end_inset

 has at least 
\begin_inset Formula $i-2$
\end_inset

 children.
\end_layout

\begin_deeper
\begin_layout Proof
Let us look at the moment when 
\begin_inset Formula $u$
\end_inset

 was joined under 
\begin_inset Formula $v$
\end_inset

.
 The 
\begin_inset Formula $i-1$
\end_inset

 older children of 
\begin_inset Formula $v$
\end_inset

 were there, and both 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 had the same number of children.
 Since then 
\begin_inset Formula $u$
\end_inset

 could have lost only one child, because it is not a root, so it still has
 at least 
\begin_inset Formula $i-2$
\end_inset

 children.
\end_layout

\end_deeper
\begin_layout Definition*
\begin_inset CommandInset label
LatexCommand label
name "Fibonacci numbers"

\end_inset

 Denote the 
\begin_inset Formula $i$
\end_inset

-th 
\emph on
Fibonacci number
\emph default
 by 
\begin_inset Formula $F_{i}$
\end_inset

: 
\begin_inset Formula $F_{0}:=0$
\end_inset

, 
\begin_inset Formula $F_{1}:=1$
\end_inset

, 
\begin_inset Formula $F_{i+2}:=F_{i+1}+F_{i}$
\end_inset

.
\end_layout

\begin_layout Lemma*
Any subtree of a vertex with 
\begin_inset Formula $i$
\end_inset

 children contains at least 
\begin_inset Formula $F_{i+2}$
\end_inset

 vertices.
\end_layout

\begin_deeper
\begin_layout Proof
By induction on 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Case
\begin_inset Formula $i=0$
\end_inset

.
 It is just one leaf, and 
\begin_inset Formula $F_{0+2}=1$
\end_inset

.
\end_layout

\begin_layout Case
\begin_inset Formula $i\ge1$
\end_inset

.
 Let us look at the children from the oldest one, and apply
\begin_inset space ~
\end_inset

Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fibonacci-lemma-old-child"

\end_inset

 on them.
 We get lower bounds on sizes of their subtrees: the total number of vertices
 including the root is at least 
\begin_inset Formula $1+\sum_{j=1}^{i}F_{j}$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Proof
Now we show that 
\begin_inset Formula $1+\sum_{j=1}^{i}F_{j}=F_{i+2}$
\end_inset

, which is easy by induction:
\end_layout

\begin_deeper
\begin_layout Case
\begin_inset Formula $i=0$
\end_inset

.
 
\begin_inset Formula $1=F_{2}$
\end_inset

.
\end_layout

\begin_layout Case
\begin_inset Formula $i\ge1$
\end_inset

.
 
\begin_inset Formula $1+\sum_{j=1}^{i}F_{j}\,=\,1+\sum_{j=1}^{i-1}F_{j}+F_{i}\,=\, F_{i+1}+F_{i}\,=\, F_{i+2}.$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Fact
\begin_inset CommandInset label
LatexCommand label
name "fact:Fibonacci-exponential"

\end_inset


\begin_inset Formula $F_{i}=\frac{1}{\sqrt{5}}\left[\varphi^{i}-\left(1-\varphi\right)^{i}\right]\ge\frac{1}{\sqrt{5}}\varphi^{i-1}$
\end_inset

 where 
\begin_inset Formula $\varphi:=\frac{1+\sqrt{5}}{2}\doteq1.62$
\end_inset

 is the golden ratio.
\end_layout

\begin_layout Proof
A straightforward exercise.
 First, the equality follows by induction on 
\begin_inset Formula $i$
\end_inset

, using that 
\begin_inset Formula $\varphi+1=\varphi^{2}$
\end_inset

.
 For the inequality we use 
\begin_inset Formula $0<\left(1-\varphi\right)<1<\varphi$
\end_inset

: 
\begin_inset Formula 
\[
F_{i}=\frac{1}{\sqrt{5}}\left[\varphi^{i}-\left(1-\varphi\right)^{i}\right]=\frac{1}{\sqrt{5}}\left[\varphi^{i-1}+\underbrace{\varphi^{i-2}}_{\ge1}-\underbrace{(1-\varphi)^{i}}_{\le1}\right]\ge\frac{1}{\sqrt{5}}\varphi^{i-1}.
\]

\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "fibonacci-child-count"

\end_inset

The degree of any vertex in a Fibonacci heap is 
\begin_inset Formula $\Opar{\log n}$
\end_inset

.
\emph on

\begin_inset Newline newline
\end_inset

The bound is approximately 
\begin_inset Formula $1.44\cdot\log n$
\end_inset

, alike to depth bound for AVL trees.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
Operation algorithms and analyses
\end_layout

\begin_layout Standard
The 
\series bold
potential
\series default
 will be the the number of trees plus twice the number of vertices with
 their indicator set to true.
\end_layout

\begin_layout Standard
Again, 
\series bold
\noun on
meld
\series default
\noun default
 just concatenates two lists and 
\series bold
\noun on
insert
\series default
\noun default
 adds one leaf to it, so both operations are still 
\begin_inset Formula $\Thpar 1$
\end_inset

 amortized and worst-case.
\end_layout

\begin_layout Standard

\series bold
\noun on
DelMin
\series default
\noun default
 also just removes a minimum root and reorganizes the list.
 The number of marked vertices can only decrease, so we use Corollary
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fibonacci-child-count"

\end_inset

 with the reorganization accounting from lazy binomial heaps to get 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 amortized bound (it is 
\begin_inset Formula $\Thpar n$
\end_inset

 in the worst case).
\end_layout

\begin_layout Standard
All other problems are solved by 
\series bold
cutting
\series default
 vertices and reinserting them into the list of trees.
 We mark the parent and increase the number of trees, so a single cut costs
 us 
\begin_inset Formula $\Thpar 1$
\end_inset

 real work plus potential increase by 
\begin_inset Formula $3$
\end_inset

.
 However, if the parent was already marked before, we would be in an inconsisten
t state, so we also cut this parent the same way, which can cascade.
 We argue that resolving each such 
\begin_inset Quotes eld
\end_inset

doubly-marked
\begin_inset Quotes erd
\end_inset

 vertex can be paid from potential decrease: we remove a double-mark, add
 one mark, and add one tree, so the potential decreases by one.
 As a result the cutting is 
\begin_inset Formula $\Thpar 1$
\end_inset

 amortized (but 
\begin_inset Formula $\Thpar n$
\end_inset

 in the worst case).
\end_layout

\begin_layout Note*
We could not afford 
\noun on
up
\noun default
 or 
\noun on
down
\noun default
 operations, because the trees may degenerate to paths of length up to 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\series bold
\noun on
decrease
\series default
\noun default
 breaks the heap condition with the parent, we cut the vertex and reinsert
 it with decreased priority, which is 
\begin_inset Formula $\Thpar 1$
\end_inset

 amortized.
 In 
\series bold
\noun on
increase
\series default
\noun default
 we need to cut not only the vertex but also all its children, so by using
 Corollary
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fibonacci-child-count"

\end_inset

 we prove 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 amortized time.
\end_layout

\begin_layout Standard
As in lazy binomial heaps, general 
\series bold
\noun on
delete
\series default
\noun default
 is implemented via 
\noun on
decrease
\noun default
 and 
\noun on
delMin
\noun default
, and we can build the heap by insertions in total 
\begin_inset Formula $\Thpar n$
\end_inset

 time.
\end_layout

\begin_layout Corollary*
Fibonacci heaps need 
\begin_inset Formula $\Thpar n$
\end_inset

 space.
 In the worst case we have all operations in 
\begin_inset Formula $\Thpar n$
\end_inset

 except for 
\noun on

\begin_inset Formula $\Thpar 1$
\end_inset

 min
\noun default
, 
\noun on
insert
\noun default
 and 
\noun on
meld
\noun default
.
 Amortized bounds are asymptotically the same except for 
\begin_inset Formula $\Thpar 1$
\end_inset

 
\noun on
decrease
\noun default
 and 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 
\noun on
increase
\noun default
, 
\noun on
delMin
\noun default
 and 
\noun on
delete
\noun default
.
\end_layout

\begin_layout Standard
That is, in comparison with lazy binomial heaps, we increased the worst-case
 complexities of several operations to 
\begin_inset Formula $\Thpar n$
\end_inset

, but we improved the amortized bounds of 
\noun on
decrease
\noun default
 to 
\begin_inset Formula $\Thpar 1$
\end_inset

 and 
\noun on
increase
\noun default
 to 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

.
 You can review the comparison (again) in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand vref
reference "tab:heaps"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Application to Dijkstra's algorithm
\end_layout

\begin_layout Standard
Dijkstra's algorithm is a classical application for heaps.
 The input is an undirected combinatorial graph with 
\begin_inset Formula $n$
\end_inset

 nodes and 
\begin_inset Formula $m$
\end_inset

 edges.
 The edges are weighted by nonnegative numbers.
 The algorithm computes the lengths of all shortest paths from a given starting
 node.
 It uses a heap of the nodes (so it has size at most 
\begin_inset Formula $n$
\end_inset

), and its asymptotical complexity can be bounded by 
\begin_inset Formula $n\times$
\end_inset

using operations 
\noun on
insert
\noun default
 and 
\noun on
delete
\noun default
, and 
\begin_inset Formula $m\times$
\end_inset

using 
\noun on
decrease
\noun default
.
\end_layout

\begin_layout Standard
When we use the Fibonacci heap (which is the most efficient in asymptotic
 amortized sense), we get a time bound of 
\begin_inset Formula $\OO\left(m+n\log n\right)$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Using 
\begin_inset Formula $d$
\end_inset

-regular heaps
\end_layout

\begin_layout Standard
The problem with Fibonacci heap is that it is quite complicated, and thus
 the multiplicative constants in time and space bounds are much higher than
 for many simpler heaps.
 We now show that for 
\begin_inset Quotes eld
\end_inset

most
\begin_inset Quotes erd
\end_inset

 graphs we can achieve the same asymptotic performance with 
\begin_inset Formula $d$
\end_inset

-regular heaps if we set 
\begin_inset Formula $d:=\min\left\{ 2,\,\Thpar{m/n}\right\} $
\end_inset

.
\end_layout

\begin_layout Standard
Remember that 
\noun on
insert
\noun default
 and 
\noun on
decrease
\noun default
 need time 
\begin_inset Formula $\Thpar{\log_{d}n}$
\end_inset

 and 
\noun on
delete
\noun default
 needs 
\begin_inset Formula $\Thpar{d\log_{d}n}$
\end_inset

 (all worst-case).
\end_layout

\begin_layout Case
Sparse graphs,
\begin_inset space ~
\end_inset

i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset


\begin_inset Formula $m=\Opar n$
\end_inset

.
 In that case we have 
\begin_inset Formula $d=\Thpar 1$
\end_inset

, so every operation only needs 
\begin_inset Formula $\Thpar{\log n}$
\end_inset

 time, and the total complexity is 
\begin_inset Formula $\Opar{n\log n}$
\end_inset

, which is the same as Fibonacci heaps for that case.
\end_layout

\begin_layout Case
Dense graphs where 
\begin_inset Formula $\exists\epsilon>0:\; m\approx n^{1+\epsilon}$
\end_inset

.
 In that case we have 
\begin_inset Formula $d\approx n^{\epsilon}$
\end_inset

, so each of the the cheaper operations need 
\begin_inset Formula $\approx\log n\,/\,\log\left(n^{\epsilon}\right)=1/\epsilon$
\end_inset

, and each 
\noun on
delete
\noun default
 needs 
\begin_inset Formula $\approx d/\epsilon\approx n^{\epsilon}/\epsilon$
\end_inset

.
 That gives us compexity for Dijkstra bounded by 
\begin_inset Formula $\apprle m\cdot1/\epsilon+n\cdot n^{\epsilon}/\epsilon\approx m/\epsilon$
\end_inset

, which is the same as Fibonacci heaps for that case (for a bounded 
\begin_inset Formula $\epsilon$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Memory hierarchies (caches)
\end_layout

\begin_layout Subsubsection
Literature
\end_layout

\begin_layout Standard
The 
\emph on
Handbook of Data Structures and Applications
\emph default
 textbook devotes Chapter
\begin_inset space ~
\end_inset

34 to this topic.
 
\emph on
Introduction to Algorithms
\emph default
 still does not contain anything on this topic (in its third edition).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Hashing 
\begin_inset CommandInset label
LatexCommand label
name "part:Hashing"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100col%"
height "0.1ex"

\end_inset


\end_layout

\begin_layout Subsection*
Warning!
\end_layout

\begin_layout Subsubsection*
The content in this hashing part follows older version on the lecture.
\end_layout

\begin_layout Subsection*
\begin_inset CommandInset line
LatexCommand rule
offset "0ex"
width "100col%"
height "0.1ex"

\end_inset


\end_layout

\begin_layout Section
The dictionary problem
\end_layout

\begin_layout Itemize
We are solving the 
\emph on
(unordered) dictionary problem
\emph default
: we have some universe set 
\begin_inset Formula $U=\{0,\dotsc,N-1\}$
\end_inset

 and we want to store a set 
\begin_inset Formula $S\subseteq U$
\end_inset

, 
\begin_inset Formula $|S|=n$
\end_inset

, only using 
\begin_inset Formula $\OO(n)$
\end_inset

 space (typically 
\begin_inset Formula $N\gg n$
\end_inset

).
 To do so, we use an array of length 
\begin_inset Formula $m=\Theta\left(n\right)$
\end_inset

 and hash functions of type 
\begin_inset Formula $h:U\rightarrow\{0,\dotsc,m-1\}$
\end_inset

.
\end_layout

\begin_layout Itemize
In these dictionaries we need to support operations 
\noun on
insert
\noun default
, 
\noun on
delete
\noun default
 and 
\noun on
member
\noun default
 for manipulating the represented set 
\begin_inset Formula $S$
\end_inset

.
 Moreover, we aim to implement them in 
\begin_inset Formula $\OO(1)$
\end_inset

 expected (amortized) time.
\end_layout

\begin_layout Itemize
Usual assumptions:
\end_layout

\begin_deeper
\begin_layout Itemize
The hash function can be evaluated in 
\begin_inset Formula $\OO(1)$
\end_inset

 time and it uniformly distributes the universe set (i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset


\begin_inset Formula $\forall y_{1},y_{2}\;\left|h^{-1}(y_{1})\right|-\left|h^{-1}(y_{2})\right|\le1$
\end_inset

).
\end_layout

\begin_layout Itemize
Any element of the universe set is equally likely to be an argument of any
 of the operations (used in most expected-time analyses).
 Note that this assumption is very unrealistic; it can be avoided with universal
 and perfect hashing.
\end_layout

\end_deeper
\begin_layout Itemize
Sometimes we will need to 
\emph on
rehash
\emph default
: iterate over the contents of the whole structure, insert all the keys
 into a new hash table (possibly with different setting of 
\begin_inset Formula $m$
\end_inset

, 
\begin_inset Formula $h$
\end_inset

, etc.) and delete the old structure.
\end_layout

\begin_layout Itemize
The event that two different elements in 
\begin_inset Formula $S$
\end_inset

 have the same hash is called a 
\emph on
collision
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Separate chaining
\end_layout

\begin_layout Itemize
The simplest method: our array contains singly linked lists of elements
 to resolve hash collisions.
 On index 
\begin_inset Formula $i$
\end_inset

 the array has a linked list that contains the set 
\begin_inset Formula $\{x\in S\mid h(x)=i\}$
\end_inset

.
\end_layout

\begin_layout Itemize
When performing an operation on the argument 
\begin_inset Formula $x$
\end_inset

, we first compute 
\begin_inset Formula $i=h(x)$
\end_inset

 and only work with the 
\begin_inset Formula $i$
\end_inset

-th linked list.
 The operations 
\noun on
insert
\noun default
, 
\noun on
delete
\noun default
 and 
\noun on
member
\noun default
 on a linked list need time proportional to the length of the list.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:hash-chosen-chain"

\end_inset

The expected length of a chosen chain equals 
\begin_inset Formula $\frac{n}{m}\equiv\alpha$
\end_inset

 (
\emph on

\begin_inset Quotes eld
\end_inset

load factor
\emph default

\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_deeper
\begin_layout Proof
Following from the uniformity assumptions, the length of a chain is distributed
 according to binomial distribution 
\begin_inset Formula $\Bi\left(n,\frac{1}{m}\right)$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
The distribution would only be exactly binomial if the elements in 
\begin_inset Formula $S$
\end_inset

 were chosen 
\begin_inset Quotes eld
\end_inset

with replacement
\begin_inset Quotes erd
\end_inset

.
 However, it's still an upper bound and it's very close in the typical case
 of 
\begin_inset Formula $n\ll N$
\end_inset

.
\end_layout

\end_inset

 It only remains to prove that 
\begin_inset Formula $\Exp{\Bi(n,p)}=np$
\end_inset

 (easy exercise).
\end_layout

\end_deeper
\begin_layout Standard
Similarly, 
\begin_inset Formula $\Var{\Bi\left(n,p\right)}=np(1-p)<np$
\end_inset

, so we get variance even lower than 
\begin_inset Formula $\alpha$
\end_inset

.
\end_layout

\begin_layout Theorem*
The expected length of the longest chain is 
\begin_inset Formula $\Theta\left(\frac{\log n}{\log\log n}\right)$
\end_inset

 (for 
\begin_inset Formula $n\in\interval{m/2}m$
\end_inset

).
 
\end_layout

\begin_layout Theorem*
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Proof in Czech lecture, but very technical, about 1 A4 page.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
However, it is possible to have all the elements in one chain, so the wost-case
 complexity is 
\begin_inset Formula $\OO(n)$
\end_inset

.
 Note that such inputs could be chosen by malicious attacker if (s)he just
 knows 
\begin_inset Formula $h$
\end_inset

 (DOS attacks based on this exist in practice).
\end_layout

\begin_layout Itemize
We usually insert elements to the front of the list.
 It is also possible to insert at the end of the list or to maintain the
 list in sorted order.
 Maintaining sorted order allows us to reduce the time needed for unsuccessful
 searches in the list
\begin_inset space ~
\end_inset

-- on average we save half of the time (the asymptotic times are unchanged
 in any of these cases).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Periodic rebuilding
\end_layout

\begin_layout Standard
Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:hash-chosen-chain"

\end_inset

 suggests we should use a table of 
\begin_inset Formula $m=\Theta(n)$
\end_inset

.
 That way we get expected times of operations 
\begin_inset Formula $\Theta\left(\frac{n}{m}\right)=\Theta(1)$
\end_inset

 and the needed space is 
\begin_inset Formula $\Theta(n+m)=\Theta(n)$
\end_inset

, which is optimal (we need to store the 
\begin_inset Formula $n$
\end_inset

 elements).
 To maintain the property, we can for example choose two constants and maintain
 
\begin_inset Formula $\frac{n}{m}\in\interval{\alpha_{1}}{\alpha_{2}}$
\end_inset

.
 Whenever we break the constraint, we rehash the whole table with 
\begin_inset Formula $m:=\frac{2}{\alpha_{1}+\alpha_{2}}n$
\end_inset

 (that changes
\begin_inset space ~
\end_inset


\begin_inset Formula $h$
\end_inset

).
 The rehash takes 
\begin_inset Formula $\Theta(n+m)$
\end_inset

 time (in this sentence, 
\begin_inset Formula $m$
\end_inset

 is the value 
\emph on
before
\emph default
 rehash), but we had to do at least 
\begin_inset Formula $\frac{\alpha_{2}-\alpha_{1}}{2}m$
\end_inset

 insertions or deletions since the last rehash, so the time can be 
\emph on
amortized
\emph default
 into additional 
\begin_inset Formula $\Theta(1)$
\end_inset

 time per modifying operation (amortization is discussed in
\begin_inset space ~
\end_inset

Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:amortized"

\end_inset

).
\end_layout

\begin_layout Subsection
Storing chains in the array
\end_layout

\begin_layout Standard
The array normally only contains pointers to the beginnings of the lists,
 but it is also possible to implement the linked lists inside of the array
 (we need 
\begin_inset Formula $m\ge n$
\end_inset

).
 We show two methods.
 In both we need to be able to find a free index in the array in constant
 time, which can be accomplished by maintaining another chain with all free
 positions.
 The operation complexities only differ by constant amount needed for an
 extra test or relocation.
\end_layout

\begin_layout Paragraph
Hashing with relocations:
\end_layout

\begin_layout Standard
every index of the array contains fields 
\family sans
key
\family default
, 
\family sans
next
\family default
 and 
\family sans
prev,
\family default
 where 
\family sans
next
\family default
 and 
\family sans
prev
\family default
 act as pointers in a doubly linked list containing the chain.
 When inserting into a nonempty list, we find an empty index of the array,
 store the 
\family sans
key
\family default
 in it and connect it with the list.
 When inserting into an empty list, it can happen that the index where the
 list should start is occupied by another item.
 In this situation we first have to 
\emph on
move
\emph default
 the item to another free position (that's why the list is doubly linked).
 To find the free space quickly, we may e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

maintain also doubly linked list of the empty positions in the same way.
\end_layout

\begin_layout Paragraph
Hashing with two pointers:
\end_layout

\begin_layout Standard
as the need to move elements is annoying, we show a modified scheme where
 every index of the array contains fields 
\family sans
begin
\family default
, 
\family sans
key
\family default
 and 
\family sans
next
\family default
.
 
\family sans
Begin
\family default
 contains the index where the corresponding chain starts or a special value
 if that chain is empty.
 The other two fields form the actual singly linked lists: 
\family sans
key
\family default
 contains the stored key and 
\family sans
next
\family default
 contains the index of the next element in the chain or a special value
 if this is the last item.
 To find the free space quickly, we may e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

maintain also 
\emph on
singly
\emph default
 linked list of the empty positions as a LIFO stack.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Coalesced hashing
\end_layout

\begin_layout Itemize
We want to store the chains in the array and want to save more space, although
 it can make the chains longer (again, we need 
\begin_inset Formula $m\ge n$
\end_inset

).
 The array items contains fields 
\family sans
key
\family default
 and 
\family sans
next
\family default
, the chains are formed by the 
\family sans
next
\family default
 links.
 There are two groups of methods:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Standard coalesced hashing
\emph default
 (SCH) uses a standard array of length 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Itemize

\emph on
Coalesced hashing
\emph default
 (CH) uses a little longer array, where the auxiliary part is used for better
 handling of collisions (so the chains coalesce less).
 When finding a free position for a new 
\emph on
colliding
\emph default
 element, we first check the auxiliary part.
 Consequently, until the auxiliary part fills up, the chains don't coalesce
 (they are separated).
\end_layout

\end_deeper
\begin_layout Itemize
Since the chains coalesce, we can't in general case perform efficient deletion.
 Instead, we mark the elements as deleted, so we can skip them while searching
 without breaking the chain (
\emph on
fake
\emph default
 
\emph on
deletion
\emph default
).
 These ghosts can be replaced by other insertions into that chain, but in
 general we may have to rehash the table after performing many deletions
 (omitting the marked elements).
\end_layout

\begin_layout Itemize
There are various methods of CH and SCH that differ in the point of insertion
 into chains.
\end_layout

\begin_deeper
\begin_layout Itemize
EICH and EISCH (
\emph on
early insertion
\emph default
) insert the elements after the first element in the chain.
\end_layout

\begin_layout Itemize
LICH and LISCH (
\emph on
late insertion
\emph default
) insert the elements after the last element in the chain.
\end_layout

\begin_layout Itemize
VICH (
\emph on
varied insertion
\emph default
) works like LICH in the auxiliary part and like EICH in the main part of
 the table.
 That is, the new element is put after the last element in the chain that
 is still in the auxiliary part of the table (or after the first element
 if the whole chain is in the main part).
\end_layout

\end_deeper
\begin_layout Itemize
When maintaining a constant load factor 
\begin_inset Formula $\alpha$
\end_inset

, all the coalesced methods have expected 
\begin_inset Formula $\OO(1)$
\end_inset

 performance.
 Generally, the auxiliary memory in CH methods helps to speed up the operations
 in comparison to SCH methods.
 Early insertion is considered better than late insertion because usually
 it holds that the elements inserted later are more likely to be accessed.
 The VICH method has the best performance.
\end_layout

\begin_layout Itemize
All coalesced methods perform well even when filling the whole table, having
 at most around 
\begin_inset Formula $2$
\end_inset

 expected tests per operation (averaging over all possible inputs).
 It is recommended to divide the memory between main and auxiliary part
 of the array in ratio around 
\begin_inset Formula $85\%:15\%$
\end_inset

.
 
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
In the Czech classes, there is an analysis of *ISCH number of tests.
 It's technical and about 1-2 A4 pages long.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Open addressing
\end_layout

\begin_layout Itemize
We want to get rid of the additional fields in the array and so further
 improve the constant involved in memory consumption.
 These techniques are the most popular in practice, although they are more
 sensitive to a bad choice of the hash function for the input (in practice
 it usually doesn't hold that all inputs are equally probable, which can
 break our average-case analyses).
\end_layout

\begin_layout Itemize
The array only contains the keys and chains always start on their given
 indices, so the chains for different hashes can coalesce.
 It follows that in general we can only perform fake deletions like in coalesced
 hashing.
\end_layout

\begin_layout Itemize
All the algorithms iterate over the indices belonging into the chain until
 they find an empty space (the end of the chain).
 It is clear that when the table fills up, all the elements coalesce into
 one huge chain.
 That's why we have to keep lower load factor than in other hashing methods
 (we can afford that, because we use the memory more efficiently).
\end_layout

\begin_layout Itemize
We show two methods that differ in the way of finding the next index of
 the element in the chain.
\end_layout

\begin_layout Subsection
Hashing with linear probing
\end_layout

\begin_layout Itemize
Hashing with linear probing chooses the next index in the array as the position
 of the following element (circularly, going to the first index after the
 last).
 That makes the algorithm very simple and it behaves well with memory caches.
 
\end_layout

\begin_layout Itemize
The load factor has to be kept low to prevent forming too long chains (
\begin_inset Formula $\alpha<0.7$
\end_inset

 is recommended).
 The method is also very sensitive to breaking the uniformity assumptions.
\end_layout

\begin_layout Itemize
When 
\begin_inset Formula $\alpha\le\alpha'$
\end_inset

 for any fixed 
\begin_inset Formula $\alpha'<1$
\end_inset

, the algorithms need 
\begin_inset Formula $\OO(1)$
\end_inset

 expected time per operation.
\end_layout

\begin_layout Subsection
Double hashing
\end_layout

\begin_layout Itemize
Double hashing uses two hash functions 
\begin_inset Formula $h_{1}$
\end_inset

, 
\begin_inset Formula $h_{2}$
\end_inset

 where 
\begin_inset Formula $h_{2}(x)\neq0$
\end_inset

.
 For an element 
\begin_inset Formula $x$
\end_inset

, the position of 
\begin_inset Formula $i$
\end_inset

-th element of its chain is 
\begin_inset Formula $\left(h_{1}(x)+ih_{2}(x)\right)\bmod m$
\end_inset

.
 In order to cover the whole array with any of those sequences, we need
 
\begin_inset Formula $\gcd\left(h_{2}(x),m\right)=1$
\end_inset

 which is easily achieved by choosing prime 
\begin_inset Formula $m$
\end_inset

.
\end_layout

\begin_layout Itemize
The hashing with linear probing is a special case with 
\begin_inset Formula $h_{2}(x)=1$
\end_inset

.
\end_layout

\begin_layout Itemize
Since for every element the chain jumps over different locations in the
 table, the coalescing isn't so severe.
 The recommended load factor is 
\begin_inset Formula $\alpha<0.9$
\end_inset

.
\end_layout

\begin_layout Itemize
Restricting 
\begin_inset Formula $m$
\end_inset

 to primes can be a problem when resizing the table.
 It holds that 
\begin_inset Formula $\forall k>0\ \exists\,\mbox{prime}\in\interval k{2k}$
\end_inset

, no fast algorithm is known for finding any.
 (In
\begin_inset space ~
\end_inset

practice we could precompute a suitable sequence of primes in advance.)
\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Plain Layout
Czech classes contain analysis of performance conditioned by full randmoness
 of the sequence of probes (which can't be fulfilled; length 
\begin_inset Formula $\sim$
\end_inset

1/3 A4).
\end_layout

\end_inset


\end_layout

\begin_layout Section
Universal hashing 
\begin_inset CommandInset label
LatexCommand label
name "sec:Universal-hashing"

\end_inset


\end_layout

\begin_layout Itemize
Universal hashing methods drop the unrealistic assumption that all elements
 of the universe are equally likely to be present in the input.
 It bounds the running time for 
\emph on
any
\emph default
 input averaging over outputs of a (pseudo)random generator.
\end_layout

\begin_layout Itemize
The basic method works just like hashing with separate chaining with the
 difference that the hash function is previously randomly chosen from a
 universal family of functions.
\end_layout

\begin_layout Itemize
A family of functions 
\begin_inset Formula $H=\{h_{i}\mid i\in I\}$
\end_inset

, 
\begin_inset Formula $h_{i}:U\rightarrow\{0,\dotsc,m-1\}$
\end_inset

 is called 
\emph on

\begin_inset Formula $c$
\end_inset

-universal
\emph default
 for 
\begin_inset Formula $c\in\mathbb{R}$
\end_inset

 iff 
\begin_inset Formula $\forall x,y\in U,\; x\neq y:\;$
\end_inset

 
\begin_inset Formula $\left|\left\{ i\in I\mid h_{i}(x)=h_{i}(y)\right\} \right|\le c\frac{|I|}{m}$
\end_inset

.
 Alternative formulation: 
\begin_inset Formula $\forall x\neq y:\;\Pr_{i}\left[h(x)=h(y)\right]\le\frac{c}{m}$
\end_inset

.
\end_layout

\begin_layout Itemize
A popular 
\begin_inset Formula $c$
\end_inset

-universal family is 
\begin_inset Formula $H\,=\,\left\{ h_{a,b}\mid a,b\in\{0,\dotsc,p-1\}\right\} $
\end_inset

 where 
\begin_inset Formula $p\ge|U|$
\end_inset

 is a prime, 
\begin_inset Formula $m$
\end_inset

 is the size of the table and 
\begin_inset Formula $h_{a,b}(x)=\left((ax+b)\bmod p\right)\bmod m$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Proof
Let 
\begin_inset Formula $x,y\in U$
\end_inset

, 
\begin_inset Formula $x\neq y$
\end_inset

 be fixed.
 We want to show that the number of pairs 
\begin_inset Formula $(a,b)$
\end_inset

 such that 
\begin_inset Formula $h_{a,b}(x)=h_{a,b}(y)$
\end_inset

 is at most 
\begin_inset Formula $\frac{cp^{2}}{m}$
\end_inset

 for some 
\begin_inset Formula $c$
\end_inset

.
 For any such pair we denote 
\begin_inset Formula $i:=h_{a,b}(x)=h_{a,b}(y)$
\end_inset

 and it must hold
\begin_inset Formula 
\begin{eqnarray*}
ax+b & \equiv & i+rm\pmod{p}\\
ay+b & \equiv & i+sm\pmod{p}
\end{eqnarray*}

\end_inset

for some 
\begin_inset Formula $r,s\in\left\{ 0,\dotsc,\left\lceil \frac{p}{m}\right\rceil -1\right\} $
\end_inset

.
 The same congruence in a matrix form:
\begin_inset Formula 
\[
\begin{pmatrix}x & 1\\
y & 1
\end{pmatrix}\cdot\begin{pmatrix}a\\
b
\end{pmatrix}\equiv\begin{pmatrix}i+rm\\
i+sm
\end{pmatrix}\pmod{p}.
\]

\end_inset

Since 
\begin_inset Formula $x\neq y$
\end_inset

, the first matrix is regular and we are solving a set of linear equations
 over a (Galois) field.
 From a theorem from linear algebra we get that for any combination of the
 
\begin_inset Formula $i,r,s$
\end_inset

 parameters there is exatly one satisfying pair 
\begin_inset Formula $(a,b)\in\{0,\dotsc,p-1\}^{2}\supseteq U^{2}$
\end_inset

.
 Therefore, the number of such pairs is bounded by the number of 
\begin_inset Formula $i,r,s$
\end_inset

 combinations, which is 
\begin_inset Formula $m\left\lceil \frac{p}{m}\right\rceil ^{2}=(1+\epsilon)\frac{p^{2}}{m}$
\end_inset

 for some 
\begin_inset Formula $\epsilon>0$
\end_inset

 (created by rounding; normally 
\begin_inset Formula $p\gg m$
\end_inset

, so 
\begin_inset Formula $\epsilon\ll1$
\end_inset

).
\end_layout

\end_deeper
\begin_layout Subsection
Properties of 
\begin_inset Formula $c$
\end_inset

-universal systems
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $i\in I$
\end_inset

 and 
\begin_inset Formula $x,y\in U$
\end_inset

 we define 
\begin_inset Formula $\delta_{i}(x,y):=\begin{cases}
1 & \mbox{if }x\neq y\mbox{ and }h_{i}(x)=h_{i}(y)\\
0 & \mbox{otherwise}
\end{cases}$
\end_inset

.
 Moreover, for 
\begin_inset Formula $S\subseteq U$
\end_inset

 we define 
\begin_inset Formula $\delta_{i}(x,S):=\sum_{z\in S}\delta_{i}(x,z)$
\end_inset

.
 This is the number of elements in 
\begin_inset Formula $S$
\end_inset

 colliding with 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Itemize
The expected number of elements in 
\begin_inset Formula $S$
\end_inset

 colliding with 
\begin_inset Formula $x$
\end_inset

 equals 
\begin_inset Formula 
\begin{eqnarray*}
\frac{1}{|I|}\sum_{i\in I}\delta_{i}(x,S) & = & \frac{1}{|I|}\sum_{i\in I}\sum_{z\in S}\delta_{i}(x,z)=\frac{1}{|I|}\sum_{z\in S}\sum_{i\in I}\delta_{i}(x,z)\le\\
 &  & \mbox{now we use the definition of \ensuremath{c}-universality}\\
 & \le & \frac{1}{|I|}\sum_{z\in S\setminus\{x\}}\frac{c|I|}{m}=\frac{c\left|S\setminus\{x\}\right|}{m}\le\alpha c.
\end{eqnarray*}

\end_inset

Note that 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $S$
\end_inset

 were arbitrary.
 Consequently, we have the expected length of a chain bounded by 
\begin_inset Formula $\alpha c$
\end_inset

, so when maintaining a constant load factor, the expected complexity of
 operations is 
\begin_inset Formula $\OO(1)$
\end_inset

 for 
\emph on
any
\emph default
 input.
\end_layout

\begin_layout Itemize
There is a lower bound on the size of a 
\begin_inset Formula $c$
\end_inset

-universal family of functions: 
\begin_inset Formula $|I|\ge\frac{m}{c}\left(\left\lceil \log_{m}N\right\rceil -1\right)$
\end_inset

 where 
\begin_inset Formula $N:=|U|$
\end_inset

.
 As a consequence, the number of random bits for choosing a function is
 at least 
\begin_inset Formula $\log|I|\gtrapprox\log m-\log c+\log\log N-\log\log m$
\end_inset

.
\end_layout

\begin_layout Itemize
There exists a 
\begin_inset Formula $c$
\end_inset

-universal system that asymptotically achieves the lower bound on the number
 of needed random bits.
\end_layout

\begin_layout Itemize
For an arbitrary 
\begin_inset Formula $c$
\end_inset

-universal system it holds 
\begin_inset Formula $c\ge1-\frac{m}{N}\doteq1$
\end_inset

 (usually 
\begin_inset Formula $m\ll N$
\end_inset

).
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Proof? Slidy5 konec?
\end_layout

\end_inset


\end_layout

\begin_layout Section
Perfect hashing
\end_layout

\begin_layout Standard
In perfect hashing we try to find for a set 
\begin_inset Formula $S\subseteq U$
\end_inset

 a function 
\begin_inset Formula $h$
\end_inset

 that satisfies the following requirements:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $h$
\end_inset

 has no collisions: 
\begin_inset Formula $\nexists x,y\in S:\, x\neq y,\, h(x)=h(y)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $m$
\end_inset

 is sufficiently small.
 We will need 
\begin_inset Formula $m\in\OO(n)$
\end_inset

 to fit into linear space.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $h$
\end_inset

 is easily computable, ideally we can find 
\begin_inset Formula $h(x)$
\end_inset

 in small-constant time.
\end_layout

\begin_layout Enumerate
The description of 
\begin_inset Formula $h$
\end_inset

 doesn't take much space (if 
\begin_inset Formula $h$
\end_inset

 was defined by a table of all values, it would not help us, reducing hashing
 to tables again).
\end_layout

\begin_layout Subsection
Perfect families
\end_layout

\begin_layout Itemize
A family 
\begin_inset Formula $H$
\end_inset

 of hash functions is called 
\emph on

\begin_inset Formula $(N,m,n)$
\end_inset

-perfect
\emph default
 iff for every 
\begin_inset Formula $S\subseteq U$
\end_inset

 of size 
\begin_inset Formula $n$
\end_inset

 there 
\emph on
exists
\emph default
 
\begin_inset Formula $h\in H$
\end_inset

 such that it uses a table of size 
\begin_inset Formula $m$
\end_inset

 and it is perfect for 
\begin_inset Formula $S$
\end_inset

 (no collisions on 
\begin_inset Formula $S$
\end_inset

).
\end_layout

\begin_layout Itemize
There are lower bounds on the size of a 
\begin_inset Formula $(N,m,n)$
\end_inset

-perfect system.
 
\begin_inset Formula 
\[
|H|\ge\max\left\{ \frac{\binom{N}{n}}{\binom{m}{k}\left(\frac{N}{m}\right)^{n}},\,\frac{\log N}{\log m}\right\} 
\]

\end_inset


\end_layout

\begin_layout Itemize
It is possible to prove the existence of a 
\begin_inset Formula $(N,m,n)$
\end_inset

-perfect family of functions by examining all possible functions, but the
 proof doesn't guarantee the requirements (3) and (4) and it only shows
 the existence, not a way of finding the function reasonably quickly.
\end_layout

\begin_layout Itemize
Typical usage: show that the number of suitable functions is always at least
 a fixed fraction of 
\begin_inset Formula $H$
\end_inset

.
 By trying randomly we then find one such in expected constant number of
 trials (moreover, the probability of reaching attempt 
\begin_inset Formula $k$
\end_inset

 decreases exponentially in 
\begin_inset Formula $k$
\end_inset

, e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

by applying Chernoff bounds).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Construction of a perfect function
\end_layout

\begin_layout Standard
We show an algorithm that constructs a two-level static hash table such
 that it satisfies all the mentioned requirements via any 
\begin_inset Formula $c$
\end_inset

-universal family 
\begin_inset Formula $H$
\end_inset

 of hash functions.
\end_layout

\begin_layout Itemize
The first level will be a hash table of size 
\begin_inset Formula $m:=2cn$
\end_inset

 with hash function 
\begin_inset Formula $h$
\end_inset

, dividing the 
\begin_inset Formula $n$
\end_inset

 elements into chains of length 
\begin_inset Formula $n_{i}$
\end_inset

.
 We require that the number of ordered collision pairs is at most 
\begin_inset Formula $n$
\end_inset

, i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset


\begin_inset Formula $R:=\sum_{i}n_{i}\left(n_{i}-1\right)\le n$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Every chain will be stored in a 
\emph on
perfect
\emph default
 table of size 
\begin_inset Formula $m_{i}:=2cn_{i}^{2}$
\end_inset

 by a hash function 
\begin_inset Formula $h_{i}$
\end_inset

.
 We also need to store the parameters of these functions 
\begin_inset Formula $h$
\end_inset

 and 
\begin_inset Formula $h_{i}$
\end_inset

, so we can evaluate them when working with the table.
\end_layout

\begin_layout Itemize
The idea of a proof:
\end_layout

\begin_deeper
\begin_layout Itemize
We knew that for 
\emph on
any
\emph default
 table with 
\begin_inset Formula $c$
\end_inset

-universal family with parameters 
\begin_inset Formula $n,m$
\end_inset

, the expected number of collisions with a fixed 
\begin_inset Formula $x\in U$
\end_inset

 is at most 
\begin_inset Formula $\alpha c=\frac{n}{m}c$
\end_inset

, so the expected number of ordered collision pairs at most 
\begin_inset Formula $\sum_{x}\frac{n}{m}c=\frac{n^{2}}{m}c$
\end_inset

.
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $h$
\end_inset

 we chose 
\begin_inset Formula $m=2cn$
\end_inset

, so 
\begin_inset Formula $\Exp[h]R\le\frac{n^{2}}{m}c=\frac{n^{2}}{2cn}c=\frac{n}{2}$
\end_inset

, so by Markov inequality we get that the probability of finding a suitable
 function in 
\begin_inset Formula $H$
\end_inset

 (with 
\begin_inset Formula $R\le n)$
\end_inset

 is at least 
\begin_inset Formula $\frac{1}{2}$
\end_inset

.
\end_layout

\begin_layout Itemize
For 
\begin_inset Formula $h_{i}$
\end_inset

 we chose 
\begin_inset Formula $m_{i}=2cn_{i}^{2}$
\end_inset

, so 
\begin_inset Formula $\Exp[h]{R_{i}}\le\frac{n_{i}^{2}}{m_{i}}c=\frac{n_{i}^{2}}{2cn_{i}^{2}}c=\frac{1}{2}$
\end_inset

 and by Markov inequality we get that the probability of finding a perfect
 function 
\begin_inset Formula $h_{i}\in H$
\end_inset

 is at least 
\begin_inset Formula $\frac{1}{2}$
\end_inset

 (since 
\begin_inset Formula $R_{i}\in\mathbb{N}$
\end_inset

, 
\begin_inset Formula $R_{i}<1$
\end_inset

 implies 
\begin_inset Formula $R_{i}=0$
\end_inset

).
\end_layout

\begin_layout Itemize
The tables obviously need space 
\begin_inset Formula 
\[
\OO\left(m+\sum_{i}m_{i}\right)=\OO\left(n+\sum_{i}n_{i}^{2}\right)=\OO\left(n+R+n\right)=\OO(n)
\]

\end_inset

where the middle equality is due to: 
\begin_inset Formula 
\[
R=\sum_{i}n_{i}(n_{i}-1)=\sum_{i}n_{i}^{2}-\sum_{i}n_{i}=\sum_{i}n_{i}^{2}-n.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Note: this static construction can be modified to a dynamically maintained
 perfect hash table (with bigger constant factors).
 That gives us 
\begin_inset Formula $\OO(1)$
\end_inset

 search in the wost case and 
\begin_inset Formula $\OO(1)$
\end_inset

 expected amortized updates in 
\begin_inset Formula $\OO(n)$
\end_inset

 space (worst-case update time is unbounded again).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Exendible hashing
\end_layout

\begin_layout Standard
Hashing in external memories has some specifics.
 We illustrate them on a straightforward method by 
\emph on
Fagin
\emph default
.
\end_layout

\begin_layout Subsection
The external memory model
\end_layout

\begin_layout Itemize
We have external memory which we call 
\emph on
disk
\emph default
 and (internal) 
\emph on
memory
\emph default
.
 
\end_layout

\begin_layout Itemize
Disk is divided into blocks and it can't be accessed directly.
 We can only read a block from disc to memory or write a block to disk.
 When storing keys, we denote 
\begin_inset Formula $b$
\end_inset

 the number of keys that fit into one block and suppose 
\begin_inset Formula $b>1$
\end_inset

.
\end_layout

\begin_layout Itemize
Usually, we can only keep 
\begin_inset Formula $\OO\left(1\right)$
\end_inset

 blocks in memory and 
\begin_inset Formula $\OO\left(1\right)$
\end_inset

 additional data.
\end_layout

\begin_layout Itemize
The access to disk is considered so slow compared to memory that we only
 count the number of disk operations for the time complexity.
\end_layout

\begin_layout Subsection
The hashing method
\end_layout

\begin_layout Itemize
We use a hash function 
\begin_inset Formula $h$
\end_inset

 that hashes every key into a word of zeros and ones.
\end_layout

\begin_layout Itemize
The structure consists of a 
\emph on
directory
\emph default
 that holds pointers to disk blocks containing the actual keys.
 The directory is an array of length 
\begin_inset Formula $2^{l}$
\end_inset

 and on index 
\begin_inset Formula $i$
\end_inset

 it contains the identifier of the block that stores all the keys whose
 first 
\begin_inset Formula $l$
\end_inset

 bits of hash are equal to 
\begin_inset Formula $i$
\end_inset

 (and there may be some other keys).
\end_layout

\begin_layout Itemize
Every block 
\begin_inset Formula $P$
\end_inset

 has a number 
\begin_inset Formula $l_{P}\le l$
\end_inset

 which is the number of starting bits that are guaranteed to be common for
 all the keys stored within 
\begin_inset Formula $P$
\end_inset

.
 This common prefix of length 
\begin_inset Formula $l_{P}$
\end_inset

 is called 
\emph on
critical word
\emph default
.
 The indices in the directory that point to the block 
\begin_inset Formula $P$
\end_inset

 are exactly those that start with the critical word of 
\begin_inset Formula $P$
\end_inset

.
 As a consequence we have 
\begin_inset Formula $2^{l-l_{P}}$
\end_inset

 pointers to 
\begin_inset Formula $P$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
The operation algorithms
\end_layout

\begin_layout Itemize
When analyzing the operations we assume that the directory is held in the
 main memory.
 Otherwise we would need some more block reading and writing, especially
 when resizing the directory.
\end_layout

\begin_layout Itemize
If we wanted to store some additional data associated with the keys, the
 operations would also need some additional block reading or writing proportiona
l to the size of stored data.
\end_layout

\begin_layout Paragraph
M
\noun on
ember
\noun default

\begin_inset Formula $(x)$
\end_inset


\end_layout

\begin_layout Standard
We first compute the first 
\begin_inset Formula $l$
\end_inset

 bits of the hash value 
\begin_inset Formula $h(x)$
\end_inset

 and on this index of the directory we find the indentifier of a block (pointer
 to a block).
 If the pointer 
\family sans
is empty,
\family default
 we exit immediately, otherwise we read the block into memory and search
 its contents for 
\begin_inset Formula $x$
\end_inset

.
 Thus we at most need to read one block.
\end_layout

\begin_layout Paragraph

\noun on
Insert
\noun default

\begin_inset Formula $(x)$
\end_inset


\end_layout

\begin_layout Standard
We first find the block 
\begin_inset Formula $P$
\end_inset

 in which 
\begin_inset Formula $x$
\end_inset

 belongs (reading 
\begin_inset Formula $P$
\end_inset

 in the process).
 We insert 
\begin_inset Formula $x$
\end_inset

 into 
\begin_inset Formula $P$
\end_inset

 (unless it was there already), but if 
\begin_inset Formula $P$
\end_inset

 was full, then:
\end_layout

\begin_layout Itemize

\emph on
We split 
\begin_inset Formula $P$
\end_inset

 in two.

\emph default
 The hashes of the keys in 
\begin_inset Formula $P$
\end_inset

 share the first 
\begin_inset Formula $l_{P}$
\end_inset

 bits.
 To free one more position in 
\begin_inset Formula $P$
\end_inset

 we have to find 
\begin_inset Formula $l_{P}'$
\end_inset

: a higher value for 
\begin_inset Formula $l_{P}$
\end_inset

 such that it splits away at least one element.
 The value 
\begin_inset Formula $l_{P}+1$
\end_inset

 usually suffices, but it may have to be higher.
 Every increment of 
\begin_inset Formula $l_{P}$
\end_inset

 splits in half the part of the universe set covered by the block.
 If both of the halves contain at least one key, we fit in.
 Otherwise we have to split again.
  This process divides the keys from 
\begin_inset Formula $P$
\end_inset

 into two blocks (and possibly some 
\begin_inset Quotes eld
\end_inset

empty blocks
\begin_inset Quotes erd
\end_inset

 which we don't allocate).
 We allocate that new block on disc and write the new contents into the
 two blocks (we reuse the old block of 
\begin_inset Formula $P$
\end_inset

).
\end_layout

\begin_layout Itemize

\emph on
We make sure that the directory is large enough 
\begin_inset Formula $\left(l\ge l_{P}'\right)$
\end_inset

.

\emph default
 The resize just creates the new directory array of length 
\begin_inset Formula $2^{l_{P}'}$
\end_inset

 and every block pointer from the old array is replaced by its copies on
 consecutive 
\begin_inset Formula $2^{l_{P}'-l}$
\end_inset

 indices.
 The usual case is increasing 
\begin_inset Formula $l$
\end_inset

 by 
\begin_inset Formula $1$
\end_inset

 so every pointer is doubled.
 Since usually we suppose that the directory fits into the main memory,
 the resize needs no disc operations.
\end_layout

\begin_layout Itemize

\emph on
We update the directory
\emph default
 (regardless of its resizing).
 We redirect indices that pointed to 
\begin_inset Formula $P$
\end_inset

 to point to the correct of the two blocks (or empty pointers).
 There was at most 
\begin_inset Formula $2^{l-l_{P}}$
\end_inset

 pointers to 
\begin_inset Formula $P$
\end_inset

 and we find them on the indices corresponding to 
\begin_inset Formula $P$
\end_inset

's 
\emph on
critical word
\emph default
.
\end_layout

\begin_layout Standard
To sum up, the worst case for needed disc block operations is when 
\begin_inset Formula $P$
\end_inset

 has to be split and it consists of one reading, one writing and one allocation
 with writing.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Paragraph

\noun on
Delete
\noun default

\begin_inset Formula $(x)$
\end_inset


\end_layout

\begin_layout Standard
We find the block 
\begin_inset Formula $P$
\end_inset

 in which 
\begin_inset Formula $x$
\end_inset

 belongs (reading 
\begin_inset Formula $P$
\end_inset

 in the process).
 If 
\begin_inset Formula $x$
\end_inset

 isn't in 
\begin_inset Formula $P$
\end_inset

, we terminate the operation.
 Otherwise we remove and then take care of merging possibilites for 
\begin_inset Formula $P$
\end_inset

:
\end_layout

\begin_layout Itemize
We take the 
\emph on
critical word
\emph default
 of 
\begin_inset Formula $P$
\end_inset

 (the first common 
\begin_inset Formula $l_{P}$
\end_inset

 bits), flip the least significant bit and look at the resulting index in
 our directory.
 If it points to such a block 
\begin_inset Formula $Q$
\end_inset

 that 
\begin_inset Formula $l_{P}=l_{Q}$
\end_inset

 and their keys can fit into a single block (we read 
\begin_inset Formula $Q$
\end_inset

 in the process), we merge 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

.
 That consists of deallocating 
\begin_inset Formula $Q$
\end_inset

, writing the new contents into 
\begin_inset Formula $P$
\end_inset

 and replacing pointers to 
\begin_inset Formula $Q$
\end_inset

 by pointers to 
\begin_inset Formula $P$
\end_inset

 (
\begin_inset Formula $l_{P}$
\end_inset

 is decreased by one).
 It also may be possible to merge the resulting block with adjacent 
\begin_inset Quotes eld
\end_inset

empty blocks
\begin_inset Quotes erd
\end_inset

 represented in the directory by 
\family sans
nil
\family default
 pointers (the inverse case to multiple splitting during
\family sans
 
\noun on
insert
\family default
\noun default
).
\end_layout

\begin_layout Itemize
As we decreased 
\begin_inset Formula $l_{P}$
\end_inset

, we can reduce the size of the dictionary if now 
\begin_inset Formula $l>\max\left\{ l_{R}\mid\mbox{block }R\right\} $
\end_inset

.
 To be able to find this out, we can store the 
\begin_inset Formula $l_{R}$
\end_inset

 values within the directory and always scan them (if it can be kept in
 the main memory).
 A more efficient way is to maintain the total counts of used 
\begin_inset Formula $l_{R}$
\end_inset

 values, which is just an array of length 
\begin_inset Formula $l$
\end_inset

 containing small integers.
\end_layout

\begin_layout Itemize
Resizing the dictionary is again straightforward.
 Let 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $l'=\max\left\{ l_{R}\mid\mbox{block }R\right\} $
\end_inset

, then we are guaranteed that the consecutive segments of length 
\begin_inset Formula $2^{l-l'}$
\end_inset

 in the dictionary contain the same block pointers, so we can replace the
 segments by single items.
\end_layout

\begin_layout Standard
To sum up, the worst case for needed disc block operations is when 
\begin_inset Formula $P$
\end_inset

 is merged and it consists of two readings, one writing and one deallocation.
\end_layout

\begin_layout Subsection
Expected properties
\end_layout

\begin_layout Itemize
For analysis we suppose the usual uniformity assumptions for simple hashing.
\end_layout

\begin_layout Itemize
The expected number of used blocks equals 
\begin_inset Formula $\frac{n}{b\ln2}$
\end_inset

.
 That is, the blocks are expected to be around 69% full.
\end_layout

\begin_layout Itemize
The expected size of the directory equals 
\begin_inset Formula $\frac{b\mathbb{e}}{\ln2}n^{1+1/b}$
\end_inset

.
 This can be a problem for low 
\begin_inset Formula $b$
\end_inset

 values where the size of the directory grows almost quadratically.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Omitted from the lecture
\end_layout

\begin_layout Standard
Some topics are no longer taught in the course, but they may be of interest.
\end_layout

\begin_layout Section
AVL trees 
\begin_inset CommandInset label
LatexCommand label
name "sec:AVL-trees"

\end_inset


\end_layout

\begin_layout Standard
AVL trees are binary search trees (see pg.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand pageref
reference "sec:BST"

\end_inset

) that maintain a simple balancing condition: in every vertex the heights
 of its child subtrees differ by at most one.
 We need to add a field 
\begin_inset Formula $\b(v):=\h\left(\r(v)\right)-\h\left(\l(v)\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Now we show how this condition bounds the height of the tree.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $f(h)$
\end_inset

 be the minimal number of elements representable by an AVL of height 
\begin_inset Formula $h$
\end_inset

.
 Then 
\begin_inset Formula $f(h)=F_{h+2}-1$
\end_inset

 where 
\begin_inset Formula $F_{i}$
\end_inset

 is the 
\begin_inset Formula $i$
\end_inset

-th Fibonacci number (
\begin_inset Formula $F_{0}=0$
\end_inset

, 
\begin_inset Formula $F_{1}=1$
\end_inset

, 
\begin_inset Formula $F_{i+1}=F_{i}+F_{i-1}$
\end_inset

).
\end_layout

\begin_deeper
\begin_layout Proof
By induction on 
\begin_inset Formula $h$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Case
\begin_inset Formula $h=0$
\end_inset

.
 A single leaf represents the empty set, 
\begin_inset Formula $f(0)=0=F_{2}-1$
\end_inset

.
\end_layout

\begin_layout Case
\begin_inset Formula $h=1.$
\end_inset

 Root with two leaves as children represents a set of size one, 
\begin_inset Formula $f(1)=1=F_{3}-1$
\end_inset

.
\end_layout

\begin_layout Case
\begin_inset Formula $h\ge2$
\end_inset

.
 Root with two subtrees of lower height.
 The worst case is when we have children of height 
\begin_inset Formula $h-1$
\end_inset

 and 
\begin_inset Formula $h-2$
\end_inset

, and both represent the minimum number of elements possible, thus 
\begin_inset Formula 
\[
f(h)=1+f(h-1)+f(h-2)=1+F_{h+1}-1+F_{h}-1=F_{h+2}-1.
\]

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Fact*
\begin_inset Argument 1
status open

\begin_layout Plain Layout
see 
\begin_inset CommandInset ref
LatexCommand vref
reference "fact:Fibonacci-exponential"

\end_inset


\end_layout

\end_inset

 
\begin_inset Formula $F_{i}=\frac{1}{\sqrt{5}}\left[\varphi^{i}-\left(1-\varphi\right)^{i}\right]\ge\frac{1}{\sqrt{5}}\varphi^{i-1}$
\end_inset

 where 
\begin_inset Formula $\varphi=\frac{1+\sqrt{5}}{2}$
\end_inset

.
\end_layout

\begin_layout Corollary
The height of AVL tree containing 
\begin_inset Formula $n$
\end_inset

 elements is at most 
\begin_inset Formula $\log_{\varphi}n+\OO\left(1\right)$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Proof
We know 
\begin_inset Formula $n\ge F_{h+2}-1\ge\frac{1}{\sqrt{5}}\varphi^{h+1}-1$
\end_inset

 so 
\begin_inset Formula $\log_{\varphi}\left(\sqrt{5}(n+1)\right)-1\ge h$
\end_inset

, thus 
\begin_inset Formula 
\[
h\,\le\,\log_{\varphi}\left(n+1\right)+\log_{\varphi}\frac{\sqrt{5}}{\varphi}\,\doteq\,1.44\log\left(n+1\right)+0.67.
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Subsubsection
Operations
\end_layout

\begin_layout Standard
Simple operations like 
\noun on
member
\noun default
, 
\noun on
min
\noun default
 and 
\noun on
max
\noun default
 are the same as in general BSTs.
 In 
\noun on
insert
\noun default
 and 
\noun on
delete
\noun default
 we just update the values of 
\begin_inset Formula $\b$
\end_inset

 and then perform some rebalancing at the end of the operation to restore
 that 
\begin_inset Formula $\left|\b\left(u\right)\right|\le1$
\end_inset

, as follows.
\end_layout

\begin_layout Standard
The invariant can only break in the way that 
\begin_inset Formula $\left|\b\left(u\right)\right|=2$
\end_inset

 in some vertices on the affected path.
 We shall start with the lowest broken vertex 
\begin_inset Formula $v$
\end_inset

.
 Here we only discuss the case of 
\begin_inset Formula $\b\left(u\right)=2$
\end_inset

, as the other one is symmetrical.
 Let 
\begin_inset Formula $v:=\r(u)$
\end_inset

, there are several cases (there's a figure for each):
\end_layout

\begin_layout Case
\begin_inset Formula $\b\left(v\right)=1$
\end_inset

.
 We rotate the 
\begin_inset Formula $\left(u\rightarrow v\right)$
\end_inset

 edge.
 That restores 
\begin_inset Formula $\b(u)=\b(v)=0$
\end_inset

 and decreases the height in the root of rotation by one.
\end_layout

\begin_layout Case
\begin_inset Formula $\b\left(v\right)=0$
\end_inset

.
 We also rotate the 
\begin_inset Formula $\left(u\rightarrow v\right)$
\end_inset

 edge, but this time we get 
\begin_inset Formula $\b(u)=1$
\end_inset

 and 
\begin_inset Formula $\b(v)=-1$
\end_inset

.
 The height in the root of rotation remains the same.
\end_layout

\begin_layout Case
\begin_inset Formula $\b\left(v\right)=-1$
\end_inset

.
 We double-rotate the 
\begin_inset Formula $w:=\l(u)$
\end_inset

 vertex, that is, we first rotate 
\begin_inset Formula $\left(v\rightarrow w\right)$
\end_inset

 and then 
\begin_inset Formula $\left(u\rightarrow w\right)$
\end_inset

.
 That gives 
\begin_inset Formula $\b(w)=0$
\end_inset

; for 
\begin_inset Formula $v$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 the new balance depends on the old balance of 
\begin_inset Formula $w$
\end_inset

, but it is OK in any case.
 The height in the root of double rotation is decreased by one.
\end_layout

\begin_layout Standard
After fixing the invariant locally we continue up the path fixing the 
\begin_inset Formula $\b$
\end_inset

 values.
 It can be shown that:
\end_layout

\begin_layout Itemize
After 
\noun on
insert
\noun default
 there can only be cases
\begin_inset space ~
\end_inset

1 or 3, so after hitting one of these cases, the height in the root of (double)
 rotation gets down back to the value before insertion and the operation
 can end at that point.
\end_layout

\begin_layout Itemize
After 
\noun on
delete
\noun default
 it may be needed to rotate the whole path.
\end_layout

\begin_layout Standard
The 
\noun on
rank
\noun default
 and 
\noun on
ord
\noun default
 operations can be added the same way as in general BSTs.
 It is obvious now that in any case we do at most some constant work on
 every level.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename avl-p1.dot
	lyxscale 50
	scale 50
	groupId BST

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
AVL: rotation for Case 1.
 As for all AVL figures, balance information is in parentheses, and heights
 are in brackets (parametrized by 
\begin_inset Formula $k$
\end_inset

).
 Note that nodes can have larger subtrees that are not shown.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename avl-p2.dot
	lyxscale 50
	scale 50
	groupId BST

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
AVL: rotation for Case 2.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename avl-p3.dot
	lyxscale 50
	scale 50
	groupId BST

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
AVL: double rotation for Case 3.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Corollary
The complexities of all operations on AVL trees are 
\begin_inset Formula $\Theta\left(\log n\right)$
\end_inset

.
\end_layout

\begin_layout Corollary
\begin_inset Note Note
status open

\begin_layout Plain Layout
space for images
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Sorting and searching arrays
\end_layout

\begin_layout Standard
Conventions: input and output in an array of length 
\begin_inset Formula $n$
\end_inset

, we want the ascending order.
\end_layout

\begin_layout Subsection
Comparison-based sorting
\end_layout

\begin_layout Standard
In comparison-based sorting we only allow pairwise comparisons of elements.
 We will see that the time for worst-case input is asymptotically logarithmic.
\end_layout

\begin_layout Paragraph
HeapSort
\end_layout

\begin_layout Standard
works via constructing a 
\begin_inset Formula $d$
\end_inset

-regular max-heap in the input array with 
\begin_inset Formula $d\in\Theta\left(1\right)$
\end_inset

.
 Then it repeatedly extracts the maximum and puts it at the end of the array
 into the place which is no longer used by the heap, until we sort it all.
 
\end_layout

\begin_layout Standard

\emph on
Properties
\emph default
: 
\begin_inset Formula $\Theta\left(n\log n\right)$
\end_inset

 time and comparisons, but high multiplicative constants for both.
 It's robust (almost always the same time) and in-place (only constant additiona
l memory is needed).
\end_layout

\begin_layout Paragraph
MergeSort
\end_layout

\begin_layout Standard
starts with a queue for sorted sequences that is initialized by the singleton
 elements (for example).
 Then repeatedly the first two sequences are merged and the result is put
 on the end of the queue, until we only have one sorted sequence.
\end_layout

\begin_layout Standard

\emph on
Merging
\emph default
 two sorted sequences: iteratively compare the first elements and extract
 a smaller one into the output.
 To achieve stability (never change order of elements that compare equal),
 we select from the first sequence whenever there is a tie.
 Obviously this takes 
\begin_inset Formula $n_{1}+n_{2}-1$
\end_inset

 comparisons and time.
\end_layout

\begin_layout Standard

\emph on
Running time
\emph default
: every time the queue is rotated, perhaps leaving one sequence into the
 next round, the number of sequences is halved (rounded up), so every element
 takes part in at most 
\begin_inset Formula $\left\lceil \log n\right\rceil $
\end_inset

 merges.
 Thus the total number of comparisons is at most 
\begin_inset Formula $n\left\lceil \log n\right\rceil $
\end_inset

, which is exactly the best possible in the worst case (up to rounding).
\end_layout

\begin_layout Standard

\emph on
Properties
\emph default
: faster than heapsort in practice, but not in-place
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
However, there exists a very complicated version that is in-place.
\end_layout

\end_inset

; easy to paralelize, stable, low number of comparisons, good memory locality.
 It is very useful on memories with substantially faster sequential access,
 such as disks or tapes, usually modified to do multi-way merges.
 The start can be modified to work faster almost-sorted sequences, but then
 we need a more complicated way of choosing the pairs to merge (Huffman
 tree).
\end_layout

\begin_layout Paragraph
A-sort:
\end_layout

\begin_layout Standard
described 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sub:A-sort"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
QuickSort
\end_layout

\begin_layout Standard
Quicksort starts by choosing any element as the pivot (somehow) and exchanging
 it with the first element.
 Then we partition the rest of the array according to comparison with the
 pivot as follows.
 We have two pointers
\begin_inset space ~
\end_inset

-- one starts on the leftmost position and finds the first element larger
 than the pivot, the latter starts on the right and finds an element smaller
 than the pivot.
 Then those elements are exchanged and all continues until the pointers
 cross.
 To finish the partition, we exchange the pivot with the last element of
 the created left segment.
 Finally we use recursion on both segments.
\end_layout

\begin_layout Standard

\emph on
Properties
\emph default
: fast and popular in practice (uses relatively sequential access), in-place,
 good memory locality, but sensitive to pivot choice or malicious inputs.
\end_layout

\begin_layout Standard

\emph on
Pivot choice:
\emph default
 if we are unlucky and e
\begin_inset space \thinspace{}
\end_inset

.g.
\begin_inset space ~
\end_inset

always choose the smallest element, then the running time is obviously 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

.
 Several common ways to deal with it:
\end_layout

\begin_layout Itemize
Use some fast heuristic choice, e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

the median of the first, middle and last element.
 This is still 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

 in the worst case, but such inputs are less natural (the original formulation
 degenerates even on almost-sorted sequences), and even the average case
 might get improved a little.
\end_layout

\begin_layout Itemize
Choose randomly.
 As proven below, this gives 
\begin_inset Formula $\Theta\left(n\log n\right)$
\end_inset

 expected time, regardless of the input.
 However, using so much randomness is usualy too expensive in practice.
\end_layout

\begin_layout Itemize
Choose a median or other good-enough element (at least a constant fraction
 from both ends in the order).
 This can be done in 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 time in the worst case, so we can guarantee 
\begin_inset Formula $\Theta\left(n\log n\right)$
\end_inset

 time.
 However, the constants get higher than for mergeSort or heapSort, so it
 isn't practical.
\end_layout

\begin_layout Itemize
IntroSort or similar solution: do some simple choice (e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

a middle element), but switch to a worst-case method (typically heapSort)
 whenever the depth of recursion reaches some logarithmic threshold.
 Very popular in practice.
\end_layout

\begin_layout Standard

\emph on
Expected case:
\emph default
 denote the elements 
\begin_inset Formula $x_{1}<x_{2}<\dotsb<x_{n}$
\end_inset

, then observe that 
\begin_inset Formula $x_{i}$
\end_inset

 and 
\begin_inset Formula $x_{j}$
\end_inset

, 
\begin_inset Formula $i<j$
\end_inset

, are compared iff either is chosen as the pivot before they are split by
 choosing some pivot in between.
 If the pivot choice is uniform, then clearly 
\begin_inset Formula $\Pr\left[\mbox{\ensuremath{x_{i}}and \ensuremath{x_{j}}get compared}\right]=2/\left(j-i+1\right)$
\end_inset

.
 The expected number of comparisons: 
\begin_inset Formula 
\[
\sum_{1\le i<j\le n}\frac{2}{j-i+1}\overset{k:=j-i+1}{=}\sum_{i=1}^{n-1}\sum_{k=2}^{n-i+1}\frac{2}{k}<2n\sum_{k=2}^{n}\frac{1}{k}<2n\int_{1}^{n}\frac{1}{k}=2n\ln n\doteq2.88\cdot n\log n
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsubsection
Lower bounds via decision trees 
\begin_inset CommandInset label
LatexCommand label
name "sub:sorting-decision-trees"

\end_inset


\end_layout

\begin_layout Standard
Decision trees: for simplicity we suppose the algorithm is deterministic,
 and we imagine a tree describing comparisons on all possible inputs.
 Thus each vertex corresponds to a comparison, and the tree is binary.
 Each leaf corresponds to one result of execution (assuming we pruned unreachabl
e vertices), so the depth of the tree will correspond to the worst case
 number of comparisons.
\end_layout

\begin_layout Standard

\series bold
Sorting
\series default
 needs to differentiate among all permutations of the input sequence, which
 is 
\begin_inset Formula $n!$
\end_inset

 possibilities (for a sequence without repeats).
 That means the depth is bounded by 
\begin_inset Formula $\log n!\ge\log n^{n/2}=\frac{n}{2}\log n$
\end_inset

 (first inequality by pairing as 
\begin_inset Formula $k\cdot(n-k)\ge n$
\end_inset

; almost exact analysis: 
\begin_inset Formula $\log n!\doteq n\log\frac{n}{\mathrm{e}}$
\end_inset

).
\end_layout

\begin_layout Standard
Similarly for a simple search in a 
\series bold
dictionary
\series default
 of size 
\begin_inset Formula $n$
\end_inset

, we need to differentiate among 
\begin_inset Formula $n+1$
\end_inset

 possibilities, which gives us a lower bound of 
\begin_inset Formula $\log n$
\end_inset

 comparisons.
\end_layout

\begin_layout Subsection
Non-comparison sorting
\end_layout

\begin_layout Paragraph
CountingSort / BucketSort
\end_layout

\begin_layout Standard
works on integers in some range of length 
\begin_inset Formula $m$
\end_inset

.
 We allocate an array of 
\begin_inset Formula $m$
\end_inset

 counters initialized to zeros, and on the first pass we count the numbers
 of keys.
 If we don't care e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

about data associated with the keys, we could produce the output by one
 pass over the counters.
 Otherwise we accumulate the numbers from the left, so the new counter values
 will contain the sums of the old counter values to the left (excluding
 itself).
 Note that now the counter for each key marks the first position in the
 output array that should be occupied by some equal key.
 Now we pass over the input and put every element at the position denoted
 by its counter, while incrementing that counter.
 Obviously, the algorithm is correct and stable; it needs additional space
 is 
\begin_inset Formula $\Theta\left(m\right)$
\end_inset

 and total time is 
\begin_inset Formula $\Theta\left(n+m\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Note: the bucketSort implementation is often explained in a way that instead
 of counters we have buckets, i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset

linear linked lists containing the elements.
 However, the implementation above behaves the same asymptotically and it
 has much better multiplicative constants in practice.
\end_layout

\begin_layout Paragraph
RadixSort
\end_layout

\begin_layout Standard
expands the linear behaviour from linear to polynomial ranges.
 We imagine each key is split into digits of 
\begin_inset Formula $\log n+\Theta\left(1\right)$
\end_inset

 bits, which means each digit has range 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
 We start with the input sequence, and in phase 
\begin_inset Formula $i$
\end_inset

 we bucket-sort the output of the previous phase by the 
\begin_inset Formula $i$
\end_inset

-th least significant digit.
\end_layout

\begin_layout Standard
Note that by induction, after 
\begin_inset Formula $i$
\end_inset

 phases we get a sequence that is sorted lexicographically according to
 the last 
\begin_inset Formula $i$
\end_inset

 digits (using stability of bucketSort).
 Each phase takes 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 time and memory and the number of phases is 
\begin_inset Formula $\Theta\left(\log m/\log n\right)$
\end_inset

.
 If the total range is polynomial, i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset


\begin_inset Formula $m=n^{\Theta\left(1\right)}$
\end_inset

, we get total time 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
 RadixSort is very fast even in practice, if the keys are relatively short.
\end_layout

\begin_layout Paragraph
WordSort
\end_layout

\begin_layout Standard
expands the linear behaviour to the case when lengths of keys differ much.
 We denote the total number of digits in the input as 
\begin_inset Formula $N$
\end_inset

 and the alphabet for digits as 
\begin_inset Formula $\Sigma$
\end_inset

.
 First we construct a list of digits occuring on every position in keys:
 we radix-sort all pairs (position,digit) from the input, and we remove
 repeated occurences.
 That will need time and space 
\begin_inset Formula $\Theta\left(N+|\Sigma|\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Then we bucket-sort all keys by their length (number of digits), which needs
 
\begin_inset Formula $\Theta\left(N\right)$
\end_inset

 time and space.
 We continue similarly to radixSort, sorting by digits of keys.
 In early phases we don't include keys that aren't long enough (we can imagine
 the keys aligned on the 
\emph on
most
\emph default
 significant bit).
 Also in each phase we use the sorted list of occuring digits, so we skip
 the other digits, and the time needed in a phase is only linear in the
 number of keys included in that phase (without dependency on 
\begin_inset Formula $|\Sigma|$
\end_inset

).
 As each key takes part in as many phases as its number of digits, the total
 time and space is 
\begin_inset Formula $\Theta\left(N+|\Sigma|\right)$
\end_inset

, including preprocessing.
\begin_inset Note Note
status open

\begin_layout Plain Layout

\emph on
(ToDo: re-verify)
\emph default
 Note: this algorithm needs no arrays and can be implemented on a Pointer
 Machine.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
HybridSort
\end_layout

\begin_layout Standard
shows a good example of using distribution of input data.
 We suppose the keys are distributed uniformly over some interval.
 We split that interval uniformly into 
\begin_inset Formula $m:=\alpha n$
\end_inset

 buckets for an arbitrary 
\begin_inset Formula $\alpha\in\Theta\left(1\right)$
\end_inset

, and we distribute the input into an array with one linked list per bucket.
 Then we sort each bucket and send its elements in order to the output.
\end_layout

\begin_layout Standard
Worst-case analysis of 
\begin_inset Formula $\Theta\left(n\log n\right)$
\end_inset

: if bucket 
\begin_inset Formula $i$
\end_inset

 gets 
\begin_inset Formula $B_{i}$
\end_inset

 elements, then the time of the second phase is asymptotically bounded by
 
\begin_inset Formula $\sum_{i}B_{i}\log B_{i}\le\sum_{i}B_{i}\log n=n\log n$
\end_inset

.
\end_layout

\begin_layout Standard
Expected-time analysis of 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
 
\begin_inset Formula $B_{i}$
\end_inset

 are binomially distributed random variables: 
\begin_inset Formula $\Pr\left[B_{i}=k\right]=\binom{n}{k}\left(\frac{1}{m}\right)^{k}\left(1-\frac{1}{m}\right)^{n-k}$
\end_inset

.
 If we leave out buckets of size less than two, then the expected time for
 bucket 
\begin_inset Formula $i$
\end_inset

 is asymptotically
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\begin{gathered}\sum_{k=2}^{n}\Pr\left[B_{i}=k\right]k\log k\le\sum_{k=2}^{n}\Pr\left[B_{i}=k\right]\cdot k(k-1)=\\
\sum_{k=2}^{n}\frac{k\left(k-1\right)\cdot n!}{k!(n-k)!}\left(\frac{1}{m}\right)^{k}\left(1-\frac{1}{m}\right)^{n-k}=\sum_{k=2}^{n}\frac{n\left(n-1\right)(n-2)!}{(k-2)!(n-k)!}\left(\frac{1}{m}\right)^{k}\left(1-\frac{1}{m}\right)^{n-k}\\
\overset{k':=k-2}{=}\frac{n(n-1)}{m^{2}}\sum_{k'=0}^{n-2}\binom{n-2}{k'}\left(\frac{1}{m}\right)^{k'}\left(1-\frac{1}{m}\right)^{n-2-k'}<\frac{n^{2}}{m^{2}}\left(\frac{1}{m}+1-\frac{1}{m}\right)^{n-2}.
\end{gathered}
\]

\end_inset

 Thus the total expected time is 
\begin_inset Formula $\OO\left(n+m+m\cdot n^{2}/m^{2}\right)=\OO\left(n+\alpha n+\frac{n^{2}}{\alpha n}\right)=\OO\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Note that this scheme can be directly generalized to a dynamic data structure
 that works with expected constant time per operation (for uniformly distributed
 data).
 For the bucket structures we would better choose e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

binary search trees, so most operations get logarithmic in the worst case
 as well.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Selecting the 
\begin_inset Formula $k$
\end_inset

-th element
\end_layout

\begin_layout Standard
Sometimes we don't need sorting but just finding the 
\begin_inset Formula $k$
\end_inset

-th smallest element (e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

median).
 That can be done in linear time even in comparison-based setting.
 For simplicity we assume that no elements are equal, so the choice is unambiguo
us.
\end_layout

\begin_layout Paragraph
QuickSelect
\end_layout

\begin_layout Standard
is a trivial modification of quickSort
\begin_inset space ~
\end_inset

-- instead of recursing into both subsequences, it is sufficient to explore
 just one of them.
 More precisely: after splitting according to a pivot with 
\begin_inset Formula $l$
\end_inset

 elemnts to the left, we know that the pivot will have the current position
 
\begin_inset Formula $l+1$
\end_inset

 in the sorted order.
 Thus if 
\begin_inset Formula $k=l+1$
\end_inset

, we have the answer; if 
\begin_inset Formula $k<l+1$
\end_inset

, we search for 
\begin_inset Formula $k$
\end_inset

-th on the left subsequence.
 Finally, if 
\begin_inset Formula $k>l+1$
\end_inset

, we search for 
\begin_inset Formula $\left(k-l-1\right)$
\end_inset

-th in the right subsequence.
\end_layout

\begin_layout Standard
Analyses: in the worst case we split away just one element per recursion
 step, so it can take 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

 time.
 However, with random input/pivot, we are expected to cut away at least
 
\begin_inset Formula $1/4$
\end_inset

 of current elements.
\begin_inset Foot
status open

\begin_layout Plain Layout
The following analysis can also be solved by directly applying Master Theorem
 instead.
 An extended version also simply solves the median-of-medians analysis.
\end_layout

\end_inset

 Now we use induction by 
\begin_inset Formula $n$
\end_inset

: if we have 
\begin_inset Formula $T\left(n'\right)\le cn'+d$
\end_inset

 for some constants 
\begin_inset Formula $c,d$
\end_inset

 and all 
\begin_inset Formula $n'<n$
\end_inset

; then if we recurse, for some constants 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $t$
\end_inset

, we have expected time 
\begin_inset Formula $T(n)\le T\left(\frac{3}{4}n\right)+sn+t\le n\left(\frac{3}{4}c+s\right)+\frac{3}{4}d+t$
\end_inset

, so it suffices to choose 
\begin_inset Formula $c\ge4s$
\end_inset

 and 
\begin_inset Formula $d\ge4t$
\end_inset

 for the base case of some small constant 
\begin_inset Formula $n$
\end_inset

, and we get 
\begin_inset Formula $T(n)=\Theta(n)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Median of medians
\end_layout

\begin_layout Standard
can do the selection in linear worst-case time by choosing a good-enough
 pivot in linear time (splitting takes linear time anyway).
 First it conceptually divides the input into 5-tuples and finds a median
 in each, e.
\begin_inset space \thinspace{}
\end_inset

g.
\begin_inset space ~
\end_inset

by sorting.
\begin_inset Foot
status open

\begin_layout Plain Layout
The last group can be smaller.
 We can also use 7-tuples instead.
\end_layout

\end_inset

 Then it finds a median 
\begin_inset Formula $p$
\end_inset

 of these medians by recursively calling the selection algorithm.
 By transitivity over the medians smaller than 
\begin_inset Formula $p$
\end_inset

 (or equal), we have at least 
\begin_inset Formula $\frac{3}{5}\frac{n}{2}=0.3\, n$
\end_inset

 elements with value at most 
\begin_inset Formula $p$
\end_inset

 (up to small additive constant due to rounding).
 The situation is symmetric, so by choosing 
\begin_inset Formula $p$
\end_inset

 as the pivot we reduce the size of the task to 
\begin_inset Formula $0.7\, n$
\end_inset

 in the worst case.
\end_layout

\begin_layout Standard
Analysis by induction on 
\begin_inset Formula $n$
\end_inset

, denoting the time by 
\begin_inset Formula $T(n)$
\end_inset

: if we have 
\begin_inset Formula $T\left(n'\right)\le cn'+d$
\end_inset

 for some constants 
\begin_inset Formula $c,d$
\end_inset

 and all 
\begin_inset Formula $n'<n$
\end_inset

, then by the recursion step, for some constants 
\begin_inset Formula $s\mbox{ and }t$
\end_inset

, we have 
\begin_inset Formula $T(n)\le sn+T\left(n/5\right)+T\left(0.7\, n\right)+t=sn+0.9\, cn+0.9\, d+t$
\end_inset

.
 That is, if we choose 
\begin_inset Formula $c\ge10s$
\end_inset

 and 
\begin_inset Formula $d\ge10t$
\end_inset

 to get 
\begin_inset Formula $T(n)=\Theta\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Practice: the constants get high by using this guaranteed algorithm, so
 people tend to use a simpler rule for pivot choice (for both quickSelect
 and quickSort).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
Searching sorted arrays
\end_layout

\begin_layout Standard
It's a static version of the ordered dictionary problem.
 We assume the elements are ordered and stored in an array (consecutively;
 we can do direct addressing).
 The only thing a comparison-based search can do is to successively 
\emph on
probe
\emph default
 some positions in the array (i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset

compare them with the key that we search for).
\end_layout

\begin_layout Standard
The well-known binary search needs 
\begin_inset Formula $\log n+\Theta\left(1\right)$
\end_inset

 probes.
 Exercise: in the worst case any comparison-based data structure can't answer
 
\noun on
member
\begin_inset Formula $\left(x\right)$
\end_inset


\noun default
 faster (hint: decision tree lower bound).
 However, if we assume some properties about the data, we can expect to
 be even exponentially faster.
\end_layout

\begin_layout Standard
Notation: 
\begin_inset Formula $A\left[i\right]$
\end_inset

 for the value stored on the index 
\begin_inset Formula $i$
\end_inset

, and 
\begin_inset Formula $A\left[l\dots h\right]$
\end_inset

 for the currently searched segment.
 We assume the keys are numbers that are uniformly distributed over some
 interval, and we're searching for key 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Subsubsection
Interpolation search
\end_layout

\begin_layout Itemize
The next index to probe is always 
\begin_inset Formula $l+\left\lceil \frac{x-A[l]}{A[h]-A[l]}\left(h-l\right)\right\rceil $
\end_inset

 (naturally!).
\end_layout

\begin_layout Itemize
The expected number of probes needed is 
\begin_inset Formula $\log\log n+\Theta\left(1\right)$
\end_inset

, which is optimal (for searching sorted arrays via probes; cf.
\begin_inset space ~
\end_inset

dynamizing bucket sort).
\end_layout

\begin_layout Itemize
However, in the worst case the number of probes is 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

.
\end_layout

\begin_layout Standard
The expected complexity is quite difficult to prove, so we show a modified
 algorithm where it's much easier and we only have to pay a multiplicative
 constant.
\end_layout

\begin_layout Subsubsection
Generalized quadratic search
\end_layout

\begin_layout Standard
The probes are generated in blocks, where each looks like this:
\end_layout

\begin_layout Itemize
First we do an interpolation step.
 This determines the length of the following 
\emph on
unary
\emph default
 steps as 
\begin_inset Formula $\left\lfloor \sqrt{h-l}\right\rfloor $
\end_inset

.
\end_layout

\begin_layout Itemize
We alternate unary steps with binary steps until we jump over the value
 of 
\begin_inset Formula $x$
\end_inset

 with a unary step.
 Unary step just additively moves 
\begin_inset Formula $l$
\end_inset

 or 
\begin_inset Formula $h$
\end_inset

.
\end_layout

\begin_layout Standard
Such blocks get repeated until we find 
\begin_inset Formula $x$
\end_inset

.
 First note that together we do at most 
\begin_inset Formula $3\log n$
\end_inset

 probes (in the worst case!), because at least every third probe is binary.
\end_layout

\begin_layout Standard
The length of the segment always decreases to at most square root, so there
 can be at most 
\begin_inset Formula $\log\log n$
\end_inset

 blocks.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Theorem*
\begin_inset ERT
status open

\begin_layout Plain Layout

[Chebyshev inequality]
\end_layout

\end_inset


\begin_inset Formula $\forall k>0\quad{\displaystyle \Pr\left[\left|X-\Exp X\right|\ge k\right]\le\frac{\Var X}{k^{2}}}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Expected-case analysis
\end_layout

\begin_layout Standard
Denote 
\begin_inset Formula $X$
\end_inset

 as the index of 
\begin_inset Formula $x$
\end_inset

 within the segment 
\begin_inset Formula $A\left[l\dots h\right]$
\end_inset

, and let 
\begin_inset Formula $p:=\frac{x-A[l]}{A[h]-A[l]}$
\end_inset

.
 Notice that 
\begin_inset Formula $p$
\end_inset

 is the probability that an element in 
\begin_inset Formula $A\left[l\dots h\right]$
\end_inset

 is before 
\begin_inset Formula $x$
\end_inset

, so 
\begin_inset Formula $X$
\end_inset

 is binomially distributed within the segment, i.
\begin_inset space \thinspace{}
\end_inset

e.
\begin_inset space ~
\end_inset


\begin_inset Formula $X\sim\Bi\left(h-l,p\right)$
\end_inset

, and 
\begin_inset Formula $\mu:=\Exp X=p\left(h-l\right)$
\end_inset

 (note: that's our probe position), 
\begin_inset Formula $\sigma^{2}:=\Var X=p(1-p)(h-l)\le\frac{1}{4}\left(h-l\right)$
\end_inset

.
 Now by using Cheybshev inequality with 
\begin_inset Formula $k:=i\sqrt{h-l}$
\end_inset

 we have that 
\begin_inset Formula 
\[
\Pr\left[\left|X-p\left(h-l\right)\right|\ge i\sqrt{h-l}\right]\leq\frac{\frac{1}{4}\left(h-l\right)}{i^{2}\sqrt{h-l}^{2}}=\frac{1}{4i^{2}}.
\]

\end_inset

Consequently, the expected number of unary steps needed to skip 
\begin_inset Formula $x$
\end_inset

 is at most 
\begin_inset Formula $1+\sum_{i=1}^{\infty}\Pr\left[\mbox{more than \ensuremath{i}unary steps}\right]=1+\sum_{i=1}^{\infty}\frac{1}{4i^{2}}=1+\frac{\pi^{2}}{6}$
\end_inset

.
 The number of binary steps is lower, so the expected total number of all
 steps within a block is bounded by 
\begin_inset Formula $\underbrace{1}_{\mbox{i.}}+\underbrace{\frac{\pi^{2}}{6}}_{\mbox{binary}}+\underbrace{1+\frac{\pi^{2}}{6}}_{\mbox{unary}}=2+\frac{\pi^{2}}{3}<5.3$
\end_inset

.
\end_layout

\begin_layout Corollary*

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
The total expected number of probes of generalized quadratic search is bounded
 by 
\begin_inset Formula $5.3\log\log n$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Leftist heaps
\begin_inset CommandInset label
LatexCommand label
name "sec:Leftist-heaps"

\end_inset


\end_layout

\begin_layout Standard
The main advantage of leftist heaps against regular heaps is that they allow
 
\noun on
meld
\noun default
 in 
\begin_inset Formula $\Theta\left(\log n\right)$
\end_inset

 time.
 They are much simpler than binomial or Fibonacci heaps.
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\sp}{\mathsf{sp}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\root}{\mathsf{root}}
\end_inset


\end_layout

\begin_layout Subsubsection
Definition
\end_layout

\begin_layout Itemize
Binary tree with heap property, stored elements are 1-1 mapped to vertices.
\end_layout

\begin_layout Itemize
Let 
\begin_inset Formula $\sp\left(v\right)$
\end_inset

 be the length of the shortest path from 
\begin_inset Formula $v$
\end_inset

 within its subtree to a vertex with at least one child missing.
\end_layout

\begin_layout Itemize
Leftist property: if a vertex has only one child, then it's left; if 
\begin_inset Formula $v$
\end_inset

 has two children, then 
\begin_inset Formula $\sp\left(\l(v)\right)\ge\sp\left(\r\left(v\right)\right)$
\end_inset

.
\end_layout

\begin_layout Itemize
Each vertex also maintains a pointer to its parent.
\end_layout

\begin_layout Standard
Note that due to the leftist property the rightmost path from any 
\begin_inset Formula $v$
\end_inset

 is shortest among the paths down the subtree and so it has lenght 
\begin_inset Formula $\sp\left(v\right)$
\end_inset

.
 Therefore the subtree of 
\begin_inset Formula $v$
\end_inset

 is full up to the level of 
\begin_inset Formula $\sp\left(v\right)$
\end_inset

: 
\begin_inset Formula $n\ge\sum_{d=0}^{\sp\left(v\right)}2^{d}=2^{\sp\left(v\right)+1}-1$
\end_inset

, so 
\begin_inset Formula $\sp\left(v\right)\le\log\left(n+1\right)-1\le\log n$
\end_inset

 (for 
\begin_inset Formula $n>0$
\end_inset

).
\end_layout

\begin_layout Subsubsection
Operations
\end_layout

\begin_layout Standard
Note that paths in leftist heaps could be very long, so we can't afford
 using 
\noun on
up
\noun default
 and 
\noun on
down
\noun default
 as in regular heaps.
\end_layout

\begin_layout Paragraph

\noun on
meld
\noun default

\begin_inset Formula $\left(H_{1},H_{2}\right)$
\end_inset

:
\end_layout

\begin_layout Standard
The basic operation.
 Easy if either heap is empty, otherwise WLOG 
\begin_inset Formula $\root\left(H_{1}\right)\le\root\left(H_{2}\right)$
\end_inset

.
 We replace 
\begin_inset Formula $\r\left(\root\left(H_{1}\right)\right)$
\end_inset

 by its 
\noun on
meld
\noun default
 with 
\begin_inset Formula $H_{2}$
\end_inset

 (recursively).
 Then we recompute the value of 
\begin_inset Formula $\sp$
\end_inset

 from values in children, and we switch them if the leftist property got
 broken.
 Note that in every recursion step we shorten 
\begin_inset Formula $\sp$
\end_inset

 of one of the heaps being melded, so the total running time is 
\begin_inset Formula $\Theta\left(\log n\right)$
\end_inset

.
\end_layout

\begin_layout Paragraph

\noun on
insert
\noun default

\begin_inset Formula $\left(H,x\right)$
\end_inset

:
\end_layout

\begin_layout Standard
We just 
\noun on
meld
\noun default
 with a one-element heap created from 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Paragraph

\noun on
delMin
\noun default

\begin_inset Formula $\left(H\right)$
\end_inset

:
\end_layout

\begin_layout Standard
We remove the root and 
\noun on
meld
\noun default
 its children.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Paragraph

\noun on
makeHeap
\noun default

\begin_inset Formula $\left(A\right)$
\end_inset

:
\end_layout

\begin_layout Standard
We create a FIFO queue of heaps, initialized by singletons from the input.
 Then we repeatedly pop the first two heaps, 
\noun on
meld
\noun default
 them and push the result on the end of the queue.
 When only one heap remains, we have the result.
\end_layout

\begin_layout Standard
We show that the complexity is linear.
 We look at the queue's rounds of rotation: in round 
\begin_inset Formula $i$
\end_inset

 we 
\noun on
meld
\noun default
 at most 
\begin_inset Formula $\left\lceil n/2^{i}\right\rceil $
\end_inset

 pairs of heaps with sizes at most 
\begin_inset Formula $2^{i-1}$
\end_inset

.
 That means 
\begin_inset Formula $\sp\le\log\left(2^{i-1}+1\right)-1\le i-1$
\end_inset

 (as 
\begin_inset Formula $i\ge1$
\end_inset

), so each 
\noun on
meld
\noun default
 in round 
\begin_inset Formula $i$
\end_inset

 needs at most 
\begin_inset Formula $2(i-1)+1<2i$
\end_inset

 steps.
 Total work: 
\begin_inset Formula $\sum_{i=1}^{\left\lceil \log n\right\rceil }2i\left\lceil n/2^{i}\right\rceil \le\log n+2n\sum_{i=1}^{\left\lceil \log n\right\rceil }i/2^{i}\le\OO\left(n\right)$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Note Note
status open

\begin_layout Plain Layout
ToDo: fix removing the rounding
\end_layout

\end_inset

, as this is a finite sum alike to 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun on
\color inherit
makeHeap
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 of regular heaps.
\end_layout

\begin_layout Paragraph

\noun on
fix
\noun default

\begin_inset Formula $\left(H,p\right)$
\end_inset

:
\end_layout

\begin_layout Standard
An auxiliary operation to fix the values of 
\begin_inset Formula $\sp$
\end_inset

 just after it got decreased at some position 
\begin_inset Formula $p$
\end_inset

 (assuming all other properties are OK).
 We repeatedly go to the parent, recompute its 
\begin_inset Formula $\sp$
\end_inset

 and switch its children if necessary.
 We can stop when 
\begin_inset Formula $\sp$
\end_inset

 didn't change in the current vertex.
\end_layout

\begin_layout Standard
Note that whenever we decreased 
\begin_inset Formula $\sp$
\end_inset

 of a vertex, we set it to 
\begin_inset Formula $1+\sp$
\end_inset

 of the child that we came from.
 Thus the values of 
\begin_inset Formula $\sp$
\end_inset

 (after 
\noun on
fix
\noun default
) on the path that we walked are strictly increasing, and since 
\begin_inset Formula $\forall v\;\sp\left(v\right)\le\log n$
\end_inset

, the time is 
\begin_inset Formula $\Theta\left(\log n\right)$
\end_inset

.
\end_layout

\begin_layout Paragraph

\noun on
decrease
\noun default

\begin_inset Formula $\left(H,p,\delta\right)$
\end_inset

:
\end_layout

\begin_layout Standard
We cut the subtree of 
\begin_inset Formula $p$
\end_inset

, then 
\noun on
fix
\noun default
 
\begin_inset Formula $H$
\end_inset

 from 
\begin_inset Formula $p$
\end_inset

's former parent.
 Now 
\begin_inset Formula $p$
\end_inset

 points to a root, so we can just decrease its priority and 
\noun on
meld
\noun default
 the two heaps.
\end_layout

\begin_layout Paragraph

\noun on
delete
\noun default

\begin_inset Formula $\left(H,p\right)$
\end_inset

:
\end_layout

\begin_layout Standard
We remove 
\begin_inset Formula $p$
\end_inset

, leaving its child subtrees with the rest of 
\begin_inset Formula $h$
\end_inset

, then 
\noun on
fix
\noun default
 
\begin_inset Formula $H$
\end_inset

 from 
\begin_inset Formula $p$
\end_inset

's former parent.
 Now 
\noun on
meld
\noun default
 the three heaps together (in two operations).
\end_layout

\begin_layout Paragraph

\noun on
increase
\noun default

\begin_inset Formula $\left(H,p,\delta\right)$
\end_inset

:
\end_layout

\begin_layout Standard
We cut both children of 
\begin_inset Formula $p$
\end_inset

 and then 
\noun on
fix
\begin_inset Formula $\left(H,p\right)$
\end_inset


\noun default
.
 Now 
\begin_inset Formula $p$
\end_inset

 points to a leaf, so we can just increase its priority and 
\noun on
meld
\noun default
 the three heaps.
\end_layout

\begin_layout Corollary*
Leftist heaps need 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 space and 
\noun on
makeHeap
\noun default
 needs 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

 time.
 
\noun on
insert, delMin, delete, decrease, increase
\noun default
 and 
\noun on
meld
\noun default
 need 
\begin_inset Formula $\Theta\left(\log n\right)$
\end_inset

 time.
 
\end_layout

\begin_layout Remark*
It is possible to balance the subtrees by number of elements instead of
 
\begin_inset Formula $\sp$
\end_inset

 (
\begin_inset Quotes eld
\end_inset

weight-biased leftist trees
\begin_inset Quotes erd
\end_inset

).
 Experiments suggest that it is faster in practice.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\end_body
\end_document
