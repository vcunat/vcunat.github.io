<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Fractal Image Compressor: modules.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>modules.cpp</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &lt;typeinfo&gt;</span> <span class="comment">// needed for FerrisLoki/DataGenerators.h</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include "headers.h"</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="preprocessor">#include "modules/root.h"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include "modules/colorModel.h"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include "modules/squarePixels.h"</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include "modules/quadTree.h"</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "modules/stdDomains.h"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "modules/quality2SE.h"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "modules/stdEncoder.h"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "modules/vliCodec.h"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "modules/saupePredictor.h"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "modules/noPredictor.h"</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include "fileUtil.h"</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="preprocessor">#include "FerrisLoki/DataGenerators.h"</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="keyword">using namespace </span>std;
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="keyword">typedef</span> Loki::TL::MakeTypelist&lt; <a class="code" href="classMRoot.html" title="The root module implementation.">MRoot</a>, <a class="code" href="classMColorModel.html" title="Simple color transformer for affine models.">MColorModel</a>, <a class="code" href="classMSquarePixels.html" title="A simple shape transformer using square pixels.">MSquarePixels</a>, <a class="code" href="classMQuadTree.html" title="Module dividing range blocks with a quad-tree.">MQuadTree</a>, <a class="code" href="classMStdDomains.html" title="Standard domain-pool generator.">MStdDomains</a>
<a name="l00023"></a>00023 , <a class="code" href="classMQuality2SE__std.html" title="Standard quality-to-SE module - uses fixed SE for all block sizes.">MQuality2SE_std</a>, <a class="code" href="classMStdEncoder.html" title="Standard square encoder - uses affine color transformation for one-domain to one-range...">MStdEncoder</a>, <a class="code" href="classMDifferentialVLICodec.html" title="Variable-length-integer codec optimized for encoding little-changing sequences.">MDifferentialVLICodec</a>, <a class="code" href="classMSaupePredictor.html" title="Predictor for MStdEncoder based on a theorem proven in Saupe&amp;#39;s work.">MSaupePredictor</a>, <a class="code" href="classMNoPredictor.html" title="Predictor that doesn&amp;#39;t predict, just tries all the domains.">MNoPredictor</a>
<a name="l00024"></a>00024 , <a class="code" href="classMQuality2SE__alt.html" title="Alternate quality-to-SE module - uses fixed MSE for all block sizes.">MQuality2SE_alt</a> &gt;
<a name="l00025"></a>00025 ::Result Modules;
<a name="l00026"></a>00026 
<a name="l00027"></a><a class="code" href="util_8h.html#028bb9c3e9b53d4219f052cbd265e328">00027</a> <span class="keyword">const</span> <span class="keywordtype">int</span> powers[31]= { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2*1024         <span class="comment">/* 2^11 */</span>
<a name="l00028"></a>00028     , 4*1024, 8*1024, 16*1024, 32*1024, 64*1024, 128*1024, 256*1024, 512*1024       <span class="comment">/* 2^19 */</span>
<a name="l00029"></a>00029     , 1024*1024, 2*1024*1024, 4*1024*1024, 8*1024*1024, 16*1024*1024, 32*1024*1024  <span class="comment">/* 2^25 */</span>
<a name="l00030"></a>00030     , 64*1024*1024, 128*1024*1024, 256*1024*1024, 512*1024*1024, 1024*1024*1024 };  <span class="comment">/* 2^30 */</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structUpdateInfo.html#5174d13e768474aacf4eda4a2e2d865f" title="default for terminate, defined in modules.cpp">UpdateInfo::noTerminate</a>;
<a name="l00034"></a>00034 <span class="keyword">const</span> <a class="code" href="structUpdateInfo.html" title="Structure providing support for progress update and interruption (used for encoding)...">UpdateInfo</a> <a class="code" href="structUpdateInfo.html#7eb58ebeecf56cc1caf4984b1770f55a" title="empty UpdateInfo instance, in modules.cpp">UpdateInfo::none</a>= <a class="code" href="structUpdateInfo.html" title="Structure providing support for progress update and interruption (used for encoding)...">UpdateInfo</a>
<a name="l00035"></a>00035     ( <a class="code" href="structUpdateInfo.html#5174d13e768474aacf4eda4a2e2d865f" title="default for terminate, defined in modules.cpp">UpdateInfo::noTerminate</a>, &amp;<a class="code" href="structUpdateInfo.html#bd12f0cae4838f72b3538a48e7681ff7" title="does nothing, default for IncInt functions">UpdateInfo::emptyFunction</a>, &amp;<a class="code" href="structUpdateInfo.html#bd12f0cae4838f72b3538a48e7681ff7" title="does nothing, default for IncInt functions">UpdateInfo::emptyFunction</a> );
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="keyword">namespace </span>NOSPACE {
<a name="l00039"></a>00039     <span class="keyword">using namespace </span>Loki;
<a name="l00040"></a>00040     <span class="keyword">using namespace </span>Loki::TL;
<a name="l00041"></a>00041 
<a name="l00044"></a>00044     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Typelist,<span class="keyword">class</span> Interface&gt;
<a name="l00045"></a>00045     <span class="keyword">struct </span>Compatible;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iface&gt;
<a name="l00048"></a>00048     <span class="keyword">struct </span>Compatible&lt;NullType,Iface&gt; {
<a name="l00049"></a>00049         <span class="keyword">typedef</span> NullType Result;
<a name="l00050"></a>00050     };
<a name="l00051"></a>00051 
<a name="l00052"></a>00052     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Head,<span class="keyword">class</span> Tail,<span class="keyword">class</span> Iface&gt;
<a name="l00053"></a>00053     <span class="keyword">struct </span>Compatible&lt; Typelist&lt;Head,Tail&gt; , Iface &gt; {
<a name="l00054"></a>00054         <span class="keyword">typedef</span> <span class="keyword">typename</span> Select
<a name="l00055"></a>00055             &lt;SuperSubclass&lt;Iface,Head&gt;::value
<a name="l00056"></a>00056             ,Typelist&lt; Head , typename Compatible&lt;Tail,Iface&gt;::Result &gt;
<a name="l00057"></a>00057             ,<span class="keyword">typename</span> Compatible&lt;Tail,Iface&gt;::Result
<a name="l00058"></a>00058         &gt;::Result Result;
<a name="l00059"></a>00059     };
<a name="l00060"></a>00060 
<a name="l00061"></a>00061     <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span>ExtractId {
<a name="l00062"></a>00062         <span class="keywordtype">int</span> operator()()<span class="keyword"> const</span>
<a name="l00063"></a>00063 <span class="keyword">            </span>{ <span class="keywordflow">return</span> Loki::TL::IndexOf&lt;Modules,T&gt;::value; }
<a name="l00064"></a>00064     };
<a name="l00065"></a>00065 }
<a name="l00066"></a><a class="code" href="classInterface.html#3c61ce061b6cbd454aceb5e860eb9e10">00066</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iface&gt; <span class="keyword">const</span> vector&lt;int&gt;&amp; <a class="code" href="classInterface.html#3c61ce061b6cbd454aceb5e860eb9e10" title="Returns a reference to compMods_ (initializes it if empty).">Interface&lt;Iface&gt;::getCompMods</a>() {
<a name="l00067"></a>00067     <span class="keyword">using namespace </span>Loki::TL;
<a name="l00068"></a>00068     <span class="keyword">typedef</span> <span class="keyword">typename</span> Compatible&lt;Modules,Iface&gt;::Result CompList;
<a name="l00069"></a>00069 <span class="comment">//  if compMods_ vector is empty, create it and fill it</span>
<a name="l00070"></a>00070     <span class="keywordflow">if</span> ( <a class="code" href="classInterface.html#017699eb987e6caf1c53ee5d8dd54f18" title="IDs of modules derived from this interface.">compMods_</a>.empty() &amp;&amp; Length&lt;CompList&gt;::value ) {
<a name="l00071"></a>00071         <a class="code" href="classInterface.html#017699eb987e6caf1c53ee5d8dd54f18" title="IDs of modules derived from this interface.">compMods_</a>.reserve(Length&lt;CompList&gt;::value);
<a name="l00072"></a>00072         IterateTypes&lt;CompList,ExtractId&gt; gendata;
<a name="l00073"></a>00073         gendata( back_inserter(<a class="code" href="classInterface.html#017699eb987e6caf1c53ee5d8dd54f18" title="IDs of modules derived from this interface.">compMods_</a>) );
<a name="l00074"></a>00074     }
<a name="l00075"></a>00075     <span class="keywordflow">return</span> <a class="code" href="classInterface.html#017699eb987e6caf1c53ee5d8dd54f18" title="IDs of modules derived from this interface.">compMods_</a>;
<a name="l00076"></a>00076 }
<a name="l00077"></a>00077 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iface&gt; std::vector&lt;int&gt; <a class="code" href="classInterface.html" title="A base class for all interfaces, parametrized by the interface&amp;#39;s type.">Interface&lt;Iface&gt;::compMods_</a>;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 
<a name="l00081"></a>00081 <span class="keyword">const</span> <a class="code" href="structModule_1_1SettingTypeItem.html" title="Represents the type of one setting - including label, description, etc.">Module::SettingTypeItem</a> <a class="code" href="structModule_1_1SettingTypeItem.html#017407a16af8726a6de461bf40dea4c4" title="Predefined list terminator.">Module::SettingTypeItem</a>
<a name="l00082"></a>00082 <a class="code" href="structModule_1_1SettingTypeItem.html#017407a16af8726a6de461bf40dea4c4" title="Predefined list terminator.">::stopper</a>= { 0, 0, {Stop,{i:-1},{text:0}} };
<a name="l00083"></a>00083 
<a name="l00084"></a><a class="code" href="classModule.html#1122f016df478b67a21bd27d8083bbaf">00084</a> <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">Module::SettingItem</a>* <a class="code" href="classModule.html#1122f016df478b67a21bd27d8083bbaf" title="Creates a copy of module&amp;#39;s settings (includes the whole module subtree).">Module::copySettings</a>(<a class="code" href="classModule.html#0d7267d0abb3311b695471793ad723aa" title="Two types of cloning, used in clone.">CloneMethod</a> method)<span class="keyword"> const </span>{
<a name="l00085"></a>00085     ASSERT( method==DeepCopy || method==ShallowCopy );
<a name="l00086"></a>00086 <span class="comment">//  copy the settings array</span>
<a name="l00087"></a>00087     <span class="keywordtype">int</span> length= <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<a class="code" href="structModule_1_1TypeInfo.html#6fabafddb7b1669d9cbb6b3996a8c4a9" title="The number of setting items.">setLength</a>;
<a name="l00088"></a>00088     <span class="keywordflow">if</span> (!length)
<a name="l00089"></a>00089         <span class="keywordflow">return</span> 0;
<a name="l00090"></a>00090     <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">SettingItem</a> *result= <span class="keyword">new</span> <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">SettingItem</a>[length];
<a name="l00091"></a>00091     copy( <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>, <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>+length, result );
<a name="l00092"></a>00092 
<a name="l00093"></a>00093     <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">SettingItem</a> *item= result, *itemEnd= result+length;
<a name="l00094"></a>00094     <span class="keywordflow">if</span> (method==DeepCopy)
<a name="l00095"></a>00095     <span class="comment">//  make child modules copy themselves (deeply again)</span>
<a name="l00096"></a>00096         <span class="keywordflow">while</span> (item!=itemEnd) {
<a name="l00097"></a>00097             <span class="keywordflow">if</span> (item-&gt;<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>)
<a name="l00098"></a>00098                 item-&gt;<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>= item-&gt;<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>-&gt;<a class="code" href="classModule.html#40ff6b686b05a4757ccc592021fe189a" title="Cloning method, implemented in all modules via macros.">abstractClone</a>(DeepCopy);
<a name="l00099"></a>00099             ++item;
<a name="l00100"></a>00100         }
<a name="l00101"></a>00101     <span class="keywordflow">else</span> <span class="comment">// ShallowCopy</span>
<a name="l00102"></a>00102     <span class="comment">//  null module links</span>
<a name="l00103"></a>00103         <span class="keywordflow">while</span> (item!=itemEnd) {
<a name="l00104"></a>00104             item-&gt;<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>= 0;
<a name="l00105"></a>00105             ++item;
<a name="l00106"></a>00106         }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108     <span class="keywordflow">return</span> result;
<a name="l00109"></a>00109 }
<a name="l00110"></a><a class="code" href="classModule.html#5154ee9e5a649eaf2427dae434f4f57b">00110</a> <span class="keywordtype">void</span> <a class="code" href="classModule.html#5154ee9e5a649eaf2427dae434f4f57b" title="Called for prototypes to initialize the default links to other modules.">Module::initDefaultModuleLinks</a>() {
<a name="l00111"></a>00111 <span class="comment">//  iterate over all settings</span>
<a name="l00112"></a>00112     <span class="keyword">const</span> <a class="code" href="structModule_1_1SettingTypeItem.html" title="Represents the type of one setting - including label, description, etc.">SettingTypeItem</a> *setType= <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<a class="code" href="structModule_1_1TypeInfo.html#0f441c8f8d4dceec75aee383f478e625" title="The types of module&amp;#39;s settings.">setType</a>;
<a name="l00113"></a>00113     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; setType[i].<a class="code" href="structModule_1_1SettingTypeItem.html#e3cd318999bb228272c0e65adf6b20c7" title="The type of this setting.">type</a>.<a class="code" href="structModule_1_1SettingType.html#8baa28833330e216ae1fd6feebd812dd" title="The type of the item.">type</a>!=<a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc26cbe19ba5e3780bc9739e6c0092b4431" title="a list-terminator">Stop</a>; ++i )
<a name="l00114"></a>00114         <span class="keywordflow">if</span> (setType[i].type.<a class="code" href="structModule_1_1SettingTypeItem.html#e3cd318999bb228272c0e65adf6b20c7" title="The type of this setting.">type</a>==<a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc244a205073fbed44dccd69bb4adf53e5c" title="a connection to another module (shown as a combo-box)">ModuleCombo</a>) {
<a name="l00115"></a>00115         <span class="comment">//  it is a module link -&gt; initialize it with the right prototype</span>
<a name="l00116"></a>00116             ASSERT(!<a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[i].m);
<a name="l00117"></a>00117             <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[i].<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>= <a class="code" href="util_8h.html#7dcbfa1a47034c99f2e76ea4ffa8700a" title="Automatic version of const_cast for pointers.">constCast</a>(&amp;<a class="code" href="classModuleFactory.html#4fe6e48e4ad958b0c10c57fdfeec4d0a" title="Returns a reference to the module prototype with given id.">ModuleFactory::prototype</a>(
<a name="l00118"></a>00118                 (*setType[i].type.data.compatIDs)[<a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[i].<a class="code" href="structModule_1_1SettingItem.html#71a46105fdddba87d6fcc3f18648a608" title="The setting value.">val</a>.<a class="code" href="unionModule_1_1SettingValue.html#de47847b53cb9c43af708e37526fb648" title="Setting value for integer/module types (see Module::ChoiceType).">i</a>]
<a name="l00119"></a>00119             ));
<a name="l00120"></a>00120         }
<a name="l00121"></a>00121 }
<a name="l00122"></a><a class="code" href="classModule.html#bced57ac9e266f8674ea8a76e7aec51a">00122</a> <span class="keywordtype">void</span> <a class="code" href="classModule.html#bced57ac9e266f8674ea8a76e7aec51a" title="Called for prototypes to null links to other modules.">Module::nullModuleLinks</a>() {
<a name="l00123"></a>00123 <span class="comment">//  iterate over all settings</span>
<a name="l00124"></a>00124     <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">SettingItem</a> *itEnd= <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>+<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<a class="code" href="structModule_1_1TypeInfo.html#6fabafddb7b1669d9cbb6b3996a8c4a9" title="The number of setting items.">setLength</a>;
<a name="l00125"></a>00125     <span class="keywordflow">for</span> (<a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">SettingItem</a> *it=<a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>; it!=itEnd; ++it)
<a name="l00126"></a>00126         it-&gt;m= 0;
<a name="l00127"></a>00127 }
<a name="l00128"></a><a class="code" href="classModule.html#fdbe57bc3861787fdebaae2ce44e3eb8">00128</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> M&gt; M* <a class="code" href="classModule.html#fdbe57bc3861787fdebaae2ce44e3eb8" title="Concrete cloning method - templated by the actual type of the module.">Module::concreteClone</a>(<a class="code" href="classModule.html#0d7267d0abb3311b695471793ad723aa" title="Two types of cloning, used in clone.">CloneMethod</a> method)<span class="keyword"> const </span>{
<a name="l00129"></a>00129     ASSERT( <span class="keyword">this</span> &amp;&amp; <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<span class="keywordtype">id</span> == ModuleFactory::getModuleID&lt;M&gt;() );
<a name="l00130"></a>00130 <span class="comment">//  create a new instance of the same type and fill its settings with a copy of mine</span>
<a name="l00131"></a>00131     M *result= <span class="keyword">new</span> M;
<a name="l00132"></a>00132     result-&gt;settings= <a class="code" href="classModule.html#1122f016df478b67a21bd27d8083bbaf" title="Creates a copy of module&amp;#39;s settings (includes the whole module subtree).">copySettings</a>(method);
<a name="l00133"></a>00133     <span class="keywordflow">return</span> result;
<a name="l00134"></a>00134 }
<a name="l00135"></a>00135     
<a name="l00136"></a><a class="code" href="classModule.html#db6e18ffa28139a8f56995f41526a414">00136</a> <span class="keywordtype">void</span> <a class="code" href="classModule.html#db6e18ffa28139a8f56995f41526a414" title="Called for prototypes to create the settings and inicialize them with defaults.">Module::createDefaultSettings</a>() {
<a name="l00137"></a>00137     ASSERT(!<a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>);
<a name="l00138"></a>00138     <span class="keyword">const</span> <a class="code" href="structModule_1_1TypeInfo.html" title="Information about one module-type.">TypeInfo</a> &amp;inf= <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>();
<a name="l00139"></a>00139     <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>= <span class="keyword">new</span> <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">SettingItem</a>[inf.<a class="code" href="structModule_1_1TypeInfo.html#6fabafddb7b1669d9cbb6b3996a8c4a9" title="The number of setting items.">setLength</a>];
<a name="l00140"></a>00140     copy( inf.<a class="code" href="structModule_1_1TypeInfo.html#0f441c8f8d4dceec75aee383f478e625" title="The types of module&amp;#39;s settings.">setType</a>, inf.<a class="code" href="structModule_1_1TypeInfo.html#0f441c8f8d4dceec75aee383f478e625" title="The types of module&amp;#39;s settings.">setType</a>+inf.<a class="code" href="structModule_1_1TypeInfo.html#6fabafddb7b1669d9cbb6b3996a8c4a9" title="The number of setting items.">setLength</a>, <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a> );
<a name="l00141"></a>00141 }
<a name="l00142"></a>00142 
<a name="l00143"></a><a class="code" href="classModule.html#96e114820c3a84d684d5e2d661a764af">00143</a> <span class="keywordtype">void</span> <a class="code" href="classModule.html#96e114820c3a84d684d5e2d661a764af" title="Puts a module-identifier in a stream (which is the index in settings).">Module::file_saveModuleType</a>( ostream &amp;os, <span class="keywordtype">int</span> which ) {
<a name="l00144"></a>00144 <span class="comment">//  do some assertions - we expect to have the child module, etc.</span>
<a name="l00145"></a>00145     ASSERT( which&gt;=0 &amp;&amp; which&lt;<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().setLength );
<a name="l00146"></a>00146     <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">SettingItem</a> &amp;setItem= <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[which];
<a name="l00147"></a>00147     ASSERT( <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().setType[which].type.type==<a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc244a205073fbed44dccd69bb4adf53e5c" title="a connection to another module (shown as a combo-box)">ModuleCombo</a> &amp;&amp; setItem.<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a> );
<a name="l00148"></a>00148 <span class="comment">//  put the module's identifier</span>
<a name="l00149"></a>00149     put&lt;Uchar&gt;( os, setItem.<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>-&gt;<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<a class="code" href="structModule_1_1TypeInfo.html#256e567189a46d449dd975a82936134b" title="The module-type&amp;#39;s ID.">id</a> );
<a name="l00150"></a>00150 }
<a name="l00151"></a><a class="code" href="classModule.html#f398c50aa7db17f0ec2096a787141637">00151</a> <span class="keywordtype">void</span> <a class="code" href="classModule.html#f398c50aa7db17f0ec2096a787141637" title="Gets an module-identifier from the stream, initializes the pointer in settings with...">Module::file_loadModuleType</a>( istream &amp;is, <span class="keywordtype">int</span> which ) {
<a name="l00152"></a>00152 <span class="comment">//  do some assertions - we expect not to have the child module, etc.</span>
<a name="l00153"></a>00153     ASSERT( which&gt;=0 &amp;&amp; which&lt;<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().setLength );
<a name="l00154"></a>00154     <span class="keyword">const</span> <a class="code" href="structModule_1_1SettingTypeItem.html" title="Represents the type of one setting - including label, description, etc.">SettingTypeItem</a> &amp;setType= <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<a class="code" href="structModule_1_1TypeInfo.html#0f441c8f8d4dceec75aee383f478e625" title="The types of module&amp;#39;s settings.">setType</a>[which];
<a name="l00155"></a>00155     <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">SettingItem</a> &amp;setItem= <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[which];
<a name="l00156"></a>00156     ASSERT( setType.<a class="code" href="structModule_1_1SettingTypeItem.html#e3cd318999bb228272c0e65adf6b20c7" title="The type of this setting.">type</a>.<a class="code" href="structModule_1_1SettingType.html#8baa28833330e216ae1fd6feebd812dd" title="The type of the item.">type</a>==<a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc244a205073fbed44dccd69bb4adf53e5c" title="a connection to another module (shown as a combo-box)">ModuleCombo</a> &amp;&amp; !setItem.<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a> );
<a name="l00157"></a>00157 <span class="comment">//  get module identifier and check its existence</span>
<a name="l00158"></a>00158     <span class="keywordtype">int</span> newId= get&lt;Uchar&gt;(is);
<a name="l00159"></a>00159     <a class="code" href="util_8h.html#ff10f244de23061a13ff884eaeac2d7d" title="Checking a condition - throws std::exception if false.">checkThrow</a>( 0&lt;=newId &amp;&amp; newId&lt;Loki::TL::Length&lt;Modules&gt;::value );
<a name="l00160"></a>00160 <span class="comment">//  check module compatibility</span>
<a name="l00161"></a>00161     <span class="keyword">const</span> vector&lt;int&gt; &amp;v= *setType.<a class="code" href="structModule_1_1SettingTypeItem.html#e3cd318999bb228272c0e65adf6b20c7" title="The type of this setting.">type</a>.<a class="code" href="structModule_1_1SettingType.html#70a4906ea1b9f01bd9bd5cd999313679" title="Additional data, differs for different type.">data</a>.<a class="code" href="structModule_1_1SettingType.html#11c3bbb60a8dac48aaf38266da89a93c" title="Pointer to the vector of IDs of compatible modules (type==ModuleCombo), meant to...">compatIDs</a>;
<a name="l00162"></a>00162     <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[which].<a class="code" href="structModule_1_1SettingItem.html#71a46105fdddba87d6fcc3f18648a608" title="The setting value.">val</a>.<a class="code" href="unionModule_1_1SettingValue.html#de47847b53cb9c43af708e37526fb648" title="Setting value for integer/module types (see Module::ChoiceType).">i</a>= find(v.begin(),v.end(),newId) - v.begin();
<a name="l00163"></a>00163     <a class="code" href="util_8h.html#ff10f244de23061a13ff884eaeac2d7d" title="Checking a condition - throws std::exception if false.">checkThrow</a>( <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[which].val.i &lt; (<span class="keywordtype">int</span>)v.size() );
<a name="l00164"></a>00164 <span class="comment">//  create a new correct empty module</span>
<a name="l00165"></a>00165     setItem.<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>= <a class="code" href="classModuleFactory.html#a04f013d81baf61218167b7baccc732d" title="Returns a new instance of the module-type with given id.">ModuleFactory::newModule</a>(newId,ShallowCopy);
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00168"></a><a class="code" href="classModule.html#eb8ddf381baa54ae94627b17f7845bde">00168</a> <span class="keywordtype">void</span> <a class="code" href="classModule.html#eb8ddf381baa54ae94627b17f7845bde" title="Saves all the settings, icluding child modules.">Module::file_saveAllSettings</a>(std::ostream &amp;stream) {
<a name="l00169"></a>00169     <span class="keywordtype">int</span> setLength= <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<a class="code" href="structModule_1_1TypeInfo.html#6fabafddb7b1669d9cbb6b3996a8c4a9" title="The number of setting items.">setLength</a>;
<a name="l00170"></a>00170     <span class="keywordflow">if</span> (!setLength)
<a name="l00171"></a>00171         <span class="keywordflow">return</span>;
<a name="l00172"></a>00172     <span class="keywordflow">else</span>
<a name="l00173"></a>00173         ASSERT( <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a> &amp;&amp; setLength&gt;0 );
<a name="l00174"></a>00174     
<a name="l00175"></a>00175     <span class="keyword">const</span> <a class="code" href="structModule_1_1SettingTypeItem.html" title="Represents the type of one setting - including label, description, etc.">SettingTypeItem</a> *setType= <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<a class="code" href="structModule_1_1TypeInfo.html#0f441c8f8d4dceec75aee383f478e625" title="The types of module&amp;#39;s settings.">setType</a>;
<a name="l00176"></a>00176     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;setLength; ++i)
<a name="l00177"></a>00177         <span class="keywordflow">switch</span>(setType[i].type.<a class="code" href="structModule_1_1SettingTypeItem.html#e3cd318999bb228272c0e65adf6b20c7" title="The type of this setting.">type</a>) {
<a name="l00178"></a>00178         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc2386c8944cfbec7a3e93f98cc6fd98df2" title="integer from an interval">Int</a>:
<a name="l00179"></a>00179         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc208f683b276a92487fd695f445261fbc1" title="integer from an interval prefixed with 2^">IntLog2</a>:
<a name="l00180"></a>00180         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc2af3df288d47faf7294135ae83d214922" title="choice from a list of strings">Combo</a>:
<a name="l00181"></a>00181             put&lt;Uint32&gt;( stream, <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[i].<a class="code" href="structModule_1_1SettingItem.html#71a46105fdddba87d6fcc3f18648a608" title="The setting value.">val</a>.<a class="code" href="unionModule_1_1SettingValue.html#de47847b53cb9c43af708e37526fb648" title="Setting value for integer/module types (see Module::ChoiceType).">i</a> );
<a name="l00182"></a>00182             <span class="keywordflow">break</span>;
<a name="l00183"></a>00183         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc23dc9b84a0008e6302a3ec70e40a2d9f7" title="real number from an interval">Float</a>:
<a name="l00184"></a>00184             put&lt;float&gt;( stream, <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[i].<a class="code" href="structModule_1_1SettingItem.html#71a46105fdddba87d6fcc3f18648a608" title="The setting value.">val</a>.<a class="code" href="unionModule_1_1SettingValue.html#61257c78151335f2985193130565aebe" title="Setting value for real-number type (see Module::ChoiceType).">f</a> );
<a name="l00185"></a>00185             <span class="keywordflow">break</span>;
<a name="l00186"></a>00186         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc244a205073fbed44dccd69bb4adf53e5c" title="a connection to another module (shown as a combo-box)">ModuleCombo</a>:
<a name="l00187"></a>00187             <a class="code" href="classModule.html#96e114820c3a84d684d5e2d661a764af" title="Puts a module-identifier in a stream (which is the index in settings).">file_saveModuleType</a>( stream, i );
<a name="l00188"></a>00188             <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[i].<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>-&gt;<a class="code" href="classModule.html#eb8ddf381baa54ae94627b17f7845bde" title="Saves all the settings, icluding child modules.">file_saveAllSettings</a>(stream);
<a name="l00189"></a>00189             <span class="keywordflow">break</span>;
<a name="l00190"></a>00190         <span class="keywordflow">default</span>:
<a name="l00191"></a>00191             ASSERT(<span class="keyword">false</span>);
<a name="l00192"></a>00192         } <span class="comment">// switch</span>
<a name="l00193"></a>00193 }
<a name="l00194"></a>00194 
<a name="l00195"></a><a class="code" href="classModule.html#14e916b29b4ab3e5d9b5a769797eb392">00195</a> <span class="keywordtype">void</span> <a class="code" href="classModule.html#14e916b29b4ab3e5d9b5a769797eb392" title="Loads all the settings, icluding child modules (and their settings).">Module::file_loadAllSettings</a>(std::istream &amp;stream) {
<a name="l00196"></a>00196     <span class="keywordtype">int</span> setLength= <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<a class="code" href="structModule_1_1TypeInfo.html#6fabafddb7b1669d9cbb6b3996a8c4a9" title="The number of setting items.">setLength</a>;
<a name="l00197"></a>00197     ASSERT(setLength&gt;=0);
<a name="l00198"></a>00198     <span class="keywordflow">if</span> (!setLength)
<a name="l00199"></a>00199         <span class="keywordflow">return</span>;
<a name="l00200"></a>00200     <span class="keywordflow">if</span> (!<a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>)
<a name="l00201"></a>00201         <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>= <span class="keyword">new</span> <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">SettingItem</a>[setLength];
<a name="l00202"></a>00202     
<a name="l00203"></a>00203     <span class="keyword">const</span> <a class="code" href="structModule_1_1SettingTypeItem.html" title="Represents the type of one setting - including label, description, etc.">SettingTypeItem</a> *setType= <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().<a class="code" href="structModule_1_1TypeInfo.html#0f441c8f8d4dceec75aee383f478e625" title="The types of module&amp;#39;s settings.">setType</a>;
<a name="l00204"></a>00204     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;setLength; ++i)
<a name="l00205"></a>00205         <span class="keywordflow">switch</span>(setType[i].type.<a class="code" href="structModule_1_1SettingTypeItem.html#e3cd318999bb228272c0e65adf6b20c7" title="The type of this setting.">type</a>) {
<a name="l00206"></a>00206         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc2386c8944cfbec7a3e93f98cc6fd98df2" title="integer from an interval">Int</a>:
<a name="l00207"></a>00207         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc208f683b276a92487fd695f445261fbc1" title="integer from an interval prefixed with 2^">IntLog2</a>:
<a name="l00208"></a>00208         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc2af3df288d47faf7294135ae83d214922" title="choice from a list of strings">Combo</a>:
<a name="l00209"></a>00209             <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[i].<a class="code" href="structModule_1_1SettingItem.html#71a46105fdddba87d6fcc3f18648a608" title="The setting value.">val</a>.<a class="code" href="unionModule_1_1SettingValue.html#de47847b53cb9c43af708e37526fb648" title="Setting value for integer/module types (see Module::ChoiceType).">i</a>= get&lt;Uint32&gt;(stream);
<a name="l00210"></a>00210             <span class="keywordflow">break</span>;
<a name="l00211"></a>00211         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc23dc9b84a0008e6302a3ec70e40a2d9f7" title="real number from an interval">Float</a>:
<a name="l00212"></a>00212             <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[i].<a class="code" href="structModule_1_1SettingItem.html#71a46105fdddba87d6fcc3f18648a608" title="The setting value.">val</a>.<a class="code" href="unionModule_1_1SettingValue.html#61257c78151335f2985193130565aebe" title="Setting value for real-number type (see Module::ChoiceType).">f</a>= get&lt;float&gt;(stream);
<a name="l00213"></a>00213             <span class="keywordflow">break</span>;
<a name="l00214"></a>00214         <span class="keywordflow">case</span> <a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc244a205073fbed44dccd69bb4adf53e5c" title="a connection to another module (shown as a combo-box)">ModuleCombo</a>:
<a name="l00215"></a>00215             <a class="code" href="classModule.html#f398c50aa7db17f0ec2096a787141637" title="Gets an module-identifier from the stream, initializes the pointer in settings with...">file_loadModuleType</a>( stream, i );
<a name="l00216"></a>00216             <a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>[i].<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>-&gt;<a class="code" href="classModule.html#14e916b29b4ab3e5d9b5a769797eb392" title="Loads all the settings, icluding child modules (and their settings).">file_loadAllSettings</a>(stream);
<a name="l00217"></a>00217             <span class="keywordflow">break</span>;
<a name="l00218"></a>00218         <span class="keywordflow">default</span>:
<a name="l00219"></a>00219             ASSERT(<span class="keyword">false</span>);
<a name="l00220"></a>00220         } <span class="comment">// switch</span>
<a name="l00221"></a>00221 }
<a name="l00222"></a>00222 
<a name="l00224"></a>00224 <a class="code" href="classModuleFactory.html" title="A singleton factory class for creating modules.">ModuleFactory</a>* <a class="code" href="classModuleFactory.html#10557479de324c1a2fc8168769de48c5" title="Static pointer to the only instance of the ModuleFactory.">ModuleFactory::instance</a>=0;
<a name="l00225"></a>00225 
<a name="l00226"></a><a class="code" href="classModuleFactory.html#c3832c78915135cde0d126557e01c332">00226</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> M&gt; <span class="keywordtype">int</span> <a class="code" href="classModuleFactory.html#c3832c78915135cde0d126557e01c332" title="Returns the ID of a module-type.">ModuleFactory::getModuleID</a>()
<a name="l00227"></a>00227     { <span class="keywordflow">return</span> Loki::TL::IndexOf&lt;Modules,M&gt;::value; }
<a name="l00228"></a>00228     
<a name="l00229"></a>00229 
<a name="l00230"></a><a class="code" href="classModuleFactory.html#2e1d9dc458f1bc1b4ec2a793923a9fb6">00230</a> <span class="keywordtype">void</span> <a class="code" href="classModuleFactory.html#2e1d9dc458f1bc1b4ec2a793923a9fb6" title="The real constructing routine.">ModuleFactory::initialize</a>() {
<a name="l00231"></a>00231 <span class="comment">//  create one instance of each module-type</span>
<a name="l00232"></a>00232     ASSERT( <a class="code" href="classModuleFactory.html#340df38d1c652ee5174beb1886dd2e09" title="Pointers to the prototypes for every module type (indexed by their ID&amp;#39;s).">prototypes</a>.empty() );
<a name="l00233"></a>00233     <a class="code" href="classModuleFactory.html#340df38d1c652ee5174beb1886dd2e09" title="Pointers to the prototypes for every module type (indexed by their ID&amp;#39;s).">prototypes</a>.reserve( Loki::TL::Length&lt;Modules&gt;::value );
<a name="l00234"></a>00234     Loki::TL::IterateTypes&lt;Modules,Creator&gt; gendata;
<a name="l00235"></a>00235     gendata( back_inserter(<a class="code" href="classModuleFactory.html#340df38d1c652ee5174beb1886dd2e09" title="Pointers to the prototypes for every module type (indexed by their ID&amp;#39;s).">prototypes</a>) );
<a name="l00236"></a>00236 <span class="comment">//  initialize the prototypes' settings and interconnections</span>
<a name="l00237"></a>00237     for_each( <a class="code" href="classModuleFactory.html#340df38d1c652ee5174beb1886dd2e09" title="Pointers to the prototypes for every module type (indexed by their ID&amp;#39;s).">prototypes</a>, mem_fun(&amp;<a class="code" href="classModule.html#db6e18ffa28139a8f56995f41526a414" title="Called for prototypes to create the settings and inicialize them with defaults.">Module::createDefaultSettings</a>) );
<a name="l00238"></a>00238     for_each( <a class="code" href="classModuleFactory.html#340df38d1c652ee5174beb1886dd2e09" title="Pointers to the prototypes for every module type (indexed by their ID&amp;#39;s).">prototypes</a>, mem_fun(&amp;<a class="code" href="classModule.html#5154ee9e5a649eaf2427dae434f4f57b" title="Called for prototypes to initialize the default links to other modules.">Module::initDefaultModuleLinks</a>) );
<a name="l00239"></a>00239 }
<a name="l00240"></a><a class="code" href="classModuleFactory.html#de033bafb95d3e0603a0df2ac1d4590f">00240</a> <span class="keywordtype">void</span> <a class="code" href="classModuleFactory.html#de033bafb95d3e0603a0df2ac1d4590f" title="Sets appropriate prototype settings according to given module&amp;#39;s settings.">ModuleFactory::changeDefaultSettings</a>(<span class="keyword">const</span> <a class="code" href="classModule.html" title="A common base class for all modules.">Module</a> &amp;module) {
<a name="l00241"></a>00241 <span class="comment">//  get the right prototype</span>
<a name="l00242"></a>00242     <span class="keyword">const</span> <a class="code" href="structModule_1_1TypeInfo.html" title="Information about one module-type.">Module::TypeInfo</a> &amp;mi= module.<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>();
<a name="l00243"></a>00243     <a class="code" href="structModule_1_1SettingItem.html" title="Represents one setting value in a module.">Module::SettingItem</a> *protSet= <a class="code" href="classModuleFactory.html#4fe6e48e4ad958b0c10c57fdfeec4d0a" title="Returns a reference to the module prototype with given id.">prototype</a>(mi.<a class="code" href="structModule_1_1TypeInfo.html#256e567189a46d449dd975a82936134b" title="The module-type&amp;#39;s ID.">id</a>).<a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>;
<a name="l00244"></a>00244 <span class="comment">//  replace prototype's settings</span>
<a name="l00245"></a>00245     ASSERT( protSet &amp;&amp; module.<a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a> );
<a name="l00246"></a>00246     copy( module.<a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>, module.<a class="code" href="classModule.html#05a8665b709707811945fa29714c2e00" title="The current setting values of this Module.">settings</a>+mi.<a class="code" href="structModule_1_1TypeInfo.html#6fabafddb7b1669d9cbb6b3996a8c4a9" title="The number of setting items.">setLength</a>, protSet );
<a name="l00247"></a>00247 <span class="comment">//  convert module-links to links to the correct prototypes</span>
<a name="l00248"></a>00248     <span class="keywordflow">for</span> (<span class="keyword">const</span> Module::SettingTypeItem *setType= mi.<a class="code" href="structModule_1_1TypeInfo.html#0f441c8f8d4dceec75aee383f478e625" title="The types of module&amp;#39;s settings.">setType</a>
<a name="l00249"></a>00249     ; setType-&gt;type.type!=<a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc26cbe19ba5e3780bc9739e6c0092b4431" title="a list-terminator">Module::Stop</a>; ++setType,++protSet)
<a name="l00250"></a>00250         <span class="keywordflow">if</span> ( setType-&gt;type.type==<a class="code" href="classModule.html#0baedffa9e50881da4626ec45dc23cc244a205073fbed44dccd69bb4adf53e5c" title="a connection to another module (shown as a combo-box)">Module::ModuleCombo</a> ) {
<a name="l00251"></a>00251             ASSERT(protSet-&gt;<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>);
<a name="l00252"></a>00252             protSet-&gt;<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>= <a class="code" href="util_8h.html#7dcbfa1a47034c99f2e76ea4ffa8700a" title="Automatic version of const_cast for pointers.">constCast</a>(&amp;<a class="code" href="classModuleFactory.html#4fe6e48e4ad958b0c10c57fdfeec4d0a" title="Returns a reference to the module prototype with given id.">prototype</a>( protSet-&gt;<a class="code" href="structModule_1_1SettingItem.html#17f621f90a4080f17bc1db4e60f26670" title="Pointer to the connected module (if type is Module::ModuleCombo).">m</a>-&gt;<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>().id ));
<a name="l00253"></a>00253         }
<a name="l00254"></a>00254 }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">int</span> ModuleFactory::Instantiator&lt;T&gt;::operator()()<span class="keyword"> const </span>{
<a name="l00258"></a>00258     <span class="keywordtype">int</span> i= getModuleID&lt;T&gt;();
<a name="l00259"></a>00259     <a class="code" href="classModule.html" title="A common base class for all modules.">Module</a> *m= T::newCompatibleModule();
<a name="l00260"></a>00260     m= m-&gt;concreteClone&lt;T&gt;(Module::DeepCopy);
<a name="l00261"></a>00261     i+= T::getCompMods().front();
<a name="l00262"></a>00262     <span class="keywordflow">return</span> i;
<a name="l00263"></a>00263 }
<a name="l00264"></a><a class="code" href="classModuleFactory.html#f1e04431ebf6cedf3c14bf93fd4f5bc8">00264</a> <span class="keywordtype">void</span> <a class="code" href="classModuleFactory.html#f1e04431ebf6cedf3c14bf93fd4f5bc8" title="Never called, only exists for certain templates to be instantiated in modules.cpp...">ModuleFactory::instantiateModules</a>() {
<a name="l00265"></a>00265     IterateTypes&lt;Modules,Instantiator&gt; gendata;
<a name="l00266"></a>00266     vector&lt;int&gt; v;
<a name="l00267"></a>00267     gendata(back_inserter(v));
<a name="l00268"></a>00268 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 6 22:33:14 2009 for Fractal Image Compressor by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
