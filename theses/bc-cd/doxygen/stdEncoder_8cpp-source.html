<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Fractal Image Compressor: modules/stdEncoder.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>modules/stdEncoder.cpp</h1><a href="stdEncoder_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#include &lt;memory&gt;</span> <span class="comment">// auto_ptr</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="preprocessor">#include "stdEncoder.h"</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include "../fileUtil.h"</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="keyword">using namespace </span>std;
<a name="l00007"></a>00007 
<a name="l00009"></a>00009 
<a name="l00011"></a><a class="code" href="namespaceQuantizer.html">00011</a> <span class="keyword">namespace </span>Quantizer {
<a name="l00013"></a><a class="code" href="namespaceQuantizer.html#4c01228bcd549ce8090c553a29869d6e">00013</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespaceQuantizer.html#4c01228bcd549ce8090c553a29869d6e" title="Quantizes f that belongs to [0,possib/2^scale] into [0,possib-1].">quantizeByPower</a>(Real f,<span class="keywordtype">int</span> scale,<span class="keywordtype">int</span> possib) {
<a name="l00014"></a>00014         ASSERT( f&gt;=0 &amp;&amp; f&lt;=possib/(Real)powers[scale] );
<a name="l00015"></a>00015         <span class="keywordtype">int</span> result= (int)trunc(ldexp(f,scale));
<a name="l00016"></a>00016         ASSERT( result&gt;=0 &amp;&amp; result&lt;=possib );
<a name="l00017"></a>00017         <span class="keywordflow">return</span> result&lt;possib ? result : --result;
<a name="l00018"></a>00018     }
<a name="l00020"></a><a class="code" href="namespaceQuantizer.html#882c381c78eb4895e0b78f34403e4569">00020</a>     <span class="keyword">inline</span> Real <a class="code" href="namespaceQuantizer.html#882c381c78eb4895e0b78f34403e4569" title="Performs the opposite to quantizeByPower.">dequantizeByPower</a>(<span class="keywordtype">int</span> i,<span class="keywordtype">int</span> scale,<span class="keywordtype">int</span> DEBUG_ONLY(possib)) {
<a name="l00021"></a>00021         ASSERT( i&gt;=0 &amp;&amp; i&lt;possib );
<a name="l00022"></a>00022         Real result= ldexp(i+Real(0.5),-scale);
<a name="l00023"></a>00023         ASSERT( result&gt;=0 &amp;&amp; result&lt;= possib/(Real)powers[scale] );
<a name="l00024"></a>00024         <span class="keywordflow">return</span> result;
<a name="l00025"></a>00025     }
<a name="l00026"></a>00026 
<a name="l00027"></a>00027     <span class="keyword">class </span>QuantBase {
<a name="l00028"></a>00028     <span class="keyword">protected</span>:
<a name="l00029"></a>00029         <span class="keywordtype">int</span> scale   
<a name="l00030"></a>00030         , possib;   
<a name="l00031"></a>00031     <span class="keyword">public</span>:
<a name="l00033"></a>00033         <span class="keywordtype">int</span> quant(Real val)<span class="keyword"> const</span>
<a name="l00034"></a>00034 <span class="keyword">            </span>{ <span class="keywordflow">return</span> <a class="code" href="namespaceQuantizer.html#4c01228bcd549ce8090c553a29869d6e" title="Quantizes f that belongs to [0,possib/2^scale] into [0,possib-1].">quantizeByPower</a>(val,scale,possib); }
<a name="l00036"></a>00036         <a class="code" href="namespaceMTypes.html#794a900a7af0af1cedefda7db5cd0c43" title="The floating-point type in which most computations are made.">Real</a> dequant(<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00037"></a>00037 <span class="keyword">            </span>{ <span class="keywordflow">return</span> <a class="code" href="namespaceQuantizer.html#882c381c78eb4895e0b78f34403e4569" title="Performs the opposite to quantizeByPower.">dequantizeByPower</a>(i,scale,possib); }
<a name="l00039"></a>00039         <a class="code" href="namespaceMTypes.html#794a900a7af0af1cedefda7db5cd0c43" title="The floating-point type in which most computations are made.">Real</a> qRound(Real val)<span class="keyword"> const</span>
<a name="l00040"></a>00040 <span class="keyword">            </span>{ <span class="keywordflow">return</span> dequant(quant(val)); }
<a name="l00041"></a>00041     };
<a name="l00042"></a>00042 
<a name="l00044"></a><a class="code" href="classQuantizer_1_1Average.html">00044</a>     <span class="keyword">class </span><a class="code" href="classQuantizer_1_1Average.html" title="(De)Quantizer for range-block averages, only initializes QuantBase correctly">Average</a>: <span class="keyword">public</span> QuantBase {
<a name="l00045"></a>00045     <span class="keyword">public</span>:
<a name="l00046"></a>00046         <a class="code" href="classQuantizer_1_1Average.html" title="(De)Quantizer for range-block averages, only initializes QuantBase correctly">Average</a>(<span class="keywordtype">int</span> possibLog2) {
<a name="l00047"></a>00047             ASSERT(possibLog2&gt;0);
<a name="l00048"></a>00048         <span class="comment">//  the average is from [0,1]</span>
<a name="l00049"></a>00049             scale= possibLog2;
<a name="l00050"></a>00050             possib= powers[possibLog2];
<a name="l00051"></a>00051         }   
<a name="l00052"></a>00052     };
<a name="l00053"></a>00053 
<a name="l00055"></a><a class="code" href="classQuantizer_1_1Deviation.html">00055</a>     <span class="keyword">class </span><a class="code" href="classQuantizer_1_1Deviation.html" title="(De)Quantizer for range-block deviations, only initializes QuantBase correctly">Deviation</a>: <span class="keyword">public</span> QuantBase {
<a name="l00056"></a>00056     <span class="keyword">public</span>:
<a name="l00057"></a>00057         <a class="code" href="classQuantizer_1_1Deviation.html" title="(De)Quantizer for range-block deviations, only initializes QuantBase correctly">Deviation</a>(<span class="keywordtype">int</span> possibLog2) {
<a name="l00058"></a>00058             ASSERT(possibLog2&gt;0);
<a name="l00059"></a>00059         <span class="comment">//  the deviation is from [0,0.5] -&gt; we have to scale twice more (log2+=1)</span>
<a name="l00060"></a>00060             scale= possibLog2+1;
<a name="l00061"></a>00061             possib= powers[possibLog2];
<a name="l00062"></a>00062         }
<a name="l00063"></a>00063     };
<a name="l00064"></a>00064 } <span class="comment">// Quantizer namespace</span>
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 
<a name="l00068"></a><a class="code" href="stdEncoder_8cpp.html#c7c7978ac80ab8a9e6d4cd8ac39a6ec1">00068</a> <span class="keyword">inline</span> <span class="keyword">static</span> <a class="code" href="structBlock.html" title="A simple structure representing a rectangle.">Block</a> <a class="code" href="stdEncoder_8cpp.html#c7c7978ac80ab8a9e6d4cd8ac39a6ec1" title="Adjust block of a domain to be mapped equally on an incomplete range (depends on...">adjustDomainForIncompleteRange</a>( <a class="code" href="structBlock.html" title="A simple structure representing a rectangle.">Block</a> range, <span class="keywordtype">int</span> rotation, <a class="code" href="structBlock.html" title="A simple structure representing a rectangle.">Block</a> domain ) {
<a name="l00069"></a>00069     <span class="comment">// 0, 0T: top left</span>
<a name="l00070"></a>00070     <span class="comment">// 1, 1T: top right</span>
<a name="l00071"></a>00071     <span class="comment">// 2, 2T: bottom right</span>
<a name="l00072"></a>00072     <span class="comment">// 3, 3T: bottom left</span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074     ASSERT( 0&lt;=rotation &amp;&amp; rotation&lt;8 );
<a name="l00075"></a>00075     <span class="keywordtype">int</span> rotID= rotation/2;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077     <span class="keywordtype">int</span> xSize= range.<a class="code" href="structBlock.html#9334f163ead624c8baecf18fc8026cbc">width</a>();
<a name="l00078"></a>00078     <span class="keywordtype">int</span> ySize= range.<a class="code" href="structBlock.html#345f9061cb0c5572118ab0b9cb4ed8f4">height</a>();
<a name="l00079"></a>00079     
<a name="l00080"></a>00080     <span class="keywordtype">int</span> magic= rotID+rotation%2;
<a name="l00081"></a>00081     <span class="keywordflow">if</span> ( magic==1 || magic==3 ) <span class="comment">// for rotations 0T, 1, 2T, 3 -&gt; swapped x and y</span>
<a name="l00082"></a>00082         swap(xSize,ySize);
<a name="l00083"></a>00083 
<a name="l00084"></a>00084     <span class="keywordflow">if</span> ( rotID&gt;1 )  <span class="comment">// domain rotations 2, 3, 2T, 3T -&gt; aligned to the bottom</span>
<a name="l00085"></a>00085         domain.<a class="code" href="structBlock.html#46861437cbb0debca2cc82b7beef2ff3">y0</a>= domain.<a class="code" href="structBlock.html#02d734c9e46dccdd7f5652d19eef9e8e">yend</a>-ySize;
<a name="l00086"></a>00086     <span class="keywordflow">else</span>            <span class="comment">// other rotations are aligned to the top</span>
<a name="l00087"></a>00087         domain.<a class="code" href="structBlock.html#02d734c9e46dccdd7f5652d19eef9e8e">yend</a>= domain.<a class="code" href="structBlock.html#46861437cbb0debca2cc82b7beef2ff3">y0</a>+ySize;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089     <span class="keywordflow">if</span> ( rotID==1 || rotID==2 ) <span class="comment">// rotations 1, 2, 1T, 2T -&gt; aligned to the right</span>
<a name="l00090"></a>00090         domain.<a class="code" href="structBlock.html#fadf3e74377e48a4121802807a98281f">x0</a>= domain.<a class="code" href="structBlock.html#94ad9c4eb82539b860af26894751148b">xend</a>-xSize;
<a name="l00091"></a>00091     <span class="keywordflow">else</span>                        <span class="comment">// other rotations are aligned to the left</span>
<a name="l00092"></a>00092         domain.<a class="code" href="structBlock.html#94ad9c4eb82539b860af26894751148b">xend</a>= domain.<a class="code" href="structBlock.html#fadf3e74377e48a4121802807a98281f">x0</a>+xSize;
<a name="l00093"></a>00093     
<a name="l00094"></a>00094     <span class="keywordflow">return</span> domain;
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 
<a name="l00098"></a>00098 
<a name="l00099"></a><a class="code" href="classMStdEncoder.html#72466f7488c16a9eeac821604fe8b833">00099</a> <span class="keywordtype">void</span> <a class="code" href="classMStdEncoder.html#72466f7488c16a9eeac821604fe8b833" title="Initializes the module for encoding or decoding of a PlaneBlock.">MStdEncoder::initialize</a>( <a class="code" href="structIRoot.html#b0f523cc6c5db940bd9965a3c8071489" title="The root can be in any of these modes.">IRoot::Mode</a> mode, PlaneBlock &amp;planeBlock_ ) {
<a name="l00100"></a>00100     <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>= &amp;planeBlock_;
<a name="l00101"></a>00101 <span class="comment">//  prepare the domains-module</span>
<a name="l00102"></a>00102     <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;domains-&gt;initPools(*<a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104     <span class="keywordtype">int</span> maxLevel= 1 +<a class="code" href="util_8h.html#97975b87cbe19485ff0af12d5972f54e" title="Returns ceil(log2(i)).">log2ceil</a>(max( <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;width, <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;height ));
<a name="l00105"></a>00105 <span class="comment">//  prepare levelPoolInfos</span>
<a name="l00106"></a>00106     <a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>.resize(maxLevel);
<a name="l00107"></a>00107 
<a name="l00108"></a>00108     <span class="keywordflow">if</span> (mode==<a class="code" href="structIRoot.html#b0f523cc6c5db940bd9965a3c807148983bcc429fa82e6658e8a9826944c1ecb" title="contains an encoded image">IRoot::Encode</a>) {
<a name="l00109"></a>00109         <span class="keyword">typedef</span> <a class="code" href="structISquareDomains.html#45c376d77fceab3d7b7db33d759976f2" title="List of pools.">ISquareDomains::PoolList</a> PoolList;
<a name="l00110"></a>00110     <span class="comment">//  prepare the domains</span>
<a name="l00111"></a>00111         <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;domains-&gt;fillPixelsInPools(*<a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>);
<a name="l00112"></a>00112         for_each( <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;domains-&gt;getPools(), mem_fun_ref(&amp;Pool::summers_makeValid) );
<a name="l00113"></a>00113     <span class="comment">//  initialize the range summers</span>
<a name="l00114"></a>00114         <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;summers_makeValid();
<a name="l00115"></a>00115 
<a name="l00116"></a>00116     <span class="comment">//  prepare maximum SquareErrors allowed for regular range blocks</span>
<a name="l00117"></a>00117         <a class="code" href="classMStdEncoder.html#04d0c3363d57c2d7f51d9ad2b6d5ef1d" title="Caches the result of IQuality2SE::regularRangeErrors.">stdRangeSEs</a>.resize(maxLevel+1);
<a name="l00118"></a>00118         <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;settings-&gt;moduleQ2SE-&gt;regularRangeErrors
<a name="l00119"></a>00119             ( <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;settings-&gt;quality, maxLevel+1, &amp;<a class="code" href="classMStdEncoder.html#04d0c3363d57c2d7f51d9ad2b6d5ef1d" title="Caches the result of IQuality2SE::regularRangeErrors.">stdRangeSEs</a>.front() );
<a name="l00120"></a>00120     }
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 <span class="keyword">namespace </span>NOSPACE {
<a name="l00125"></a>00125     <span class="keyword">struct </span>LevelPoolInfo_indexComparator {
<a name="l00126"></a>00126         <span class="keyword">typedef</span> <a class="code" href="structISquareEncoder_1_1LevelPoolInfo.html" title="Used by encoders, represents information about a domain pool on a level.">ISquareEncoder::LevelPoolInfo</a> LevelPoolInfo;
<a name="l00127"></a>00127         <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> LevelPoolInfo &amp;a, <span class="keyword">const</span> LevelPoolInfo &amp;b )
<a name="l00128"></a>00128             { <span class="keywordflow">return</span> a.indexBegin &lt; b.indexBegin; }
<a name="l00129"></a>00129     };
<a name="l00130"></a>00130 }
<a name="l00131"></a>00131 MStdEncoder::PoolInfos::const_iterator <a class="code" href="classMStdEncoder.html#93596feb53db6e9c77e5c461b1a8f678" title="Return iterator to the pool of domain with index domID.">MStdEncoder</a>
<a name="l00132"></a><a class="code" href="classMStdEncoder.html#93596feb53db6e9c77e5c461b1a8f678">00132</a> <a class="code" href="classMStdEncoder.html#93596feb53db6e9c77e5c461b1a8f678" title="Return iterator to the pool of domain with index domID.">::getPoolFromDomID</a>( <span class="keywordtype">int</span> domID, <span class="keyword">const</span> PoolInfos &amp;poolInfos ) {
<a name="l00133"></a>00133     ASSERT( domID&gt;=0 &amp;&amp; domID&lt;poolInfos.back().indexBegin );
<a name="l00134"></a>00134 <span class="comment">//  get the right pool</span>
<a name="l00135"></a>00135     PoolInfos::value_type toFind;
<a name="l00136"></a>00136     toFind.indexBegin= domID;
<a name="l00137"></a>00137     <span class="keywordflow">return</span> upper_bound( poolInfos.begin(), poolInfos.end(), toFind
<a name="l00138"></a>00138         , LevelPoolInfo_indexComparator() ) -1;
<a name="l00139"></a>00139 }
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="keyword">const</span> ISquareDomains::Pool&amp; <a class="code" href="classMStdEncoder.html#3a5458e7264262d41b780f17dfa84fff" title="Considers a domain on a level number domIndex (in pools and poolInfos) and sets block...">MStdEncoder::getDomainData</a>
<a name="l00142"></a><a class="code" href="classMStdEncoder.html#3a5458e7264262d41b780f17dfa84fff">00142</a> ( <span class="keyword">const</span> RangeNode &amp;rangeBlock, <span class="keyword">const</span> <a class="code" href="structISquareDomains.html#45c376d77fceab3d7b7db33d759976f2" title="List of pools.">ISquareDomains::PoolList</a> &amp;pools
<a name="l00143"></a>00143 , <span class="keyword">const</span> PoolInfos &amp;poolInfos, <span class="keywordtype">int</span> domIndex, <span class="keywordtype">int</span> zoom, <a class="code" href="structBlock.html" title="A simple structure representing a rectangle.">Block</a> &amp;block ) {
<a name="l00144"></a>00144 
<a name="l00145"></a>00145 <span class="comment">//  get the pool</span>
<a name="l00146"></a>00146     PoolInfos::const_iterator it= getPoolFromDomID( domIndex, poolInfos );
<a name="l00147"></a>00147     <span class="keyword">const</span> Pool &amp;pool= pools[ it - poolInfos.begin() ];
<a name="l00148"></a>00148 <span class="comment">//  get the coordinates</span>
<a name="l00149"></a>00149     <span class="keywordtype">int</span> indexInPool= domIndex - it-&gt;indexBegin;
<a name="l00150"></a>00150     ASSERT( indexInPool&gt;=0 &amp;&amp; indexInPool&lt;(it+1)-&gt;indexBegin );
<a name="l00151"></a>00151     <span class="keywordtype">int</span> sizeNZ= powers[rangeBlock.level-zoom];
<a name="l00152"></a>00152     <span class="keywordtype">int</span> zoomFactor= powers[zoom];
<a name="l00153"></a>00153 <span class="comment">//  changed: the domains are mapped along columns and not rows</span>
<a name="l00154"></a>00154     <span class="keywordtype">int</span> domsInCol= <a class="code" href="util_8h.html#4ce0a3a4858f93f91545ac291fe77234" title="How many short intervals (shifted by density) can fit into a long interval (discrete)...">getCountForDensity</a>( pool.height/zoomFactor, it-&gt;density, sizeNZ );
<a name="l00155"></a>00155     block.<a class="code" href="structBlock.html#fadf3e74377e48a4121802807a98281f">x0</a>= (indexInPool/domsInCol)*it-&gt;density*zoomFactor;
<a name="l00156"></a>00156     block.<a class="code" href="structBlock.html#46861437cbb0debca2cc82b7beef2ff3">y0</a>= (indexInPool%domsInCol)*it-&gt;density*zoomFactor;
<a name="l00157"></a>00157     block.<a class="code" href="structBlock.html#94ad9c4eb82539b860af26894751148b">xend</a>= block.<a class="code" href="structBlock.html#fadf3e74377e48a4121802807a98281f">x0</a>+powers[rangeBlock.level];
<a name="l00158"></a>00158     block.<a class="code" href="structBlock.html#02d734c9e46dccdd7f5652d19eef9e8e">yend</a>= block.<a class="code" href="structBlock.html#46861437cbb0debca2cc82b7beef2ff3">y0</a>+powers[rangeBlock.level];
<a name="l00159"></a>00159 
<a name="l00160"></a>00160     <span class="keywordflow">return</span> pool;
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="keyword">namespace </span>NOSPACE {
<a name="l00165"></a>00165     <span class="keyword">typedef</span> IStdEncPredictor::NewPredictorData StableInfo;
<a name="l00166"></a>00166 
<a name="l00168"></a>00168     <span class="keyword">struct </span>BestInfo: <span class="keyword">public</span> <a class="code" href="structIStdEncPredictor.html" title="Interface for domain-range mapping predictor generator for MStdEncoder.">IStdEncPredictor</a>::Prediction {
<a name="l00169"></a>00169         <span class="keywordtype">float</span> error;    
<a name="l00170"></a>00170         <span class="keywordtype">bool</span> inverted;  
<a name="l00171"></a>00171 <span class="preprocessor">        #ifndef NDEBUG</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span>        Real rdSum      
<a name="l00173"></a>00173         , dSum          
<a name="l00174"></a>00174         , d2Sum;        
<a name="l00175"></a>00175 <span class="preprocessor">        #endif</span>
<a name="l00176"></a>00176 <span class="preprocessor"></span>
<a name="l00178"></a>00178         BestInfo()
<a name="l00179"></a>00179         : Prediction(), error( numeric_limits&lt;float&gt;::infinity() ) {}
<a name="l00181"></a>00181         <a class="code" href="structIStdEncPredictor_1_1Prediction.html" title="Contains information about one predicted domain block.">IStdEncPredictor::Prediction</a>&amp; prediction() 
<a name="l00182"></a>00182             { <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00183"></a>00183     };
<a name="l00184"></a>00184 } <span class="comment">// namespace NOSPACE</span>
<a name="l00185"></a>00185 
<a name="l00187"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html">00187</a> <span class="keyword">struct </span><a class="code" href="structMStdEncoder_1_1EncodingInfo.html" title="Structure constructed for a range to try domains.">MStdEncoder::EncodingInfo</a> {
<a name="l00189"></a>00189     <span class="keyword">typedef</span> bool (<a class="code" href="structMStdEncoder_1_1EncodingInfo.html" title="Structure constructed for a range to try domains.">EncodingInfo</a>::*<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6f82b8076d8858b64d47e2cf2e5f1881" title="The type for exact-comparing methods.">ExactCompareProc</a>)( <a class="code" href="structIStdEncPredictor_1_1Prediction.html" title="Contains information about one predicted domain block.">Prediction</a> prediction );
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 <span class="keyword">private</span>:
<a name="l00192"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#e54bd8f3a182e69c3fc20c002ce2c56e">00192</a>     <span class="keyword">static</span> <span class="keyword">const</span> ExactCompareProc <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#e54bd8f3a182e69c3fc20c002ce2c56e" title="Possible comparing methods.">exactCompareArray</a>[];  
<a name="l00193"></a>00193 
<a name="l00194"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#71e5349273475d8d2a5b753b8fe66b86">00194</a>     ExactCompareProc <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#71e5349273475d8d2a5b753b8fe66b86" title="Selected comparing method.">selectedProc</a>;                      
<a name="l00195"></a>00195 <span class="keyword">public</span>:
<a name="l00196"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57">00196</a>     StableInfo <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>;  
<a name="l00197"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52">00197</a>     BestInfo <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>;      
<a name="l00198"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#0c5dbbff6dd1468959aa3b53dd1ab78b">00198</a>     <span class="keywordtype">float</span> <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#0c5dbbff6dd1468959aa3b53dd1ab78b" title="The target SE (square error) for the range.">targetSE</a>;     
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="keyword">public</span>:
<a name="l00202"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#9d6d9882ae0d50eadb0e9e9dff15ac52">00202</a>     <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#9d6d9882ae0d50eadb0e9e9dff15ac52" title="Only nulls selectedProc.">EncodingInfo</a>()
<a name="l00203"></a>00203     : <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#71e5349273475d8d2a5b753b8fe66b86" title="Selected comparing method.">selectedProc</a>(0) {}
<a name="l00204"></a>00204 
<a name="l00206"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#f849c2d15f119b3605325d74fe96068b">00206</a>     <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a>* <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#f849c2d15f119b3605325d74fe96068b" title="Initializes a RangeInfo object from this.">initRangeInfo</a>(<a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *ri)<span class="keyword"> const </span>{
<a name="l00207"></a>00207         ri-&gt;bestSE=     <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.error;
<a name="l00208"></a>00208         ri-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a>=   <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.domainID;
<a name="l00209"></a>00209         ri-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a>=   <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.rotation;
<a name="l00210"></a>00210         ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a6a5c218cfb9fadae4c745e5db94fe26" title="quant-rounded target average of the block">qrAvg</a>=      <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrAvg;
<a name="l00211"></a>00211         ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#44eebb074901de9604cf4f6808540467" title="quant-rounded target variance of the block">qrDev2</a>=     <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrDev2;
<a name="l00212"></a>00212         ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a71062f3d7719fd16d41bff1d1d4bf9c" title="indicates whether the linear coefficient is negative">inverted</a>=   <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.inverted;
<a name="l00213"></a>00213 <span class="preprocessor">        #ifndef NDEBUG</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>        ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#b7b65b75e7d532a3da0e8b73e825a253">exact</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#c2e2a5878905782b60d0e72e1ebc1632">avg</a>=  <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rSum/<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount;
<a name="l00215"></a>00215         ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#b7b65b75e7d532a3da0e8b73e825a253">exact</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#fde8fd56d97322cb03aac2c62f62b3aa">dev2</a>= <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.r2Sum/<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount - <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#b7b65b75e7d532a3da0e8b73e825a253">exact</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#c2e2a5878905782b60d0e72e1ebc1632">avg</a>);
<a name="l00216"></a>00216         ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#b7b65b75e7d532a3da0e8b73e825a253">exact</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#2d95744e92d934b0d66f28d8105ccaa0">linCoeff</a>= ( <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount*<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.rdSum - <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rSum*<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.dSum )
<a name="l00217"></a>00217         / ( <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount*<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.d2Sum - <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.dSum) );
<a name="l00218"></a>00218         ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#b7b65b75e7d532a3da0e8b73e825a253">exact</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#185060bcfc45ef90223bb85297ecac89">constCoeff</a>= ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#b7b65b75e7d532a3da0e8b73e825a253">exact</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#c2e2a5878905782b60d0e72e1ebc1632">avg</a> - ri-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#b7b65b75e7d532a3da0e8b73e825a253">exact</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#2d95744e92d934b0d66f28d8105ccaa0">linCoeff</a>*<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.dSum/<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount;
<a name="l00219"></a>00219 <span class="preprocessor">        #endif</span>
<a name="l00220"></a>00220 <span class="preprocessor"></span>        <span class="keywordflow">return</span> ri;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222 
<a name="l00224"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#9cebd814b256a54bf9e31335fcaa5f46">00224</a>     <span class="keywordtype">void</span> <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#9cebd814b256a54bf9e31335fcaa5f46" title="Selects the right comparing method according to stable.">selectExactCompareProc</a>() {
<a name="l00225"></a>00225         <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#71e5349273475d8d2a5b753b8fe66b86" title="Selected comparing method.">selectedProc</a>= <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#e54bd8f3a182e69c3fc20c002ce2c56e" title="Possible comparing methods.">exactCompareArray</a>
<a name="l00226"></a>00226         [(((  <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.quantError *2
<a name="l00227"></a>00227             + <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.allowInversion ) *2
<a name="l00228"></a>00228             + <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.isRegular ) *2
<a name="l00229"></a>00229             + (<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.maxLinCoeff2 &gt;= 0) ) *2
<a name="l00230"></a>00230             + (<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.bigScaleCoeff != 0)
<a name="l00231"></a>00231         ];
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233 
<a name="l00235"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#146b097ce87266259ffb35f9ef3e6a9e">00235</a>     <span class="keywordtype">bool</span> <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#146b097ce87266259ffb35f9ef3e6a9e" title="Uses the selected comparing method.">exactCompare</a>(<a class="code" href="structIStdEncPredictor_1_1Prediction.html" title="Contains information about one predicted domain block.">Prediction</a> prediction)
<a name="l00236"></a>00236         { <span class="keywordflow">return</span> (this-&gt;* <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#71e5349273475d8d2a5b753b8fe66b86" title="Selected comparing method.">selectedProc</a>)(prediction); }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238 <span class="keyword">private</span>:
<a name="l00240"></a>00240     <span class="keyword">template</span> &lt; <span class="keywordtype">bool</span> quantErrors, <span class="keywordtype">bool</span> allowInversion, <span class="keywordtype">bool</span> isRegular
<a name="l00241"></a>00241     , <span class="keywordtype">bool</span> restrictMaxLinCoeff, <span class="keywordtype">bool</span> bigScalePenalty &gt;
<a name="l00242"></a>00242     <span class="keywordtype">bool</span> <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#cb8f3c14543aa153d17681ca49dc12c4" title="Template for all the comparing methods.">exactCompareProc</a>( <a class="code" href="structIStdEncPredictor_1_1Prediction.html" title="Contains information about one predicted domain block.">Prediction</a> prediction );
<a name="l00243"></a>00243 }; <span class="comment">// EncodingInfo struct</span>
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="preprocessor">#define ALTERNATE_0(name,params...) name&lt;params&gt;</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span><span class="preprocessor">#define ALTERNATE_1(name,params...) ALTERNATE_0(name,##params,false), ALTERNATE_0(name,##params,true)</span>
<a name="l00247"></a>00247 <span class="preprocessor"></span><span class="preprocessor">#define ALTERNATE_2(name,params...) ALTERNATE_1(name,##params,false), ALTERNATE_1(name,##params,true)</span>
<a name="l00248"></a>00248 <span class="preprocessor"></span><span class="preprocessor">#define ALTERNATE_3(name,params...) ALTERNATE_2(name,##params,false), ALTERNATE_2(name,##params,true)</span>
<a name="l00249"></a>00249 <span class="preprocessor"></span><span class="preprocessor">#define ALTERNATE_4(name,params...) ALTERNATE_3(name,##params,false), ALTERNATE_3(name,##params,true)</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span><span class="preprocessor">#define ALTERNATE_5(name,params...) ALTERNATE_4(name,##params,false), ALTERNATE_4(name,##params,true)</span>
<a name="l00251"></a>00251 <span class="preprocessor"></span><span class="keyword">const</span> <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6f82b8076d8858b64d47e2cf2e5f1881" title="The type for exact-comparing methods.">MStdEncoder::EncodingInfo::ExactCompareProc</a> <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#e54bd8f3a182e69c3fc20c002ce2c56e" title="Possible comparing methods.">MStdEncoder::EncodingInfo::exactCompareArray</a>[]
<a name="l00252"></a>00252     = {ALTERNATE_5(&amp;<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#cb8f3c14543aa153d17681ca49dc12c4" title="Template for all the comparing methods.">MStdEncoder::EncodingInfo::exactCompareProc</a>)};
<a name="l00253"></a>00253 <span class="preprocessor">#undef ALTERNATE_0</span>
<a name="l00254"></a>00254 <span class="preprocessor"></span><span class="preprocessor">#undef ALTERNATE_1</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span><span class="preprocessor">#undef ALTERNATE_2</span>
<a name="l00256"></a>00256 <span class="preprocessor"></span><span class="preprocessor">#undef ALTERNATE_3</span>
<a name="l00257"></a>00257 <span class="preprocessor"></span><span class="preprocessor">#undef ALTERNATE_4</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span><span class="preprocessor">#undef ALTERNATE_5</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span>
<a name="l00260"></a>00260 <span class="keyword">template</span>&lt; <span class="keywordtype">bool</span> quantErrors, <span class="keywordtype">bool</span> allowInversion, <span class="keywordtype">bool</span> isRegular
<a name="l00261"></a>00261 , <span class="keywordtype">bool</span> restrictMaxLinCoeff, <span class="keywordtype">bool</span> bigScalePenalty &gt;
<a name="l00262"></a><a class="code" href="structMStdEncoder_1_1EncodingInfo.html#cb8f3c14543aa153d17681ca49dc12c4">00262</a> <span class="keywordtype">bool</span> <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#cb8f3c14543aa153d17681ca49dc12c4" title="Template for all the comparing methods.">MStdEncoder::EncodingInfo::exactCompareProc</a>( <a class="code" href="structIStdEncPredictor_1_1Prediction.html" title="Contains information about one predicted domain block.">Prediction</a> prediction ) {
<a name="l00263"></a>00263     <span class="keyword">using namespace </span>MatrixWalkers;
<a name="l00264"></a>00264 <span class="comment">//  find out which domain was predicted (pixel matrix and position within it)</span>
<a name="l00265"></a>00265     <a class="code" href="structBlock.html" title="A simple structure representing a rectangle.">Block</a> domBlock;
<a name="l00266"></a>00266     <span class="keyword">const</span> Pool &amp;pool= <a class="code" href="classMStdEncoder.html#3a5458e7264262d41b780f17dfa84fff" title="Considers a domain on a level number domIndex (in pools and poolInfos) and sets block...">getDomainData</a>( *<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rangeBlock, *<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pools, *<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.poolInfos
<a name="l00267"></a>00267     , prediction.<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a>, 0<span class="comment">/*zoom*/</span>, domBlock );
<a name="l00268"></a>00268 <span class="comment">//  compute domain sums</span>
<a name="l00269"></a>00269     <span class="keywordflow">if</span> (!isRegular)
<a name="l00270"></a>00270         domBlock= <a class="code" href="stdEncoder_8cpp.html#c7c7978ac80ab8a9e6d4cd8ac39a6ec1" title="Adjust block of a domain to be mapped equally on an incomplete range (depends on...">adjustDomainForIncompleteRange</a>
<a name="l00271"></a>00271             ( *<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rangeBlock, prediction.<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a>, domBlock );
<a name="l00272"></a>00272     Real dSum, d2Sum;
<a name="l00273"></a>00273     pool.getSums(domBlock).unpack(dSum,d2Sum);
<a name="l00274"></a>00274 <span class="comment">//  compute the denominator common to most formulas</span>
<a name="l00275"></a>00275     Real test= <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount*d2Sum - <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(dSum);
<a name="l00276"></a>00276     <span class="keywordflow">if</span> (test&lt;=0) <span class="comment">// skip too flat domains</span>
<a name="l00277"></a>00277         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00278"></a>00278     Real denom= 1/test;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="comment">//  compute the sum of products of pixels</span>
<a name="l00281"></a>00281     Real rdSum= walkOperateCheckRotate
<a name="l00282"></a>00282     ( Checked&lt;const SReal&gt;(<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rangePixels-&gt;pixels, *<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rangeBlock), RDSummer&lt;Real,SReal&gt;()
<a name="l00283"></a>00283     , pool.pixels, domBlock, prediction.<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a> ) .result();
<a name="l00284"></a>00284 
<a name="l00285"></a>00285     Real nRDs_RsDs= <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount*rdSum - <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rSum*dSum;
<a name="l00286"></a>00286 <span class="comment">//  check for negative linear coefficients (if needed)</span>
<a name="l00287"></a>00287     <span class="keywordflow">if</span> (!allowInversion)
<a name="l00288"></a>00288         <span class="keywordflow">if</span> (nRDs_RsDs&lt;0)
<a name="l00289"></a>00289             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00290"></a>00290 <span class="comment">//  compute the square of linear coefficient if needed (for restricting or penalty)</span>
<a name="l00291"></a>00291     Real linCoeff2 DEBUG_ONLY(= numeric_limits&lt;Real&gt;::quiet_NaN() );
<a name="l00292"></a>00292     <span class="keywordflow">if</span> ( restrictMaxLinCoeff || bigScalePenalty )
<a name="l00293"></a>00293         linCoeff2= <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rnDev2 * denom;
<a name="l00294"></a>00294     <span class="keywordflow">if</span> (restrictMaxLinCoeff)
<a name="l00295"></a>00295         <span class="keywordflow">if</span> ( linCoeff2 &gt; <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.maxLinCoeff2 )
<a name="l00296"></a>00296             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     <span class="keywordtype">float</span> optSE DEBUG_ONLY(= numeric_limits&lt;Real&gt;::quiet_NaN() );
<a name="l00299"></a>00299 
<a name="l00300"></a>00300     <span class="keywordflow">if</span> (quantErrors) {
<a name="l00301"></a>00301         optSE= <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrAvg * ( <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount*<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrAvg - ldexp(<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rSum,1) )
<a name="l00302"></a>00302             + <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.r2Sum + <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrDev
<a name="l00303"></a>00303                 * ( <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount*<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrDev - ldexp( abs(nRDs_RsDs)*sqrt(denom), 1 ) );
<a name="l00304"></a>00304     } <span class="keywordflow">else</span> { <span class="comment">// !quantErrors</span>
<a name="l00305"></a>00305     <span class="comment">//  assuming different linear coeffitient</span>
<a name="l00306"></a>00306         Real inner= <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rnDev2 - <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rnDev*abs(nRDs_RsDs)*sqrt(denom);
<a name="l00307"></a>00307         optSE= ldexp( inner, 1 ) / <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount;
<a name="l00308"></a>00308     }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="comment">//  add big-scaling penalty if needed</span>
<a name="l00311"></a>00311     <span class="keywordflow">if</span> (bigScalePenalty)
<a name="l00312"></a>00312         optSE+= linCoeff2 * <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#0c5dbbff6dd1468959aa3b53dd1ab78b" title="The target SE (square error) for the range.">targetSE</a> * pool.contrFactor * <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.bigScaleCoeff;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="comment">//  test if the error is the best so far</span>
<a name="l00315"></a>00315     <span class="keywordflow">if</span> ( optSE &lt; <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.error ) {
<a name="l00316"></a>00316         <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.prediction()= prediction;
<a name="l00317"></a>00317         <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.error= optSE;
<a name="l00318"></a>00318         <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.inverted= nRDs_RsDs&lt;0;
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <span class="preprocessor">        #ifndef NDEBUG</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span>        <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.rdSum= rdSum;
<a name="l00322"></a>00322         <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.dSum= dSum;
<a name="l00323"></a>00323         <a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.d2Sum= d2Sum;
<a name="l00324"></a>00324 <span class="preprocessor">        #endif</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span>        
<a name="l00326"></a>00326         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00327"></a>00327     } <span class="keywordflow">else</span>
<a name="l00328"></a>00328         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00329"></a>00329 } <span class="comment">// EncodingInfo::exactCompareProc method</span>
<a name="l00330"></a>00330 
<a name="l00331"></a>00331 
<a name="l00332"></a><a class="code" href="classMStdEncoder.html#8251de54872254fed99bfb29645a215c">00332</a> <span class="keywordtype">float</span> <a class="code" href="classMStdEncoder.html#8251de54872254fed99bfb29645a215c" title="Finds mapping with the best square error for a range (returns the SE), data neccessary...">MStdEncoder::findBestSE</a>(<span class="keyword">const</span> RangeNode &amp;range,<span class="keywordtype">bool</span> allowHigherSE) {
<a name="l00333"></a>00333     ASSERT( <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a> &amp;&amp; !<a class="code" href="classMStdEncoder.html#04d0c3363d57c2d7f51d9ad2b6d5ef1d" title="Caches the result of IQuality2SE::regularRangeErrors.">stdRangeSEs</a>.empty() &amp;&amp; !range.encoderData );
<a name="l00334"></a>00334     <span class="keyword">const</span> IColorTransformer::PlaneSettings *plSet= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;settings;
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 <span class="comment">//  initialize an encoding-info object</span>
<a name="l00337"></a>00337     <a class="code" href="structMStdEncoder_1_1EncodingInfo.html" title="Structure constructed for a range to try domains.">EncodingInfo</a> <a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rangeBlock=     &amp;range;
<a name="l00340"></a>00340     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rangePixels=    <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>;
<a name="l00341"></a>00341     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pools=          &amp;<a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;domains-&gt;getPools();
<a name="l00342"></a>00342 
<a name="l00343"></a>00343     ASSERT( range.level &lt; (<span class="keywordtype">int</span>)<a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>.size() );
<a name="l00344"></a>00344     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.poolInfos=      &amp;<a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>[range.level];
<a name="l00345"></a>00345 <span class="comment">//  check the level has been initialized</span>
<a name="l00346"></a>00346     <span class="keywordflow">if</span> ( info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.poolInfos-&gt;empty() ) {
<a name="l00347"></a>00347         <a class="code" href="classMStdEncoder.html#49ac4caa839239919fc0e26b2300bfa6" title="Builds levelPoolInfos[level], uses planeBlock-&amp;gt;domains.">buildPoolInfos4aLevel</a>(range.level);
<a name="l00348"></a>00348         ASSERT( !info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.poolInfos-&gt;empty() );
<a name="l00349"></a>00349     }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.allowRotations= <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedRotations);
<a name="l00352"></a>00352     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.quantError=     <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedQuantError);
<a name="l00353"></a>00353     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.allowInversion= <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedInversion);
<a name="l00354"></a>00354     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.isRegular=      range.isRegular();
<a name="l00355"></a>00355     {
<a name="l00356"></a>00356         Real coeff= settingsFloat(MaxLinCoeff);
<a name="l00357"></a>00357         info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.maxLinCoeff2=   coeff==MaxLinCoeff_none ? -1 : <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(coeff);
<a name="l00358"></a>00358     }
<a name="l00359"></a>00359     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.bigScaleCoeff=  settingsFloat(BigScaleCoeff);
<a name="l00360"></a>00360 
<a name="l00361"></a>00361     <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;getSums(range).unpack( info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rSum, info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.r2Sum );
<a name="l00362"></a>00362     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount=   range.size();
<a name="l00363"></a>00363     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rnDev2=     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount*info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.r2Sum - <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rSum);
<a name="l00364"></a>00364     <span class="keywordflow">if</span> (info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rnDev2&lt;0)
<a name="l00365"></a>00365         info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rnDev2= 0;
<a name="l00366"></a>00366     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rnDev=      sqrt(info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rnDev2);
<a name="l00367"></a>00367 
<a name="l00368"></a>00368     Real variance;
<a name="l00369"></a>00369     {
<a name="l00370"></a>00370         <a class="code" href="classQuantizer_1_1Average.html" title="(De)Quantizer for range-block averages, only initializes QuantBase correctly">Quantizer::Average</a> quantAvg( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_avg) );
<a name="l00371"></a>00371         <a class="code" href="classQuantizer_1_1Deviation.html" title="(De)Quantizer for range-block deviations, only initializes QuantBase correctly">Quantizer::Deviation</a> quantDev( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_dev) );
<a name="l00372"></a>00372         Real average= info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rSum / info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount;
<a name="l00373"></a>00373         info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrAvg= quantAvg.qRound(average);
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         variance= info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.r2Sum/info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount - <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(average);
<a name="l00376"></a>00376         Real deviance= variance&gt;0 ? sqrt(variance) : 0;
<a name="l00377"></a>00377         <span class="keywordtype">int</span> qrDev= quantDev.quant(deviance);
<a name="l00378"></a>00378     <span class="comment">//  if we have too little deviance or no domain pool for that big level or no domain in the pool</span>
<a name="l00379"></a>00379         <span class="keywordflow">if</span> ( !qrDev || range.level &gt;= (<span class="keywordtype">int</span>)<a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>.size()
<a name="l00380"></a>00380         || info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.poolInfos-&gt;back().indexBegin &lt;= 0 ) <span class="comment">// -&gt; no domain block, only average</span>
<a name="l00381"></a>00381             <span class="keywordflow">goto</span> returning; <span class="comment">// skips to the end, assigning a constant block</span>
<a name="l00382"></a>00382         <span class="keywordflow">else</span> { <span class="comment">// the regular case, with nonzero quantized deviance</span>
<a name="l00383"></a>00383             info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrDev= quantDev.dequant(qrDev);
<a name="l00384"></a>00384             info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrDev2= <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrDev);
<a name="l00385"></a>00385         }
<a name="l00386"></a>00386     }
<a name="l00387"></a>00387 
<a name="l00388"></a>00388     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#0c5dbbff6dd1468959aa3b53dd1ab78b" title="The target SE (square error) for the range.">targetSE</a>= info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.error= info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.isRegular ? <a class="code" href="classMStdEncoder.html#04d0c3363d57c2d7f51d9ad2b6d5ef1d" title="Caches the result of IQuality2SE::regularRangeErrors.">stdRangeSEs</a>[range.level]
<a name="l00389"></a>00389         : plSet-&gt;moduleQ2SE-&gt;rangeSE( plSet-&gt;quality, range.size() );
<a name="l00390"></a>00390     ASSERT(info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#0c5dbbff6dd1468959aa3b53dd1ab78b" title="The target SE (square error) for the range.">targetSE</a>&gt;=0);
<a name="l00391"></a>00391     <span class="keywordflow">if</span> (allowHigherSE)
<a name="l00392"></a>00392         info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.error= numeric_limits&lt;float&gt;::infinity();
<a name="l00393"></a>00393     info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#9cebd814b256a54bf9e31335fcaa5f46" title="Selects the right comparing method according to stable.">selectExactCompareProc</a>();
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     { <span class="comment">// a goto-skippable block</span>
<a name="l00396"></a>00396     <span class="comment">//  create and initialize a new predictor (in auto_ptr because of exceptions)</span>
<a name="l00397"></a>00397         auto_ptr&lt;IStdEncPredictor::IOneRangePredictor&gt; predictor
<a name="l00398"></a>00398             ( modulePredictor()-&gt;newPredictor(info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>) );
<a name="l00399"></a>00399         <span class="keyword">typedef</span> <a class="code" href="structIStdEncPredictor.html#e3c904170c2d2f4e1ae67d5f32a600d2" title="List of predictions (later often reffered to as a chunk).">IStdEncPredictor::Predictions</a> Predictions;
<a name="l00400"></a>00400         Predictions predicts;
<a name="l00401"></a>00401     
<a name="l00402"></a>00402         <span class="keywordtype">float</span> sufficientSE= info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#0c5dbbff6dd1468959aa3b53dd1ab78b" title="The target SE (square error) for the range.">targetSE</a>*settingsFloat(SufficientSEq);
<a name="l00403"></a>00403     <span class="comment">//  get and process prediction chunks until an empty one is returned</span>
<a name="l00404"></a>00404         <span class="keywordflow">while</span> ( !predictor-&gt;getChunk(info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.error,predicts).empty() )
<a name="l00405"></a>00405             <span class="keywordflow">for</span> (Predictions::iterator it=predicts.begin(); it!=predicts.end(); ++it) {
<a name="l00406"></a>00406                 <span class="keywordtype">bool</span> betterSE= info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#146b097ce87266259ffb35f9ef3e6a9e" title="Uses the selected comparing method.">exactCompare</a>(*it);
<a name="l00407"></a>00407                 <span class="keywordflow">if</span> ( betterSE &amp;&amp; info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.error&lt;=sufficientSE )
<a name="l00408"></a>00408                     <span class="keywordflow">goto</span> returning;
<a name="l00409"></a>00409             }
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411         
<a name="l00412"></a>00412     returning:
<a name="l00413"></a>00413 <span class="comment">//  check the case that the predictor didn't return any domains (or jumped to returning:)</span>
<a name="l00414"></a>00414     <span class="keywordflow">if</span> ( info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.domainID &lt; 0 ) { <span class="comment">// a constant block</span>
<a name="l00415"></a>00415         info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrDev= info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrDev2= 0;
<a name="l00416"></a>00416         info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.error= info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.quantError
<a name="l00417"></a>00417             ? info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.r2Sum + info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrAvg
<a name="l00418"></a>00418                 *( info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount*info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.qrAvg - ldexp(info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.rSum,1) )
<a name="l00419"></a>00419             : variance*info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#c22a602dab838f874eb6248e3c59ee57" title="Information only depending on the range (and not domain) block.">stable</a>.pixCount;
<a name="l00420"></a>00420     }
<a name="l00421"></a>00421 <span class="comment">//  store the important info and return the error</span>
<a name="l00422"></a>00422     range.encoderData= info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#f849c2d15f119b3605325d74fe96068b" title="Initializes a RangeInfo object from this.">initRangeInfo</a>( <span class="comment">/*rangeInfoAlloc.make()*/</span> <span class="keyword">new</span> <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> );
<a name="l00423"></a>00423     <span class="keywordflow">return</span> info.<a class="code" href="structMStdEncoder_1_1EncodingInfo.html#6da5e5eecfa8e771b3cdf340410e4c52" title="Information about the best (at the moment) mapping found.">best</a>.error;
<a name="l00424"></a>00424 } <span class="comment">// ::findBestSE method</span>
<a name="l00425"></a>00425 
<a name="l00426"></a><a class="code" href="classMStdEncoder.html#49ac4caa839239919fc0e26b2300bfa6">00426</a> <span class="keywordtype">void</span> <a class="code" href="classMStdEncoder.html#49ac4caa839239919fc0e26b2300bfa6" title="Builds levelPoolInfos[level], uses planeBlock-&amp;gt;domains.">MStdEncoder::buildPoolInfos4aLevel</a>(<span class="keywordtype">int</span> level) {
<a name="l00427"></a>00427 <span class="comment">//  get the real maximum domain count (divide by the number of rotations)</span>
<a name="l00428"></a>00428     <span class="keywordtype">int</span> domainCountLog2= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;settings-&gt;domainCountLog2;
<a name="l00429"></a>00429     <span class="keywordflow">if</span> ( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedRotations) )
<a name="l00430"></a>00430         domainCountLog2-= 3;
<a name="l00431"></a>00431 <span class="comment">//  get the per-domain-pool densities</span>
<a name="l00432"></a>00432     vector&lt;short&gt; densities= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;domains-&gt;getLevelDensities(level,domainCountLog2);
<a name="l00433"></a>00433 <span class="comment">//  storing the result in this-level infos with beginIndex values for all pools</span>
<a name="l00434"></a>00434     vector&lt;LevelPoolInfo&gt; &amp;poolInfos= <a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>[level];
<a name="l00435"></a>00435     ASSERT( poolInfos.empty() );
<a name="l00436"></a>00436     <span class="keyword">const</span> <a class="code" href="structISquareDomains.html#45c376d77fceab3d7b7db33d759976f2" title="List of pools.">ISquareDomains::PoolList</a> &amp;pools= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;domains-&gt;getPools();
<a name="l00437"></a>00437     <span class="keywordtype">int</span> zoom= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;settings-&gt;zoom;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439     <span class="keywordtype">int</span> domainSizeNZ= powers[level-zoom];
<a name="l00440"></a>00440     <span class="keywordtype">int</span> poolCount= pools.size();
<a name="l00441"></a>00441     poolInfos.resize(poolCount+1);
<a name="l00442"></a>00442 
<a name="l00443"></a>00443     <span class="keywordtype">int</span> domCount= poolInfos[0].indexBegin= 0; <span class="comment">// accumulated count</span>
<a name="l00444"></a>00444     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;poolCount; ++i) {
<a name="l00445"></a>00445         <span class="keywordtype">int</span> dens= poolInfos[i].density= densities[i];
<a name="l00446"></a>00446         ASSERT(dens&gt;=0);
<a name="l00447"></a>00447         <span class="keywordflow">if</span> (dens) <span class="comment">// if dens==0, there are no domains -&gt; no increase</span>
<a name="l00448"></a>00448             domCount+= <a class="code" href="util_8h.html#33e1f25518d96411f49cb2a6c1450471" title="The same as above, but in 2D for squares fitting into a rectangle.">getCountForDensity2D</a>( <a class="code" href="util_8h.html#f5d4f5e275aa85b08f39bccb0822aac7" title="Returns i/2^bits.">rShift</a>(pools[i].width,zoom)
<a name="l00449"></a>00449                 , <a class="code" href="util_8h.html#f5d4f5e275aa85b08f39bccb0822aac7" title="Returns i/2^bits.">rShift</a>(pools[i].height,zoom), dens, domainSizeNZ );
<a name="l00450"></a>00450         poolInfos[i+1].indexBegin= domCount;
<a name="l00451"></a>00451     }
<a name="l00452"></a>00452     poolInfos[poolCount].density= -1;
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a><a class="code" href="classMStdEncoder.html#9ec474c27550cb9c58159cba0a40c084">00455</a> <span class="keywordtype">void</span> <a class="code" href="classMStdEncoder.html#9ec474c27550cb9c58159cba0a40c084" title="Write all settings needed for reconstruction (don&amp;#39;t depend on encoded thing)...">MStdEncoder::writeSettings</a>(ostream &amp;file) {
<a name="l00456"></a>00456     ASSERT( <span class="comment">/*modulePredictor() &amp;&amp;*/</span> moduleCodec(<span class="keyword">true</span>) &amp;&amp; moduleCodec(<span class="keyword">false</span>) );
<a name="l00457"></a>00457 <span class="comment">//  put settings needed for decoding</span>
<a name="l00458"></a>00458     put&lt;Uchar&gt;( file, <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedRotations) );
<a name="l00459"></a>00459     put&lt;Uchar&gt;( file, <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedInversion) );
<a name="l00460"></a>00460     put&lt;Uchar&gt;( file, <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_avg) );
<a name="l00461"></a>00461     put&lt;Uchar&gt;( file, <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_dev) );
<a name="l00462"></a>00462 <span class="comment">//  put ID's of connected modules (the predictor module doesn't need to be known)</span>
<a name="l00463"></a>00463     <a class="code" href="classModule.html#96e114820c3a84d684d5e2d661a764af" title="Puts a module-identifier in a stream (which is the index in settings).">file_saveModuleType</a>( file, ModuleCodecAvg );
<a name="l00464"></a>00464     <a class="code" href="classModule.html#96e114820c3a84d684d5e2d661a764af" title="Puts a module-identifier in a stream (which is the index in settings).">file_saveModuleType</a>( file, ModuleCodecDev );
<a name="l00465"></a>00465 <span class="comment">//  put the settings of connected modules</span>
<a name="l00466"></a>00466     moduleCodec(<span class="keyword">true</span>)-&gt;<a class="code" href="structIIntCodec.html#553ddcd5e9a4a6edf5a4f09c9642ec88" title="Write all settings needed (doesn&amp;#39;t include possibilities set).">writeSettings</a>(file);
<a name="l00467"></a>00467     moduleCodec(<span class="keyword">false</span>)-&gt;<a class="code" href="structIIntCodec.html#553ddcd5e9a4a6edf5a4f09c9642ec88" title="Write all settings needed (doesn&amp;#39;t include possibilities set).">writeSettings</a>(file);
<a name="l00468"></a>00468 }
<a name="l00469"></a><a class="code" href="classMStdEncoder.html#ffa5e17525037f968ac3624071361520">00469</a> <span class="keywordtype">void</span> <a class="code" href="classMStdEncoder.html#ffa5e17525037f968ac3624071361520" title="Read all settings, opposite to writeSettings.">MStdEncoder::readSettings</a>(istream &amp;file) {
<a name="l00470"></a>00470     ASSERT( !modulePredictor() &amp;&amp; !moduleCodec(<span class="keyword">true</span>) &amp;&amp; !moduleCodec(<span class="keyword">false</span>) );
<a name="l00471"></a>00471 <span class="comment">//  get settings needed for decoding</span>
<a name="l00472"></a>00472     <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedRotations)= get&lt;Uchar&gt;(file);
<a name="l00473"></a>00473     <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedInversion)= get&lt;Uchar&gt;(file);
<a name="l00474"></a>00474     <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_avg)= get&lt;Uchar&gt;(file);
<a name="l00475"></a>00475     <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_dev)= get&lt;Uchar&gt;(file);
<a name="l00476"></a>00476 <span class="comment">//  create connected modules (the predictor module isn't needed)</span>
<a name="l00477"></a>00477     <a class="code" href="classModule.html#f398c50aa7db17f0ec2096a787141637" title="Gets an module-identifier from the stream, initializes the pointer in settings with...">file_loadModuleType</a>( file, ModuleCodecAvg );
<a name="l00478"></a>00478     <a class="code" href="classModule.html#f398c50aa7db17f0ec2096a787141637" title="Gets an module-identifier from the stream, initializes the pointer in settings with...">file_loadModuleType</a>( file, ModuleCodecDev );
<a name="l00479"></a>00479 <span class="comment">//  get the settings of connected modules</span>
<a name="l00480"></a>00480     moduleCodec(<span class="keyword">true</span>)-&gt;<a class="code" href="structIIntCodec.html#01c7039aef49705de20bf8b6a8fad0eb" title="Read all settings needed (doesn&amp;#39;t include possibilities set).">readSettings</a>(file);
<a name="l00481"></a>00481     moduleCodec(<span class="keyword">false</span>)-&gt;<a class="code" href="structIIntCodec.html#01c7039aef49705de20bf8b6a8fad0eb" title="Read all settings needed (doesn&amp;#39;t include possibilities set).">readSettings</a>(file);
<a name="l00482"></a>00482 }
<a name="l00483"></a>00483 
<a name="l00484"></a><a class="code" href="classMStdEncoder.html#b9c8afd7abd37a25eaab919ef1ce2b42">00484</a> <span class="keywordtype">void</span> <a class="code" href="classMStdEncoder.html#b9c8afd7abd37a25eaab919ef1ce2b42" title="Write one phase of data needed for reconstruction (excluding settings).">MStdEncoder::writeData</a>(ostream &amp;file,<span class="keywordtype">int</span> phase) {
<a name="l00485"></a>00485     <span class="keyword">typedef</span> RangeList::const_iterator RLcIterator;
<a name="l00486"></a>00486     ASSERT( moduleCodec(<span class="keyword">true</span>) &amp;&amp; moduleCodec(<span class="keyword">false</span>) );
<a name="l00487"></a>00487     ASSERT( <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a> &amp;&amp; <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;ranges &amp;&amp; <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;encoder==<span class="keyword">this</span> );
<a name="l00488"></a>00488     <span class="keyword">const</span> RangeList &amp;ranges= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;ranges-&gt;getRangeList();
<a name="l00489"></a>00489     ASSERT( !ranges.empty() );
<a name="l00490"></a>00490 
<a name="l00491"></a>00491     <span class="keywordflow">switch</span>(phase) {
<a name="l00492"></a>00492         <span class="keywordflow">case</span> 0: { <span class="comment">// save the averages</span>
<a name="l00493"></a>00493         <span class="comment">//  get the list</span>
<a name="l00494"></a>00494             vector&lt;int&gt; averages;
<a name="l00495"></a>00495             averages.reserve(ranges.size());
<a name="l00496"></a>00496             <a class="code" href="classQuantizer_1_1Average.html" title="(De)Quantizer for range-block averages, only initializes QuantBase correctly">Quantizer::Average</a> quant( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_avg) );
<a name="l00497"></a>00497             <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00498"></a>00498                 ASSERT( *it &amp;&amp; (*it)-&gt;encoderData );
<a name="l00499"></a>00499                 STREAM_POS(file);
<a name="l00500"></a>00500                 <span class="keyword">const</span> <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00501"></a>00501                 averages.push_back( quant.quant(info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a6a5c218cfb9fadae4c745e5db94fe26" title="quant-rounded target average of the block">qrAvg</a>) );
<a name="l00502"></a>00502             }
<a name="l00503"></a>00503         <span class="comment">//  pass it to the codec</span>
<a name="l00504"></a>00504             moduleCodec(<span class="keyword">true</span>)-&gt;<a class="code" href="structIIntCodec.html#2ea989f64e7ecd696c7c6076ea342f9d" title="Sets the number of possible symbols to work with from now on data: [0,possib-1].">setPossibilities</a>( powers[<a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_avg)] );
<a name="l00505"></a>00505             moduleCodec(<span class="keyword">true</span>)-&gt;<a class="code" href="structIIntCodec.html#ad47dc339c951aa6160deb95e0af0db0" title="Codes data and sends them into a stream.">encode</a>( averages, file );
<a name="l00506"></a>00506             <span class="keywordflow">break</span>;
<a name="l00507"></a>00507         }
<a name="l00508"></a>00508 
<a name="l00509"></a>00509         <span class="keywordflow">case</span> 1: { <span class="comment">// save the deviations</span>
<a name="l00510"></a>00510         <span class="comment">//  get the list</span>
<a name="l00511"></a>00511             vector&lt;int&gt; devs;
<a name="l00512"></a>00512             devs.reserve(ranges.size());
<a name="l00513"></a>00513             <a class="code" href="classQuantizer_1_1Deviation.html" title="(De)Quantizer for range-block deviations, only initializes QuantBase correctly">Quantizer::Deviation</a> quant( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_dev) );
<a name="l00514"></a>00514             <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00515"></a>00515                 ASSERT( *it &amp;&amp; (*it)-&gt;encoderData );
<a name="l00516"></a>00516                 STREAM_POS(file);
<a name="l00517"></a>00517                 <span class="keyword">const</span> <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00518"></a>00518                 <span class="keywordtype">int</span> dev= ( info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a>&gt;=0 ? quant.quant(sqrt(info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#44eebb074901de9604cf4f6808540467" title="quant-rounded target variance of the block">qrDev2</a>)) : 0 );
<a name="l00519"></a>00519                 devs.push_back(dev);
<a name="l00520"></a>00520             }
<a name="l00521"></a>00521         <span class="comment">//  pass it to the codec</span>
<a name="l00522"></a>00522             moduleCodec(<span class="keyword">false</span>)-&gt;<a class="code" href="structIIntCodec.html#2ea989f64e7ecd696c7c6076ea342f9d" title="Sets the number of possible symbols to work with from now on data: [0,possib-1].">setPossibilities</a>( powers[<a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_dev)] );
<a name="l00523"></a>00523             moduleCodec(<span class="keyword">false</span>)-&gt;<a class="code" href="structIIntCodec.html#ad47dc339c951aa6160deb95e0af0db0" title="Codes data and sends them into a stream.">encode</a>( devs, file );
<a name="l00524"></a>00524             <span class="keywordflow">break</span>;
<a name="l00525"></a>00525         }
<a name="l00526"></a>00526 
<a name="l00527"></a>00527         <span class="keywordflow">case</span> 2: { <span class="comment">// save the rest</span>
<a name="l00528"></a>00528             <a class="code" href="classBitWriter.html" title="Stream bit-writer - automated buffer for writing single bits.">BitWriter</a> stream(file);
<a name="l00529"></a>00529         <span class="comment">//  put the inversion bits if inversion is allowed</span>
<a name="l00530"></a>00530             <span class="keywordflow">if</span> ( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedInversion) )
<a name="l00531"></a>00531                 <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00532"></a>00532                     ASSERT( *it &amp;&amp; (*it)-&gt;encoderData );
<a name="l00533"></a>00533                     STREAM_POS(file);
<a name="l00534"></a>00534                     <span class="keyword">const</span> <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00535"></a>00535                     <span class="keywordflow">if</span> ( info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a> &gt;= 0 )
<a name="l00536"></a>00536                         stream.<a class="code" href="classBitWriter.html#708e0eddc068829a28f67572e50ef213" title="Puts bits.">putBits</a>(info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a71062f3d7719fd16d41bff1d1d4bf9c" title="indicates whether the linear coefficient is negative">inverted</a>,1);
<a name="l00537"></a>00537                 }
<a name="l00538"></a>00538         <span class="comment">//  put the rotation bits if rotations are allowed</span>
<a name="l00539"></a>00539             <span class="keywordflow">if</span> ( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedRotations) )
<a name="l00540"></a>00540                 <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00541"></a>00541                     ASSERT( *it &amp;&amp; (*it)-&gt;encoderData );
<a name="l00542"></a>00542                     STREAM_POS(file);
<a name="l00543"></a>00543                     <span class="keyword">const</span> <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00544"></a>00544                     <span class="keywordflow">if</span> ( info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a> &gt;= 0 ) {
<a name="l00545"></a>00545                         ASSERT( 0&lt;=info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a> &amp;&amp; info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a>&lt;8 );
<a name="l00546"></a>00546                         stream.<a class="code" href="classBitWriter.html#708e0eddc068829a28f67572e50ef213" title="Puts bits.">putBits</a>( info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a>, 3 );
<a name="l00547"></a>00547                     }
<a name="l00548"></a>00548                 }
<a name="l00549"></a>00549         <span class="comment">//  find out bits needed to store IDs of domains for every level</span>
<a name="l00550"></a>00550             vector&lt;int&gt; domBits;
<a name="l00551"></a>00551             domBits.resize( <a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>.size() );
<a name="l00552"></a>00552             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;(int)<a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>.size(); ++i) {
<a name="l00553"></a>00553                 <span class="keywordtype">int</span> count= <a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>[i].empty() ? 0 : <a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>[i].back().indexBegin;
<a name="l00554"></a>00554                 ASSERT(count&gt;=0);
<a name="l00555"></a>00555                 STREAM_POS(file);
<a name="l00556"></a>00556                 domBits[i]= count ? <a class="code" href="util_8h.html#97975b87cbe19485ff0af12d5972f54e" title="Returns ceil(log2(i)).">log2ceil</a>(count) : 0;
<a name="l00557"></a>00557             }
<a name="l00558"></a>00558         <span class="comment">//  put the domain bits</span>
<a name="l00559"></a>00559             <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00560"></a>00560                 ASSERT( *it &amp;&amp; (*it)-&gt;encoderData );
<a name="l00561"></a>00561                 STREAM_POS(file);
<a name="l00562"></a>00562                 <span class="keyword">const</span> <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00563"></a>00563                 <span class="keywordtype">int</span> domID= info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a>;
<a name="l00564"></a>00564                 <span class="keywordflow">if</span> ( domID &gt;= 0 ) {
<a name="l00565"></a>00565                     <span class="keywordtype">int</span> bits= domBits[ (*it)-&gt;level ];
<a name="l00566"></a>00566                     ASSERT( 0&lt;=domID &amp;&amp; domID&lt;powers[bits] );
<a name="l00567"></a>00567                     <span class="keywordflow">if</span> (bits&gt;0)
<a name="l00568"></a>00568                         stream.<a class="code" href="classBitWriter.html#708e0eddc068829a28f67572e50ef213" title="Puts bits.">putBits</a>( domID, bits );
<a name="l00569"></a>00569                 }
<a name="l00570"></a>00570             }
<a name="l00571"></a>00571             <span class="keywordflow">break</span>;
<a name="l00572"></a>00572         }
<a name="l00573"></a>00573         <span class="keywordflow">default</span>:
<a name="l00574"></a>00574             ASSERT(<span class="keyword">false</span>);
<a name="l00575"></a>00575     }
<a name="l00576"></a>00576 } <span class="comment">// ::writeData method</span>
<a name="l00577"></a><a class="code" href="classMStdEncoder.html#ccc7854aa0b42d1817d400a1dc46bf66">00577</a> <span class="keywordtype">void</span> <a class="code" href="classMStdEncoder.html#ccc7854aa0b42d1817d400a1dc46bf66" title="Reads one phase of data needed for recostruction, assumes the settings have been...">MStdEncoder::readData</a>(istream &amp;file,<span class="keywordtype">int</span> phase) {
<a name="l00578"></a>00578     <span class="keyword">typedef</span> RangeList::const_iterator RLcIterator;
<a name="l00579"></a>00579     ASSERT( moduleCodec(<span class="keyword">true</span>) &amp;&amp; moduleCodec(<span class="keyword">false</span>) );
<a name="l00580"></a>00580     ASSERT( <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a> &amp;&amp; <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;ranges &amp;&amp; <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;encoder==<span class="keyword">this</span> );
<a name="l00581"></a>00581     <span class="keyword">const</span> RangeList &amp;ranges= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;ranges-&gt;getRangeList();
<a name="l00582"></a>00582     ASSERT( !ranges.empty() );
<a name="l00583"></a>00583 
<a name="l00584"></a>00584     <span class="keywordflow">switch</span>(phase) {
<a name="l00585"></a>00585         <span class="keywordflow">case</span> 0: { <span class="comment">// create the infos and load the averages</span>
<a name="l00586"></a>00586         <span class="comment">//  get the list of averages from the codec</span>
<a name="l00587"></a>00587             vector&lt;int&gt; averages;
<a name="l00588"></a>00588             moduleCodec(<span class="keyword">true</span>)-&gt;<a class="code" href="structIIntCodec.html#2ea989f64e7ecd696c7c6076ea342f9d" title="Sets the number of possible symbols to work with from now on data: [0,possib-1].">setPossibilities</a>( powers[<a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_avg)] );
<a name="l00589"></a>00589             moduleCodec(<span class="keyword">true</span>)-&gt;<a class="code" href="structIIntCodec.html#7a77f07e4e9962626398771a78877440" title="Reads count symbols from file, decodes them and fills in data.">decode</a>( file, ranges.size(), averages );
<a name="l00590"></a>00590         <span class="comment">//  iterate the list, create infos and fill them with dequantized averages</span>
<a name="l00591"></a>00591             <a class="code" href="classQuantizer_1_1Average.html" title="(De)Quantizer for range-block averages, only initializes QuantBase correctly">Quantizer::Average</a> quant( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_avg) );
<a name="l00592"></a>00592             <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00593"></a>00593                 ASSERT( *it &amp;&amp; !(*it)-&gt;encoderData );
<a name="l00594"></a>00594                 STREAM_POS(file);
<a name="l00595"></a>00595                 <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <span class="keyword">new</span> <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a>;<span class="comment">//rangeInfoAlloc.make();</span>
<a name="l00596"></a>00596                 (*it)-&gt;encoderData= info;
<a name="l00597"></a>00597                 info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a6a5c218cfb9fadae4c745e5db94fe26" title="quant-rounded target average of the block">qrAvg</a>= quant.dequant(averages[it-ranges.begin()]);
<a name="l00598"></a>00598                 DEBUG_ONLY( info-&gt;bestSE= -1; ) <span class="comment">// SE not needed for decoding,saving,...</span>
<a name="l00599"></a>00599                 <span class="keywordflow">if</span> ( !<a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedInversion) )
<a name="l00600"></a>00600                     info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a71062f3d7719fd16d41bff1d1d4bf9c" title="indicates whether the linear coefficient is negative">inverted</a>= <span class="keyword">false</span>;
<a name="l00601"></a>00601             }
<a name="l00602"></a>00602             <span class="keywordflow">break</span>;
<a name="l00603"></a>00603         }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605         <span class="keywordflow">case</span> 1: { <span class="comment">// load the deviations</span>
<a name="l00606"></a>00606         <span class="comment">//  get the list of deviations from the codec</span>
<a name="l00607"></a>00607             vector&lt;int&gt; devs;
<a name="l00608"></a>00608             moduleCodec(<span class="keyword">false</span>)-&gt;<a class="code" href="structIIntCodec.html#2ea989f64e7ecd696c7c6076ea342f9d" title="Sets the number of possible symbols to work with from now on data: [0,possib-1].">setPossibilities</a>( powers[<a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_dev)] );
<a name="l00609"></a>00609             moduleCodec(<span class="keyword">false</span>)-&gt;<a class="code" href="structIIntCodec.html#7a77f07e4e9962626398771a78877440" title="Reads count symbols from file, decodes them and fills in data.">decode</a>( file, ranges.size(), devs );
<a name="l00610"></a>00610         <span class="comment">//  iterate the list, create infos and fill the with dequantized deviations</span>
<a name="l00611"></a>00611             <a class="code" href="classQuantizer_1_1Deviation.html" title="(De)Quantizer for range-block deviations, only initializes QuantBase correctly">Quantizer::Deviation</a> quant( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(QuantStepLog_dev) );
<a name="l00612"></a>00612             <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00613"></a>00613                 ASSERT( *it &amp;&amp; (*it)-&gt;encoderData );
<a name="l00614"></a>00614                 STREAM_POS(file);
<a name="l00615"></a>00615                 <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00616"></a>00616                 <span class="keywordtype">int</span> quantDev= devs[it-ranges.begin()];
<a name="l00617"></a>00617                 <span class="keywordflow">if</span> (quantDev)
<a name="l00618"></a>00618                     info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#44eebb074901de9604cf4f6808540467" title="quant-rounded target variance of the block">qrDev2</a>= <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(quant.dequant(quantDev));
<a name="l00619"></a>00619                 <span class="keywordflow">else</span> { <span class="comment">// it's a flat block</span>
<a name="l00620"></a>00620                     info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#44eebb074901de9604cf4f6808540467" title="quant-rounded target variance of the block">qrDev2</a>= 0;
<a name="l00621"></a>00621                     
<a name="l00622"></a>00622                     DEBUG_ONLY( info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a71062f3d7719fd16d41bff1d1d4bf9c" title="indicates whether the linear coefficient is negative">inverted</a>= <span class="keyword">false</span>; )
<a name="l00623"></a>00623                     ASSERT( info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a>==-1 &amp;&amp; info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a>==-1 );
<a name="l00624"></a>00624                 }
<a name="l00625"></a>00625             }
<a name="l00626"></a>00626             <span class="keywordflow">break</span>;
<a name="l00627"></a>00627         }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629         <span class="keywordflow">case</span> 2: { <span class="comment">// load the rest</span>
<a name="l00630"></a>00630             <a class="code" href="classBitReader.html" title="Stream bit-reader - automated buffer for reading single bits.">BitReader</a> stream(file);
<a name="l00631"></a>00631         <span class="comment">//  get the inversion bits if inversion is allowed</span>
<a name="l00632"></a>00632             <span class="keywordflow">if</span> ( <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedInversion) )
<a name="l00633"></a>00633                 <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00634"></a>00634                     ASSERT( *it &amp;&amp; (*it)-&gt;encoderData );
<a name="l00635"></a>00635                     STREAM_POS(file);
<a name="l00636"></a>00636                     <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00637"></a>00637                     <span class="keywordflow">if</span> (info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#44eebb074901de9604cf4f6808540467" title="quant-rounded target variance of the block">qrDev2</a>)
<a name="l00638"></a>00638                         info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a71062f3d7719fd16d41bff1d1d4bf9c" title="indicates whether the linear coefficient is negative">inverted</a>= stream.<a class="code" href="classBitReader.html#47cf76a8d28a76a0d8f8dc149afa1521" title="Reads bits.">getBits</a>(1);
<a name="l00639"></a>00639                 }
<a name="l00640"></a>00640         <span class="comment">//  get the rotation bits if rotations are allowed</span>
<a name="l00641"></a>00641             <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00642"></a>00642                 ASSERT( *it &amp;&amp; (*it)-&gt;encoderData );
<a name="l00643"></a>00643                 STREAM_POS(file);
<a name="l00644"></a>00644                 <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00645"></a>00645                 <span class="keywordflow">if</span> (info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#44eebb074901de9604cf4f6808540467" title="quant-rounded target variance of the block">qrDev2</a>)
<a name="l00646"></a>00646                     info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a>= <a class="code" href="classModule.html#359731fdb1af95f2190e1031e1332515" title="A shortcut method for working with integer settings.">settingsInt</a>(AllowedRotations) ? stream.<a class="code" href="classBitReader.html#47cf76a8d28a76a0d8f8dc149afa1521" title="Reads bits.">getBits</a>(3) : 0;
<a name="l00647"></a>00647             }
<a name="l00648"></a>00648         <span class="comment">//  find out bits needed to store IDs of domains for every level</span>
<a name="l00649"></a>00649             vector&lt;int&gt; domBits( <a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>.size(), -1 );
<a name="l00650"></a>00650         <span class="comment">//  get the domain bits</span>
<a name="l00651"></a>00651             <span class="keywordflow">for</span> (RLcIterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00652"></a>00652                 ASSERT( *it &amp;&amp; (*it)-&gt;encoderData );
<a name="l00653"></a>00653                 STREAM_POS(file);
<a name="l00654"></a>00654                 <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> *<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= <a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00655"></a>00655                 <span class="keywordflow">if</span> (!info-&gt;<a class="code" href="structMStdEncoder_1_1RangeInfo.html#44eebb074901de9604cf4f6808540467" title="quant-rounded target variance of the block">qrDev2</a>)
<a name="l00656"></a>00656                     <span class="keywordflow">continue</span>;
<a name="l00657"></a>00657                 <span class="keywordtype">int</span> level= (*it)-&gt;level;
<a name="l00658"></a>00658                 <span class="keywordtype">int</span> bits= domBits[level];
<a name="l00659"></a>00659                 <span class="keywordflow">if</span> (bits&lt;0) {
<a name="l00660"></a>00660                 <span class="comment">//  yet unused level -&gt; initialize it and get the right bits</span>
<a name="l00661"></a>00661                     <a class="code" href="classMStdEncoder.html#49ac4caa839239919fc0e26b2300bfa6" title="Builds levelPoolInfos[level], uses planeBlock-&amp;gt;domains.">buildPoolInfos4aLevel</a>(level);
<a name="l00662"></a>00662                     bits= domBits[level]
<a name="l00663"></a>00663                     = <a class="code" href="util_8h.html#97975b87cbe19485ff0af12d5972f54e" title="Returns ceil(log2(i)).">log2ceil</a>( <a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>[level].back().indexBegin );
<a name="l00664"></a>00664                     ASSERT( bits&gt;0 );
<a name="l00665"></a>00665                 }
<a name="l00666"></a>00666             <span class="comment">//  get the domain ID, check it's OK and store it in the range's info</span>
<a name="l00667"></a>00667                 <span class="keywordtype">int</span> domID= stream.<a class="code" href="classBitReader.html#47cf76a8d28a76a0d8f8dc149afa1521" title="Reads bits.">getBits</a>(bits);
<a name="l00668"></a>00668                 <a class="code" href="util_8h.html#ff10f244de23061a13ff884eaeac2d7d" title="Checking a condition - throws std::exception if false.">checkThrow</a>( domID &lt; <a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>[level].back().indexBegin );
<a name="l00669"></a>00669                 info-&gt;<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a>= domID;
<a name="l00670"></a>00670             }
<a name="l00671"></a>00671         <span class="comment">//  initialize decoding accelerators for domain-to-range mappings</span>
<a name="l00672"></a>00672             <a class="code" href="classMStdEncoder.html#c3c9ec39052452c730dcc666ab5dacff" title="Initializes decoding accelerators (in RangeInfo) for all range blocks.">initRangeInfoAccelerators</a>();
<a name="l00673"></a>00673             <span class="keywordflow">break</span>;
<a name="l00674"></a>00674         }
<a name="l00675"></a>00675         <span class="keywordflow">default</span>:
<a name="l00676"></a>00676             ASSERT(<span class="keyword">false</span>);
<a name="l00677"></a>00677     }
<a name="l00678"></a>00678 } <span class="comment">// ::readData method</span>
<a name="l00679"></a>00679 
<a name="l00680"></a><a class="code" href="classMStdEncoder.html#f51101a2f9aaea188435e4d116bdb982">00680</a> <span class="keywordtype">void</span> <a class="code" href="classMStdEncoder.html#f51101a2f9aaea188435e4d116bdb982" title="Performs a decoding action.">MStdEncoder::decodeAct</a>( DecodeAct action, <span class="keywordtype">int</span> count ) {
<a name="l00681"></a>00681 <span class="comment">//  do some checks</span>
<a name="l00682"></a>00682     ASSERT( <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a> &amp;&amp; <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;ranges &amp;&amp; <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;encoder==<span class="keyword">this</span> );
<a name="l00683"></a>00683     <span class="keyword">const</span> RangeList &amp;ranges= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;ranges-&gt;getRangeList();
<a name="l00684"></a>00684     ASSERT( !ranges.empty() );
<a name="l00685"></a>00685 
<a name="l00686"></a>00686     <span class="keywordflow">switch</span> (action) {
<a name="l00687"></a>00687     <span class="keywordflow">default</span>:
<a name="l00688"></a>00688         ASSERT(<span class="keyword">false</span>);
<a name="l00689"></a>00689     <span class="keywordflow">case</span> Clear:
<a name="l00690"></a>00690         ASSERT(count==1);
<a name="l00691"></a>00691         <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;pixels.fillSubMatrix
<a name="l00692"></a>00692             ( <a class="code" href="structBlock.html" title="A simple structure representing a rectangle.">Block</a>(0,0,<a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;width,<a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;height), 0.5f );
<a name="l00693"></a>00693         <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;summers_invalidate();
<a name="l00694"></a>00694         <span class="keywordflow">break</span>;
<a name="l00695"></a>00695     <span class="keywordflow">case</span> Iterate:
<a name="l00696"></a>00696         ASSERT(count&gt;0);
<a name="l00697"></a>00697         <span class="keywordflow">do</span> {
<a name="l00698"></a>00698         <span class="comment">//  prepare the domains, iterate each range block</span>
<a name="l00699"></a>00699             <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;domains-&gt;fillPixelsInPools(*<a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>);
<a name="l00700"></a>00700             <span class="keywordflow">for</span> (RangeList::const_iterator it=ranges.begin(); it!=ranges.end(); ++it) {
<a name="l00701"></a>00701                 <span class="keyword">const</span> <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> &amp;<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= *<a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00702"></a>00702                 <span class="keywordflow">if</span> ( info.<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a> &lt; 0 ) { <span class="comment">// no domain - constant color</span>
<a name="l00703"></a>00703                     <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;pixels.fillSubMatrix( **it, info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a6a5c218cfb9fadae4c745e5db94fe26" title="quant-rounded target average of the block">qrAvg</a> );
<a name="l00704"></a>00704                     <span class="keywordflow">continue</span>;
<a name="l00705"></a>00705                 }
<a name="l00706"></a>00706             <span class="comment">//  get domain sums and the pixel count</span>
<a name="l00707"></a>00707                 Real dSum, d2Sum;
<a name="l00708"></a>00708                 info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#de09927dbcf067ce8985ec021ff3691c" title="precomputed information about the domain (to accelerate)">decAccel</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#e34060e60522145df289cd0bb558d250" title="the pool of the domain">pool</a>-&gt;summers_makeValid();
<a name="l00709"></a>00709                 info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#de09927dbcf067ce8985ec021ff3691c" title="precomputed information about the domain (to accelerate)">decAccel</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#e34060e60522145df289cd0bb558d250" title="the pool of the domain">pool</a>-&gt;getSums(info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#de09927dbcf067ce8985ec021ff3691c" title="precomputed information about the domain (to accelerate)">decAccel</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#af0158e4f3726a146a3ea39d6af77b9b" title="domain block&amp;#39;s position and size in its pool">domBlock</a>).unpack(dSum,d2Sum);
<a name="l00710"></a>00710                 Real pixCount= (*it)-&gt;size();
<a name="l00711"></a>00711             <span class="comment">//  find out the coefficients and handle constant blocks</span>
<a name="l00712"></a>00712                 Real linCoeff= (info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a71062f3d7719fd16d41bff1d1d4bf9c" title="indicates whether the linear coefficient is negative">inverted</a> ? -pixCount : pixCount)
<a name="l00713"></a>00713                     * sqrt( info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#44eebb074901de9604cf4f6808540467" title="quant-rounded target variance of the block">qrDev2</a> / ( pixCount*d2Sum - <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(dSum) ) );
<a name="l00714"></a>00714                 <span class="keywordflow">if</span> ( !isnormal(linCoeff) || !linCoeff ) {
<a name="l00715"></a>00715                     <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;pixels.fillSubMatrix( **it, info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a6a5c218cfb9fadae4c745e5db94fe26" title="quant-rounded target average of the block">qrAvg</a> );
<a name="l00716"></a>00716                     <span class="keywordflow">continue</span>;
<a name="l00717"></a>00717                 }
<a name="l00718"></a>00718                 Real constCoeff= info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#a6a5c218cfb9fadae4c745e5db94fe26" title="quant-rounded target average of the block">qrAvg</a> - linCoeff*dSum/pixCount;
<a name="l00719"></a>00719             <span class="comment">//  map the nonconstant blocks</span>
<a name="l00720"></a>00720                 <span class="keyword">using namespace </span>MatrixWalkers;
<a name="l00721"></a>00721                 MulAddCopyChecked&lt;Real&gt; oper( linCoeff, constCoeff, 0, 1 );
<a name="l00722"></a>00722                 walkOperateCheckRotate( Checked&lt;SReal&gt;(<a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;pixels, **it), oper
<a name="l00723"></a>00723                 , info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#de09927dbcf067ce8985ec021ff3691c" title="precomputed information about the domain (to accelerate)">decAccel</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#e34060e60522145df289cd0bb558d250" title="the pool of the domain">pool</a>-&gt;pixels, info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#de09927dbcf067ce8985ec021ff3691c" title="precomputed information about the domain (to accelerate)">decAccel</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#af0158e4f3726a146a3ea39d6af77b9b" title="domain block&amp;#39;s position and size in its pool">domBlock</a>, info.<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a> );
<a name="l00724"></a>00724             }
<a name="l00725"></a>00725         } <span class="keywordflow">while</span> (--count);
<a name="l00726"></a>00726         <span class="keywordflow">break</span>;
<a name="l00727"></a>00727     } <span class="comment">// switch (action)</span>
<a name="l00728"></a>00728 } <span class="comment">// ::decodeAct method</span>
<a name="l00729"></a>00729 
<a name="l00730"></a><a class="code" href="classMStdEncoder.html#c3c9ec39052452c730dcc666ab5dacff">00730</a> <span class="keywordtype">void</span> <a class="code" href="classMStdEncoder.html#c3c9ec39052452c730dcc666ab5dacff" title="Initializes decoding accelerators (in RangeInfo) for all range blocks.">MStdEncoder::initRangeInfoAccelerators</a>() {
<a name="l00731"></a>00731 <span class="comment">//  get references that are the same for all range blocks</span>
<a name="l00732"></a>00732     <span class="keyword">const</span> RangeList &amp;ranges= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;ranges-&gt;getRangeList();
<a name="l00733"></a>00733     <span class="keyword">const</span> <a class="code" href="structISquareDomains.html#45c376d77fceab3d7b7db33d759976f2" title="List of pools.">ISquareDomains::PoolList</a> &amp;pools= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;domains-&gt;getPools();
<a name="l00734"></a>00734     <span class="keywordtype">int</span> zoom= <a class="code" href="classMStdEncoder.html#78fd4c985ea6742234c17b4b536011dc" title="Pointer to the block to encode/decode.">planeBlock</a>-&gt;settings-&gt;zoom;
<a name="l00735"></a>00735 <span class="comment">//  iterate over the ranges (and their accelerators)</span>
<a name="l00736"></a>00736     <span class="keywordflow">for</span> ( RangeList::const_iterator it=ranges.begin(); it!=ranges.end(); ++it ) {
<a name="l00737"></a>00737     <span class="comment">//  get range level, reference to the range's info and to the level's pool infos</span>
<a name="l00738"></a>00738         <span class="keywordtype">int</span> level= (*it)-&gt;level;
<a name="l00739"></a>00739         <a class="code" href="structMStdEncoder_1_1RangeInfo.html" title="Stores information about a range&amp;#39;s mapping, to be pointed by ISquareRanges::RangeNode...">RangeInfo</a> &amp;<a class="code" href="classModule.html#987b1cfc57aae292f5375fbb88a4fd32" title="Returns reference to module-type&amp;#39;s information, like count and types of settings...">info</a>= *<a class="code" href="structMStdEncoder_1_1RangeInfo.html#b6f157e8ccce3cc4a7c92e922f0adfa7" title="Extracts RangeNode::encoderData and down-casts it to RangeInfo.">RangeInfo::get</a>(*it);
<a name="l00740"></a>00740         <span class="keywordflow">if</span> ( info.<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a> &lt; 0 )
<a name="l00741"></a>00741             <span class="keywordflow">continue</span>;
<a name="l00742"></a>00742         <span class="keyword">const</span> PoolInfos &amp;poolInfos= <a class="code" href="classMStdEncoder.html#2914c2a27d49ecd4cca26e59e739026b" title="see LevelPoolInfos, only initialized for used levels">levelPoolInfos</a>[level];
<a name="l00743"></a>00743     <span class="comment">//  build pool infos for the level (if neccesary), fill info's accelerators</span>
<a name="l00744"></a>00744         <span class="keywordflow">if</span> ( poolInfos.empty() ) 
<a name="l00745"></a>00745             <a class="code" href="classMStdEncoder.html#49ac4caa839239919fc0e26b2300bfa6" title="Builds levelPoolInfos[level], uses planeBlock-&amp;gt;domains.">buildPoolInfos4aLevel</a>(level), ASSERT( !poolInfos.empty() );
<a name="l00746"></a>00746         info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#de09927dbcf067ce8985ec021ff3691c" title="precomputed information about the domain (to accelerate)">decAccel</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#e34060e60522145df289cd0bb558d250" title="the pool of the domain">pool</a>= &amp;<a class="code" href="classMStdEncoder.html#3a5458e7264262d41b780f17dfa84fff" title="Considers a domain on a level number domIndex (in pools and poolInfos) and sets block...">getDomainData</a>
<a name="l00747"></a>00747             ( **it, pools, poolInfos, info.<a class="code" href="structIStdEncPredictor_1_1Prediction.html#85fecb8a6a9701945af5c1ee7d7ca8cc" title="domain&amp;#39;s identification number">domainID</a>, zoom, info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#de09927dbcf067ce8985ec021ff3691c" title="precomputed information about the domain (to accelerate)">decAccel</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#af0158e4f3726a146a3ea39d6af77b9b" title="domain block&amp;#39;s position and size in its pool">domBlock</a> );
<a name="l00748"></a>00748     <span class="comment">//  adjust domain's block if the range isn't regular</span>
<a name="l00749"></a>00749         <span class="keywordflow">if</span> ( !(*it)-&gt;isRegular() )
<a name="l00750"></a>00750             info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#de09927dbcf067ce8985ec021ff3691c" title="precomputed information about the domain (to accelerate)">decAccel</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#af0158e4f3726a146a3ea39d6af77b9b" title="domain block&amp;#39;s position and size in its pool">domBlock</a>= <a class="code" href="stdEncoder_8cpp.html#c7c7978ac80ab8a9e6d4cd8ac39a6ec1" title="Adjust block of a domain to be mapped equally on an incomplete range (depends on...">adjustDomainForIncompleteRange</a>
<a name="l00751"></a>00751                 ( **it, info.<a class="code" href="structIStdEncPredictor_1_1Prediction.html#fbb5c94434514db2c20d4ad821f9e96f" title="the rotation of the domain">rotation</a>, info.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#de09927dbcf067ce8985ec021ff3691c" title="precomputed information about the domain (to accelerate)">decAccel</a>.<a class="code" href="structMStdEncoder_1_1RangeInfo.html#af0158e4f3726a146a3ea39d6af77b9b" title="domain block&amp;#39;s position and size in its pool">domBlock</a> );
<a name="l00752"></a>00752     }
<a name="l00753"></a>00753 }
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 6 22:33:14 2009 for Fractal Image Compressor by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
