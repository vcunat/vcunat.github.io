<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Fractal Image Compressor: kdTree.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>kdTree.h</h1><a href="kdTree_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef KDTREE_HEADER_</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define KDTREE_HEADER_</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#ifdef NDEBUG</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;cstring&gt;</span> <span class="comment">// memcpy</span>
<a name="l00006"></a>00006 <span class="preprocessor">#endif</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span>
<a name="l00014"></a>00014 <span class="keyword">namespace </span>NOSPACE {
<a name="l00015"></a>00015     <span class="keyword">using namespace </span>std;
<a name="l00016"></a>00016 }
<a name="l00017"></a>00017 
<a name="l00019"></a><a class="code" href="namespaceFieldMath.html">00019</a> <span class="keyword">namespace </span>FieldMath {
<a name="l00021"></a>00021     <span class="keyword">template</span>&lt;<span class="keyword">class</span> I1,<span class="keyword">class</span> I2,<span class="keyword">class</span> Transf&gt; <span class="keyword">inline</span>
<a name="l00022"></a><a class="code" href="namespaceFieldMath.html#0c43d84cae0936059f8c31ebd1090ffc">00022</a>     Transf <a class="code" href="namespaceFieldMath.html#0c43d84cae0936059f8c31ebd1090ffc" title="Calls transformer(x,y) for every x from [i1;iEnd1) and corresponding y from [i2;...">transform2</a>( I1 i1, I1 iEnd1, I2 i2, Transf transformer ) {
<a name="l00023"></a>00023         <span class="keywordflow">for</span> (; i1!=iEnd1; ++i1,++i2)
<a name="l00024"></a>00024             transformer(*i1,*i2);
<a name="l00025"></a>00025         <span class="keywordflow">return</span> transformer;
<a name="l00026"></a>00026     }
<a name="l00028"></a>00028     <span class="keyword">template</span>&lt;<span class="keyword">class</span> I1,<span class="keyword">class</span> I2,<span class="keyword">class</span> I3,<span class="keyword">class</span> Transf&gt; <span class="keyword">inline</span>
<a name="l00029"></a><a class="code" href="namespaceFieldMath.html#b39811ab5e97437fe40adc8006ee1f9d">00029</a>     Transf <a class="code" href="namespaceFieldMath.html#b39811ab5e97437fe40adc8006ee1f9d" title="Analogous to transform2.">transform3</a>( I1 i1, I1 iEnd1, I2 i2, I3 i3, Transf transformer ) {
<a name="l00030"></a>00030         <span class="keywordflow">for</span> (; i1!=iEnd1; ++i1,++i2,++i3)
<a name="l00031"></a>00031             transformer(*i1,*i2,*i3);
<a name="l00032"></a>00032         <span class="keywordflow">return</span> transformer;
<a name="l00033"></a>00033     }
<a name="l00034"></a>00034 
<a name="l00036"></a><a class="code" href="namespaceFieldMath.html#87fef7a11afc8c89d75842bb5349827a">00036</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> T* <a class="code" href="namespaceFieldMath.html#87fef7a11afc8c89d75842bb5349827a" title="Means b[i]=a[i]; Only meant for POD types.">assign</a>(<span class="keyword">const</span> T *a,<span class="keywordtype">int</span> length,T *b) {
<a name="l00037"></a>00037 <span class="preprocessor">    #ifndef NDEBUG</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>        copy( a, a+length, b );             <span class="comment">// debugging version uses STL's copy</span>
<a name="l00039"></a>00039 <span class="preprocessor">    #else</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>        memcpy( b, a, length*<span class="keyword">sizeof</span>(T) );   <span class="comment">// release version uses C's memory-copy (faster)</span>
<a name="l00041"></a>00041 <span class="preprocessor">    #endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>        <span class="keywordflow">return</span> b;
<a name="l00043"></a>00043     }
<a name="l00044"></a>00044 
<a name="l00045"></a>00045     <span class="keyword">namespace </span>NOSPACE {
<a name="l00047"></a><a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html">00047</a>         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keywordtype">bool</span> CheckNaNs&gt; <span class="keyword">struct </span><a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html" title="A helper transforming structure, only to be used in moveToBounds_copy.">MoveToBounds</a> {
<a name="l00048"></a><a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html#d8feb203e6d642cc1559c40adf172f5e">00048</a>             T <a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html#d8feb203e6d642cc1559c40adf172f5e" title="square error accumulated so far">sqrError</a>; 
<a name="l00049"></a>00049 
<a name="l00051"></a><a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html#c91b6e55cc624390e88bfe178c6f1c96">00051</a>             <a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html#c91b6e55cc624390e88bfe178c6f1c96" title="Only sets sqrError to zero.">MoveToBounds</a>()
<a name="l00052"></a>00052             : <a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html#d8feb203e6d642cc1559c40adf172f5e" title="square error accumulated so far">sqrError</a>(0) {}
<a name="l00053"></a>00053 
<a name="l00056"></a><a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html#3db1a1c464d784662fc4ba127bb71251">00056</a>             <span class="keywordtype">void</span> <a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html#3db1a1c464d784662fc4ba127bb71251" title="Moves one coordinate of a point (in point) to a bounding box (in bounds) accumulating...">operator()</a>(<span class="keyword">const</span> T &amp;point,<span class="keyword">const</span> T bounds[2],T &amp;result) {
<a name="l00057"></a>00057                 <span class="keywordflow">if</span> ( CheckNaNs &amp;&amp; <a class="code" href="util_8h.html#b4b5510f92a08dd12cc5b50a2746399b" title="A wrapper around isnan() because of compiler support.">isNaN</a>(point) )
<a name="l00058"></a>00058                     <span class="keywordflow">return</span>;
<a name="l00059"></a>00059                 <span class="keywordflow">if</span> ( point &lt; bounds[0] ) {
<a name="l00060"></a>00060                     <a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html#d8feb203e6d642cc1559c40adf172f5e" title="square error accumulated so far">sqrError</a>+= <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(bounds[0]-point);
<a name="l00061"></a>00061                     result= bounds[0];
<a name="l00062"></a>00062                 } <span class="keywordflow">else</span>
<a name="l00063"></a>00063                 <span class="keywordflow">if</span> ( point &gt; bounds[1] ) {
<a name="l00064"></a>00064                     <a class="code" href="structFieldMath_1_1NOSPACE_1_1MoveToBounds.html#d8feb203e6d642cc1559c40adf172f5e" title="square error accumulated so far">sqrError</a>+= <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(point-bounds[1]);
<a name="l00065"></a>00065                     result= bounds[1];
<a name="l00066"></a>00066                 } <span class="keywordflow">else</span>
<a name="l00067"></a>00067                     result= point;
<a name="l00068"></a>00068             }
<a name="l00069"></a>00069         };
<a name="l00070"></a>00070     }
<a name="l00073"></a>00073     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keywordtype">bool</span> CheckNaNs&gt; <span class="keyword">inline</span>
<a name="l00074"></a><a class="code" href="namespaceFieldMath.html#2801b0ea7442e411a62051c4b5438b87">00074</a>     T <a class="code" href="namespaceFieldMath.html#2801b0ea7442e411a62051c4b5438b87" title="Copy_moves a vector (point) to the nearest point (result) within bounds (bounds)...">moveToBounds_copy</a>(<span class="keyword">const</span> T *point,<span class="keyword">const</span> T (*bounds)[2],<span class="keywordtype">int</span> length,T *result) {
<a name="l00075"></a>00075         <span class="keywordflow">return</span> <a class="code" href="namespaceFieldMath.html#b39811ab5e97437fe40adc8006ee1f9d" title="Analogous to transform2.">transform3</a>( point, point+length, bounds, result
<a name="l00076"></a>00076             , MoveToBounds&lt;T,CheckNaNs&gt;() ) .sqrError;
<a name="l00077"></a>00077     }
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder</a>;
<a name="l00083"></a><a class="code" href="classKDTree.html">00083</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classKDTree.html" title="A generic static KD-tree.">KDTree</a> {
<a name="l00084"></a>00084 <span class="keyword">public</span>:
<a name="l00085"></a>00085     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder</a>&lt;T&gt;;
<a name="l00086"></a>00086     <span class="keyword">typedef</span> <a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder&lt;T&gt;</a> <a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">Builder</a>;
<a name="l00087"></a>00087 <span class="keyword">protected</span>:
<a name="l00089"></a><a class="code" href="structKDTree_1_1Node.html">00089</a>     <span class="keyword">struct </span><a class="code" href="structKDTree_1_1Node.html" title="Represents one node of the KD-tree.">Node</a> {
<a name="l00090"></a><a class="code" href="structKDTree_1_1Node.html#f8ef19e463c2986fd7bb7dcda1e5c39a">00090</a>         <span class="keywordtype">int</span> <a class="code" href="structKDTree_1_1Node.html#f8ef19e463c2986fd7bb7dcda1e5c39a" title="The coordinate along which the tree splits in this node.">coord</a>;  
<a name="l00091"></a><a class="code" href="structKDTree_1_1Node.html#64ecf824dd364a29a797cd9daacc624c">00091</a>         T <a class="code" href="structKDTree_1_1Node.html#64ecf824dd364a29a797cd9daacc624c" title="The threshold of the split (left[coord] &amp;lt;= threshold &amp;lt;= right[coord]).">threshold</a>;
<a name="l00093"></a>00093     };
<a name="l00094"></a>00094     <span class="keyword">typedef</span> T (*Bounds)[2];
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="keyword">public</span>:
<a name="l00097"></a>00097     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="classKDTree.html#8bf98992fabd73eb9b85f051f5b626e9" title="The depth of the tree = log2ceil(::count).">depth</a> 
<a name="l00098"></a><a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5">00098</a>     , <a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>        
<a name="l00099"></a>00099     , <a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a>;        
<a name="l00100"></a>00100 <span class="keyword">protected</span>:
<a name="l00101"></a><a class="code" href="classKDTree.html#304690838aecbf6fe4bf55af6f942dd6">00101</a>     Node *<a class="code" href="classKDTree.html#304690838aecbf6fe4bf55af6f942dd6" title="The array of the tree-nodes (heap-like topology of the tree).">nodes</a>;    
<a name="l00102"></a><a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2">00102</a>     <span class="keywordtype">int</span> *<a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>;   
<a name="l00103"></a><a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e">00103</a>     Bounds <a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>;  
<a name="l00104"></a>00104 
<a name="l00106"></a><a class="code" href="classKDTree.html#402fa47d7dbc1c0dedfa4ba0bdf0b0a5">00106</a>     <a class="code" href="classKDTree.html#402fa47d7dbc1c0dedfa4ba0bdf0b0a5" title="Prepares to build a new KD-tree from count_ vectors of length_ elements.">KDTree</a>(<span class="keywordtype">int</span> length_,<span class="keywordtype">int</span> count_)
<a name="l00107"></a>00107     : <a class="code" href="classKDTree.html#8bf98992fabd73eb9b85f051f5b626e9" title="The depth of the tree = log2ceil(::count).">depth</a>( <a class="code" href="util_8h.html#97975b87cbe19485ff0af12d5972f54e" title="Returns ceil(log2(i)).">log2ceil</a>(count_) ), <a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>(length_), <a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a>(count_)
<a name="l00108"></a>00108     , <a class="code" href="classKDTree.html#304690838aecbf6fe4bf55af6f942dd6" title="The array of the tree-nodes (heap-like topology of the tree).">nodes</a>( new Node[count_] ), <a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>( new int[count_] ), <a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>( new T[length_][2] ) {
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110 
<a name="l00112"></a><a class="code" href="classKDTree.html#391623f54098326a5935c9a8b42830dc">00112</a>     <a class="code" href="classKDTree.html#402fa47d7dbc1c0dedfa4ba0bdf0b0a5" title="Prepares to build a new KD-tree from count_ vectors of length_ elements.">KDTree</a>(<a class="code" href="classKDTree.html" title="A generic static KD-tree.">KDTree</a> &amp;other)
<a name="l00113"></a>00113     : <a class="code" href="classKDTree.html#8bf98992fabd73eb9b85f051f5b626e9" title="The depth of the tree = log2ceil(::count).">depth</a>(other.<a class="code" href="classKDTree.html#8bf98992fabd73eb9b85f051f5b626e9" title="The depth of the tree = log2ceil(::count).">depth</a>), <a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>(other.<a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>), <a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a>(other.<a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a>)
<a name="l00114"></a>00114     , <a class="code" href="classKDTree.html#304690838aecbf6fe4bf55af6f942dd6" title="The array of the tree-nodes (heap-like topology of the tree).">nodes</a>(other.<a class="code" href="classKDTree.html#304690838aecbf6fe4bf55af6f942dd6" title="The array of the tree-nodes (heap-like topology of the tree).">nodes</a>), <a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>(other.<a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>), <a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>(other.<a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>) {
<a name="l00115"></a>00115         other.<a class="code" href="classKDTree.html#304690838aecbf6fe4bf55af6f942dd6" title="The array of the tree-nodes (heap-like topology of the tree).">nodes</a>= 0;
<a name="l00116"></a>00116         other.<a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>= 0;
<a name="l00117"></a>00117         other.<a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>= 0;
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119     
<a name="l00122"></a><a class="code" href="classKDTree.html#71db9bc3d9486498cd3d8ef989b60332">00122</a>     <span class="keywordtype">int</span> <a class="code" href="classKDTree.html#71db9bc3d9486498cd3d8ef989b60332" title="Takes an index of a &amp;quot;leaf&amp;quot; node (past the end of nodes) and returns the...">leafID2dataID</a>(<span class="keywordtype">int</span> leafID)<span class="keyword"> const </span>{
<a name="l00123"></a>00123         ASSERT( <a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a>&lt;=leafID &amp;&amp; leafID&lt;2*<a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a> );
<a name="l00124"></a>00124         <span class="keywordtype">int</span> index= leafID-powers[<a class="code" href="classKDTree.html#8bf98992fabd73eb9b85f051f5b626e9" title="The depth of the tree = log2ceil(::count).">depth</a>];
<a name="l00125"></a>00125         <span class="keywordflow">if</span> (index&lt;0)
<a name="l00126"></a>00126             index+= <a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a>; <span class="comment">// it is on the shallower side of the tree</span>
<a name="l00127"></a>00127         ASSERT( 0&lt;=index &amp;&amp; index&lt;<a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a> );
<a name="l00128"></a>00128         <span class="keywordflow">return</span> <a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>[index];
<a name="l00129"></a>00129     }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="keyword">public</span>:
<a name="l00133"></a><a class="code" href="classKDTree.html#938adfcaafe0bfc1e1486d590f0ca66a">00133</a>     <a class="code" href="classKDTree.html#938adfcaafe0bfc1e1486d590f0ca66a" title="Only frees the memory.">~KDTree</a>() {
<a name="l00134"></a>00134     <span class="comment">//  clean up</span>
<a name="l00135"></a>00135         <span class="keyword">delete</span>[] <a class="code" href="classKDTree.html#304690838aecbf6fe4bf55af6f942dd6" title="The array of the tree-nodes (heap-like topology of the tree).">nodes</a>;
<a name="l00136"></a>00136         <span class="keyword">delete</span>[] <a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>;
<a name="l00137"></a>00137         <span class="keyword">delete</span>[] <a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>;
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 
<a name="l00144"></a><a class="code" href="classKDTree_1_1PointHeap.html">00144</a>     <span class="keyword">class </span><a class="code" href="classKDTree_1_1PointHeap.html" title="Performs a nearest-neighbour search by managing a heap from nodes of a KDTree.">PointHeap</a> {
<a name="l00146"></a><a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html">00146</a>         <span class="keyword">struct </span><a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html" title="One element of the heap representing a node in the KDTree kd.">HeapNode</a> {
<a name="l00147"></a><a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#74ade26789f1ecfc023eb01a1446b85e">00147</a>             <span class="keywordtype">int</span> <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#74ade26789f1ecfc023eb01a1446b85e" title="Index of the node in kd.">nodeIndex</a>;  
<a name="l00148"></a><a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#b19b2eb5981b1968786fa91f9021638f">00148</a>             T *<a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#b19b2eb5981b1968786fa91f9021638f" title="Stores the SE and the coordinates of the nearest point (to this node&amp;#39;s bounding...">data</a>;        
<a name="l00151"></a><a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#42cd3043bfacaf08d9cefbb0021bbd0f">00151</a>             <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#42cd3043bfacaf08d9cefbb0021bbd0f" title="No-init constructor.">HeapNode</a>() {}
<a name="l00153"></a><a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#57ee59208a9a42c176b0a25e162f6ec6">00153</a>             <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#57ee59208a9a42c176b0a25e162f6ec6" title="Initializes the members from the parameters.">HeapNode</a>(<span class="keywordtype">int</span> nodeIndex_,T *data_): <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#74ade26789f1ecfc023eb01a1446b85e" title="Index of the node in kd.">nodeIndex</a>(nodeIndex_), <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#b19b2eb5981b1968786fa91f9021638f" title="Stores the SE and the coordinates of the nearest point (to this node&amp;#39;s bounding...">data</a>(data_) {}
<a name="l00154"></a>00154 
<a name="l00156"></a><a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#72c6d7ffb97dcb1bea979885dd54cb04">00156</a>             T&amp; <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#72c6d7ffb97dcb1bea979885dd54cb04" title="Returns reference to the SE of the nearest point to this node&amp;#39;s bounding box...">getSE</a>()          { <span class="keywordflow">return</span> *<a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#b19b2eb5981b1968786fa91f9021638f" title="Stores the SE and the coordinates of the nearest point (to this node&amp;#39;s bounding...">data</a>; }
<a name="l00158"></a><a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#1e4076149fa27532e0a646bec1a7f095">00158</a>             T <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#1e4076149fa27532e0a646bec1a7f095" title="Returns the SE of the nearest point to this node&amp;#39;s bounding box.">getSE</a>()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> *<a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#b19b2eb5981b1968786fa91f9021638f" title="Stores the SE and the coordinates of the nearest point (to this node&amp;#39;s bounding...">data</a>; }
<a name="l00160"></a><a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#c42703da4f2675ab0dd616f9ba9394d5">00160</a>             T* <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#c42703da4f2675ab0dd616f9ba9394d5" title="Returns pointer to the nearest point to this node&amp;#39;s bounding box.">getNearest</a>()     { <span class="keywordflow">return</span> <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#b19b2eb5981b1968786fa91f9021638f" title="Stores the SE and the coordinates of the nearest point (to this node&amp;#39;s bounding...">data</a>+1; }
<a name="l00161"></a>00161         };
<a name="l00163"></a><a class="code" href="structKDTree_1_1PointHeap_1_1HeapOrder.html">00163</a>         <span class="keyword">struct </span><a class="code" href="structKDTree_1_1PointHeap_1_1HeapOrder.html" title="Defines the order of heap - ascending according to getSE.">HeapOrder</a> {
<a name="l00164"></a>00164             <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html" title="One element of the heap representing a node in the KDTree kd.">HeapNode</a> &amp;a,<span class="keyword">const</span> <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html" title="One element of the heap representing a node in the KDTree kd.">HeapNode</a> &amp;b)
<a name="l00165"></a>00165                 { <span class="keywordflow">return</span> a.<a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#72c6d7ffb97dcb1bea979885dd54cb04" title="Returns reference to the SE of the nearest point to this node&amp;#39;s bounding box...">getSE</a>() &gt; b.<a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#72c6d7ffb97dcb1bea979885dd54cb04" title="Returns reference to the SE of the nearest point to this node&amp;#39;s bounding box...">getSE</a>(); }
<a name="l00166"></a>00166         };
<a name="l00167"></a>00167 
<a name="l00168"></a><a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7">00168</a>         <span class="keyword">const</span> <a class="code" href="classKDTree.html" title="A generic static KD-tree.">KDTree</a> &amp;<a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>;           
<a name="l00169"></a><a class="code" href="classKDTree_1_1PointHeap.html#a51e5b3ae885fe054e620e8b62cb286d">00169</a>         <span class="keyword">const</span> T* <span class="keyword">const</span> <a class="code" href="classKDTree_1_1PointHeap.html#a51e5b3ae885fe054e620e8b62cb286d" title="Pointer to the point we are trying to approach.">point</a>;       
<a name="l00170"></a><a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e">00170</a>         vector&lt;HeapNode&gt; <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>;      
<a name="l00171"></a><a class="code" href="classKDTree_1_1PointHeap.html#2c08a95fefeedca5b3b1159694cfbc7d">00171</a>         BulkAllocator&lt;T&gt; <a class="code" href="classKDTree_1_1PointHeap.html#2c08a95fefeedca5b3b1159694cfbc7d" title="The allocator for HeapNode::data.">allocator</a>; 
<a name="l00172"></a>00172     <span class="keyword">public</span>:
<a name="l00175"></a><a class="code" href="classKDTree_1_1PointHeap.html#779cb6e2e82f558d676cc992cbba4024">00175</a>         <a class="code" href="classKDTree_1_1PointHeap.html#779cb6e2e82f558d676cc992cbba4024" title="Builds the heap from a KDTree tree and vector point_ (they&amp;#39;ve got to remain valid...">PointHeap</a>(<span class="keyword">const</span> <a class="code" href="classKDTree.html" title="A generic static KD-tree.">KDTree</a> &amp;tree,<span class="keyword">const</span> T *point_,<span class="keywordtype">bool</span> checkNaNs)
<a name="l00176"></a>00176         : <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>(tree), <a class="code" href="classKDTree_1_1PointHeap.html#a51e5b3ae885fe054e620e8b62cb286d" title="Pointer to the point we are trying to approach.">point</a>(point_) {
<a name="l00177"></a>00177             ASSERT(<a class="code" href="classKDTree_1_1PointHeap.html#a51e5b3ae885fe054e620e8b62cb286d" title="Pointer to the point we are trying to approach.">point</a>);
<a name="l00178"></a>00178         <span class="comment">//  create the root heap-node</span>
<a name="l00179"></a>00179             <a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html" title="One element of the heap representing a node in the KDTree kd.">HeapNode</a> rootNode( 1, <a class="code" href="classKDTree_1_1PointHeap.html#2c08a95fefeedca5b3b1159694cfbc7d" title="The allocator for HeapNode::data.">allocator</a>.makeField(<a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>+1) );
<a name="l00180"></a>00180         <span class="comment">//  compute the nearest point within the global bounds and corresponding SE</span>
<a name="l00181"></a>00181             <span class="keyword">using namespace </span>FieldMath;
<a name="l00182"></a>00182             rootNode.<a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#72c6d7ffb97dcb1bea979885dd54cb04" title="Returns reference to the SE of the nearest point to this node&amp;#39;s bounding box...">getSE</a>()= checkNaNs
<a name="l00183"></a>00183                 ? moveToBounds_copy&lt;T,true&gt; ( <a class="code" href="classKDTree_1_1PointHeap.html#a51e5b3ae885fe054e620e8b62cb286d" title="Pointer to the point we are trying to approach.">point</a>, <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>, <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>, rootNode.<a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#c42703da4f2675ab0dd616f9ba9394d5" title="Returns pointer to the nearest point to this node&amp;#39;s bounding box.">getNearest</a>() )
<a name="l00184"></a>00184                 : moveToBounds_copy&lt;T,false&gt;( point, <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>, <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>, rootNode.<a class="code" href="structKDTree_1_1PointHeap_1_1HeapNode.html#c42703da4f2675ab0dd616f9ba9394d5" title="Returns pointer to the nearest point to this node&amp;#39;s bounding box.">getNearest</a>() );
<a name="l00185"></a>00185         <span class="comment">//  push it onto the heap (and reserve more to speed up the first leaf-gettings)</span>
<a name="l00186"></a>00186             <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.reserve(<a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#8bf98992fabd73eb9b85f051f5b626e9" title="The depth of the tree = log2ceil(::count).">depth</a>*2);
<a name="l00187"></a>00187             <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.push_back(rootNode);
<a name="l00188"></a>00188         }
<a name="l00189"></a>00189 
<a name="l00191"></a><a class="code" href="classKDTree_1_1PointHeap.html#8ca1b5fdfefcd6a14d0cc198d26fe781">00191</a>         <span class="keywordtype">bool</span> <a class="code" href="classKDTree_1_1PointHeap.html#8ca1b5fdfefcd6a14d0cc198d26fe781" title="Returns whether the heap is empty ( !isEmpty() is needed for all other methods).">isEmpty</a>()
<a name="l00192"></a>00192             { <span class="keywordflow">return</span> <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.empty(); }
<a name="l00193"></a>00193 
<a name="l00195"></a><a class="code" href="classKDTree_1_1PointHeap.html#5844f5ca3bedef5690b0e7fb53397532">00195</a>         T <a class="code" href="classKDTree_1_1PointHeap.html#5844f5ca3bedef5690b0e7fb53397532" title="Returns the SE of the top node (always equals the SE of the next leaf).">getTopSE</a>() {
<a name="l00196"></a>00196             ASSERT( !<a class="code" href="classKDTree_1_1PointHeap.html#8ca1b5fdfefcd6a14d0cc198d26fe781" title="Returns whether the heap is empty ( !isEmpty() is needed for all other methods).">isEmpty</a>() );
<a name="l00197"></a>00197             <span class="keywordflow">return</span> <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>[0].getSE();
<a name="l00198"></a>00198         }
<a name="l00199"></a>00199 
<a name="l00202"></a><a class="code" href="classKDTree_1_1PointHeap.html#a8c293a21745885cf65427ff2fcc2e3b">00202</a>         <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> CheckNaNs&gt; <span class="keywordtype">int</span> <a class="code" href="classKDTree_1_1PointHeap.html#a8c293a21745885cf65427ff2fcc2e3b" title="Removes a leaf, returns the matching vector&amp;#39;s index, assumes it&amp;#39;s safe to...">popLeaf</a>(T maxSE) {
<a name="l00203"></a>00203         <span class="comment">//  ensure a leaf is on the top of the heap and get its ID</span>
<a name="l00204"></a>00204             makeTopLeaf&lt;CheckNaNs&gt;(maxSE);
<a name="l00205"></a>00205             <span class="keywordtype">int</span> result= <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#71db9bc3d9486498cd3d8ef989b60332" title="Takes an index of a &amp;quot;leaf&amp;quot; node (past the end of nodes) and returns the...">leafID2dataID</a>( <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.front().nodeIndex );
<a name="l00206"></a>00206         <span class="comment">//  remove the top from the heap (no need to free the memory - ::allocator)</span>
<a name="l00207"></a>00207             pop_heap( <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.begin(), <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.end(), <a class="code" href="structKDTree_1_1PointHeap_1_1HeapOrder.html" title="Defines the order of heap - ascending according to getSE.">HeapOrder</a>() );
<a name="l00208"></a>00208             <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.pop_back();
<a name="l00209"></a>00209             <span class="keywordflow">return</span> result;
<a name="l00210"></a>00210         }
<a name="l00211"></a>00211     <span class="keyword">protected</span>:
<a name="l00214"></a>00214         <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> CheckNaNs&gt; <span class="keywordtype">void</span> <a class="code" href="classKDTree_1_1PointHeap.html#6277ab5984c3ef4abbac5023fc173224" title="Divides the top nodes until there&amp;#39;s a leaf on the top assumes it&amp;#39;s safe to...">makeTopLeaf</a>(T maxSE);
<a name="l00215"></a>00215 
<a name="l00216"></a>00216     }; <span class="comment">// PointHeap class</span>
<a name="l00217"></a>00217 }; <span class="comment">// KDTree class</span>
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 
<a name="l00220"></a>00220 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> CheckNaNs&gt;
<a name="l00221"></a>00221 <span class="keywordtype">void</span> <a class="code" href="classKDTree_1_1PointHeap.html#6277ab5984c3ef4abbac5023fc173224" title="Divides the top nodes until there&amp;#39;s a leaf on the top assumes it&amp;#39;s safe to...">KDTree&lt;T&gt;::PointHeap::makeTopLeaf</a>(T maxSE) {
<a name="l00222"></a>00222     ASSERT( !<a class="code" href="classKDTree_1_1PointHeap.html#8ca1b5fdfefcd6a14d0cc198d26fe781" title="Returns whether the heap is empty ( !isEmpty() is needed for all other methods).">isEmpty</a>() );
<a name="l00223"></a>00223 <span class="comment">//  exit if there's a leaf on the top already</span>
<a name="l00224"></a>00224     <span class="keywordflow">if</span> ( <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>[0].nodeIndex &gt;= <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a> )
<a name="l00225"></a>00225         <span class="keywordflow">return</span>;
<a name="l00226"></a>00226     PtrInt oldHeapSize= <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.size();
<a name="l00227"></a>00227     HeapNode heapRoot= <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>[0]; <span class="comment">// making a local working copy of the top of the heap</span>
<a name="l00228"></a>00228 
<a name="l00229"></a>00229     <span class="keywordflow">do</span> { <span class="comment">// while heapRoot isn't leaf ... while ( heapRoot.nodeIndex&lt;kd.count )</span>
<a name="l00230"></a>00230         <span class="keyword">const</span> Node &amp;node= <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#304690838aecbf6fe4bf55af6f942dd6" title="The array of the tree-nodes (heap-like topology of the tree).">nodes</a>[heapRoot.nodeIndex];
<a name="l00231"></a>00231     <span class="comment">//  now replace the node with its two children:</span>
<a name="l00232"></a>00232     <span class="comment">//      one of them will have the same SE (replaces its parent on the top),</span>
<a name="l00233"></a>00233     <span class="comment">//      the other one can have higher SE (push_back-ed on the heap)</span>
<a name="l00234"></a>00234 
<a name="l00235"></a>00235         <span class="keywordtype">bool</span> validCoord= !CheckNaNs || !<a class="code" href="util_8h.html#b4b5510f92a08dd12cc5b50a2746399b" title="A wrapper around isnan() because of compiler support.">isNaN</a>(<a class="code" href="classKDTree_1_1PointHeap.html#a51e5b3ae885fe054e620e8b62cb286d" title="Pointer to the point we are trying to approach.">point</a>[node.coord]);
<a name="l00236"></a>00236     <span class="comment">//  the higher SE can be computed from the parent heap-node</span>
<a name="l00237"></a>00237         T newSE;
<a name="l00238"></a>00238         <span class="keywordtype">bool</span> goRight; <span class="comment">// will the heapRoot represent the right child or the left one?</span>
<a name="l00239"></a>00239         <span class="keywordflow">if</span> (validCoord) {
<a name="l00240"></a>00240             <a class="code" href="namespaceMTypes.html#794a900a7af0af1cedefda7db5cd0c43" title="The floating-point type in which most computations are made.">Real</a> oldDiff= <a class="code" href="namespaceMTypes.html#794a900a7af0af1cedefda7db5cd0c43" title="The floating-point type in which most computations are made.">Real</a>(<a class="code" href="classKDTree_1_1PointHeap.html#a51e5b3ae885fe054e620e8b62cb286d" title="Pointer to the point we are trying to approach.">point</a>[node.coord]) - heapRoot.getNearest()[node.coord];
<a name="l00241"></a>00241             <a class="code" href="namespaceMTypes.html#794a900a7af0af1cedefda7db5cd0c43" title="The floating-point type in which most computations are made.">Real</a> newDiff= <a class="code" href="namespaceMTypes.html#794a900a7af0af1cedefda7db5cd0c43" title="The floating-point type in which most computations are made.">Real</a>(<a class="code" href="classKDTree_1_1PointHeap.html#a51e5b3ae885fe054e620e8b62cb286d" title="Pointer to the point we are trying to approach.">point</a>[node.coord]) - node.threshold;
<a name="l00242"></a>00242             goRight= newDiff&gt;0;
<a name="l00243"></a>00243             newSE= heapRoot.getSE() - <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(oldDiff) + <a class="code" href="util_8h.html#c768d5f9cea71e68e404f4b2455462a6" title="Helper template function computing the square of a number.">sqr</a>(newDiff);
<a name="l00244"></a>00244             ASSERT( newSE &gt;= heapRoot.getSE() );
<a name="l00245"></a>00245         } <span class="keywordflow">else</span> {
<a name="l00246"></a>00246             newSE= heapRoot.getSE();
<a name="l00247"></a>00247             goRight= <span class="keyword">false</span>; <span class="comment">// both boolean values are possible </span>
<a name="l00248"></a>00248         }
<a name="l00249"></a>00249     <span class="comment">//  the root will represent its closer child - neither nearest point nor SE changes</span>
<a name="l00250"></a>00250         heapRoot.nodeIndex= heapRoot.nodeIndex*2 + goRight;
<a name="l00251"></a>00251     <span class="comment">//  if the new SE is too high, continue (omit the child with this big SE)</span>
<a name="l00252"></a>00252         <span class="keywordflow">if</span> (newSE&gt;maxSE)    
<a name="l00253"></a>00253             <span class="keywordflow">continue</span>;
<a name="l00254"></a>00254     <span class="comment">//  create a new heap-node, allocate it's data and assign index of the other child</span>
<a name="l00255"></a>00255         HeapNode newHNode;
<a name="l00256"></a>00256         newHNode.data= <a class="code" href="classKDTree_1_1PointHeap.html#2c08a95fefeedca5b3b1159694cfbc7d" title="The allocator for HeapNode::data.">allocator</a>.makeField(<a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>+1);
<a name="l00257"></a>00257         newHNode.getSE()= newSE;    
<a name="l00258"></a>00258         newHNode.nodeIndex= heapRoot.nodeIndex-goRight+!goRight;
<a name="l00259"></a>00259     <span class="comment">//  the nearest point of the new heap-node only differs in one coordinate</span>
<a name="l00260"></a>00260         <a class="code" href="namespaceFieldMath.html#87fef7a11afc8c89d75842bb5349827a" title="Means b[i]=a[i]; Only meant for POD types.">FieldMath::assign</a>( heapRoot.getNearest(), <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>, newHNode.getNearest() );
<a name="l00261"></a>00261         <span class="keywordflow">if</span> (validCoord)
<a name="l00262"></a>00262             newHNode.getNearest()[node.coord]= node.threshold;
<a name="l00263"></a>00263     <span class="comment">//  add the new node to the back, restore the heap-property later</span>
<a name="l00264"></a>00264         <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.push_back(newHNode);
<a name="l00265"></a>00265         
<a name="l00266"></a>00266     } <span class="keywordflow">while</span> ( heapRoot.nodeIndex &lt; <a class="code" href="classKDTree_1_1PointHeap.html#c4ee0a0ca4cef7ab7069bad3b90e32c7" title="Reference to the KDTree we operate on.">kd</a>.<a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a> );
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>[0]= heapRoot; <span class="comment">// restoring the working copy of the heap's top node</span>
<a name="l00269"></a>00269 <span class="comment">//  restore the heap-property on the added nodes</span>
<a name="l00270"></a>00270     <span class="keyword">typename</span> vector&lt;HeapNode&gt;::iterator it= <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.begin()+oldHeapSize;
<a name="l00271"></a>00271     <span class="keywordflow">do</span>
<a name="l00272"></a>00272         push_heap( <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.begin(), it, HeapOrder() );
<a name="l00273"></a>00273     <span class="keywordflow">while</span> ( it++ != <a class="code" href="classKDTree_1_1PointHeap.html#6acdf477b72187f24ab311a106bf4c4e" title="The current heap of the tree nodes.">heap</a>.end() );
<a name="l00274"></a>00274 } <span class="comment">// KDTree&lt;T&gt;::PointHeap::makeTopLeaf&lt;CheckNaNs&gt;() method</span>
<a name="l00275"></a>00275 
<a name="l00277"></a><a class="code" href="classKDBuilder.html">00277</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder</a>: <span class="keyword">public</span> <a class="code" href="classKDTree.html" title="A generic static KD-tree.">KDTree</a>&lt;T&gt; {
<a name="l00278"></a>00278 <span class="keyword">public</span>:
<a name="l00279"></a>00279     <span class="keyword">typedef</span> <a class="code" href="classKDTree.html">KDTree&lt;T&gt;</a> <a class="code" href="classKDTree.html">Tree</a>;
<a name="l00280"></a>00280     <span class="keyword">typedef</span> T BoundsPair[2];
<a name="l00281"></a>00281     <span class="keyword">typedef</span> <span class="keyword">typename</span> Tree::Bounds Bounds;
<a name="l00283"></a>00283     <span class="keyword">typedef</span> int (<a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder</a>::*CoordChooser)
<a name="l00284"></a>00284         (<span class="keywordtype">int</span> nodeIndex,<span class="keywordtype">int</span> *beginIDs,<span class="keywordtype">int</span> *endIDs,<span class="keywordtype">int</span> depthLeft) <span class="keyword">const</span>;
<a name="l00285"></a>00285 <span class="keyword">protected</span>:
<a name="l00286"></a>00286     <span class="keyword">using</span> Tree::depth;  <span class="keyword">using</span> Tree::length;     <span class="keyword">using</span> Tree::count;
<a name="l00287"></a>00287     <span class="keyword">using</span> Tree::nodes;  <span class="keyword">using</span> Tree::dataIDs;    <span class="keyword">using</span> Tree::bounds;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     <span class="keyword">const</span> T *data;
<a name="l00290"></a>00290     <span class="keyword">const</span> CoordChooser chooser;
<a name="l00291"></a>00291     <span class="keyword">mutable</span> Bounds chooserTmp;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     <a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder</a>(<span class="keyword">const</span> T *data_,<span class="keywordtype">int</span> <a class="code" href="classKDTree.html#0c16a23d7d95c26d5211fd37ede739f5" title="The length of the vectors.">length</a>,<span class="keywordtype">int</span> <a class="code" href="classKDTree.html#775f89e789100d5285065e625765fb84" title="The number of the vectors.">count</a>,CoordChooser chooser_)
<a name="l00294"></a>00294     : <a class="code" href="classKDTree.html">Tree</a>(length,count), data(data_), chooser(chooser_), chooserTmp(0) {
<a name="l00295"></a>00295         ASSERT( length&gt;0 &amp;&amp; count&gt;0 &amp;&amp; chooser &amp;&amp; data );
<a name="l00296"></a>00296     <span class="comment">//  create the index-vector, coumpute the bounding box, build the tree</span>
<a name="l00297"></a>00297         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;count; ++i)
<a name="l00298"></a>00298             <a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>[i]= i;
<a name="l00299"></a>00299         getBounds(<a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>);
<a name="l00300"></a>00300         <span class="keywordflow">if</span> (count&gt;1)
<a name="l00301"></a>00301             buildNode(1,<a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>,<a class="code" href="classKDTree.html#9f6747b745ea21a5459d2c14dc00c3b2" title="Data IDs for children of &amp;quot;leaf&amp;quot; nodes.">dataIDs</a>+count,<a class="code" href="classKDTree.html#8bf98992fabd73eb9b85f051f5b626e9" title="The depth of the tree = log2ceil(::count).">depth</a>);
<a name="l00302"></a>00302         <span class="keyword">delete</span>[] chooserTmp;
<a name="l00303"></a>00303         DEBUG_ONLY( chooserTmp= 0; data= 0; )
<a name="l00304"></a>00304     }
<a name="l00305"></a>00305 
<a name="l00307"></a><a class="code" href="structKDBuilder_1_1NewBounds.html">00307</a>     <span class="keyword">struct</span> <a class="code" href="structKDBuilder_1_1NewBounds.html" title="Creates bounds containing one value.">NewBounds</a> {
<a name="l00308"></a>00308         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> T &amp;val,BoundsPair &amp;<a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>)<span class="keyword"> const</span>
<a name="l00309"></a>00309 <span class="keyword">            </span>{ bounds[0]= bounds[1]= val; }
<a name="l00310"></a>00310     };
<a name="l00312"></a><a class="code" href="structKDBuilder_1_1BoundsExpander.html">00312</a>     <span class="keyword">struct </span><a class="code" href="structKDBuilder_1_1BoundsExpander.html" title="Expands a valid bounding box to contain a point (one coordinate at once).">BoundsExpander</a> {
<a name="l00313"></a>00313         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> T &amp;val,BoundsPair &amp;<a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>)<span class="keyword"> const </span>{
<a name="l00314"></a>00314             <span class="keywordflow">if</span> ( val &lt; bounds[0] ) <span class="comment">// lower bound</span>
<a name="l00315"></a>00315                 bounds[0]= val; <span class="keywordflow">else</span>
<a name="l00316"></a>00316             <span class="keywordflow">if</span> ( val &gt; bounds[1] ) <span class="comment">// upper bound</span>
<a name="l00317"></a>00317                 bounds[1]= val;
<a name="l00318"></a>00318         }
<a name="l00319"></a>00319     };
<a name="l00322"></a><a class="code" href="classKDBuilder.html#86dd30a38b0baaf7857e7d9b88e544a5">00322</a>     <span class="keywordtype">void</span> <a class="code" href="classKDBuilder.html#86dd30a38b0baaf7857e7d9b88e544a5" title="Computes the bounding box of count vectors with length length stored in data.">getBounds</a>(Bounds boundsRes)<span class="keyword"> const </span>{
<a name="l00323"></a>00323         <span class="keyword">using namespace </span>FieldMath;
<a name="l00324"></a>00324         ASSERT(length&gt;0);
<a name="l00325"></a>00325     <span class="comment">//  make the initial bounds only contain the first point</span>
<a name="l00326"></a>00326         <a class="code" href="namespaceFieldMath.html#0c43d84cae0936059f8c31ebd1090ffc" title="Calls transformer(x,y) for every x from [i1;iEnd1) and corresponding y from [i2;...">transform2</a>(data,data+length,boundsRes,<a class="code" href="structKDBuilder_1_1NewBounds.html" title="Creates bounds containing one value.">NewBounds</a>());
<a name="l00327"></a>00327         <span class="keywordtype">int</span> count= Tree::count;
<a name="l00328"></a>00328         <span class="keyword">const</span> T *nowData= data;
<a name="l00329"></a>00329     <span class="comment">//  expand the bounds by every point (except for the first one)</span>
<a name="l00330"></a>00330         <span class="keywordflow">while</span> (--count) {
<a name="l00331"></a>00331             nowData+= length;
<a name="l00332"></a>00332             <a class="code" href="namespaceFieldMath.html#0c43d84cae0936059f8c31ebd1090ffc" title="Calls transformer(x,y) for every x from [i1;iEnd1) and corresponding y from [i2;...">transform2</a>( nowData, nowData+length, boundsRes, <a class="code" href="structKDBuilder_1_1BoundsExpander.html" title="Expands a valid bounding box to contain a point (one coordinate at once).">BoundsExpander</a>() );
<a name="l00333"></a>00333         }
<a name="l00334"></a>00334     }
<a name="l00337"></a><a class="code" href="classKDBuilder.html#20b6a1550f8027812eb9d263952e1fed">00337</a>     <span class="keywordtype">void</span> <a class="code" href="classKDBuilder.html#20b6a1550f8027812eb9d263952e1fed" title="Like getBounds, but it only works on vectors with indices from [beginIDs;endIDs)...">getBounds</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> *beginIDs,<span class="keyword">const</span> <span class="keywordtype">int</span> *endIDs,Bounds boundsRes)<span class="keyword"> const </span>{
<a name="l00338"></a>00338         <span class="keyword">using namespace </span>FieldMath;
<a name="l00339"></a>00339         ASSERT(endIDs&gt;beginIDs);
<a name="l00340"></a>00340     <span class="comment">//  make the initial bounds only contain the first point</span>
<a name="l00341"></a>00341         <span class="keyword">const</span> T *begin= data + *beginIDs*length;
<a name="l00342"></a>00342         <a class="code" href="namespaceFieldMath.html#0c43d84cae0936059f8c31ebd1090ffc" title="Calls transformer(x,y) for every x from [i1;iEnd1) and corresponding y from [i2;...">transform2</a>(begin,begin+length,boundsRes,<a class="code" href="structKDBuilder_1_1NewBounds.html" title="Creates bounds containing one value.">NewBounds</a>());
<a name="l00343"></a>00343     <span class="comment">//  expand the bounds by every point (except for the first one)</span>
<a name="l00344"></a>00344         <span class="keywordflow">while</span> ( ++beginIDs != endIDs ) {
<a name="l00345"></a>00345             begin= data + *beginIDs*length;
<a name="l00346"></a>00346             <a class="code" href="namespaceFieldMath.html#0c43d84cae0936059f8c31ebd1090ffc" title="Calls transformer(x,y) for every x from [i1;iEnd1) and corresponding y from [i2;...">transform2</a>( begin, begin+length, boundsRes, <a class="code" href="structKDBuilder_1_1BoundsExpander.html" title="Expands a valid bounding box to contain a point (one coordinate at once).">BoundsExpander</a>() );
<a name="l00347"></a>00347         }
<a name="l00348"></a>00348     }
<a name="l00349"></a>00349 
<a name="l00352"></a>00352     <span class="keywordtype">void</span> buildNode(<span class="keywordtype">int</span> nodeIndex,<span class="keywordtype">int</span> *beginIDs,<span class="keywordtype">int</span> *endIDs,<span class="keywordtype">int</span> depthLeft);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354 <span class="keyword">public</span>:
<a name="l00357"></a><a class="code" href="classKDBuilder.html#4f5070032b774ff513cbfad64b33acea">00357</a>     <span class="keyword">static</span> <a class="code" href="classKDTree.html">Tree</a>* <a class="code" href="classKDBuilder.html#4f5070032b774ff513cbfad64b33acea" title="Builds a KDTree from count vectors of length length stored in data, splitting the...">makeTree</a>(<span class="keyword">const</span> T *data,<span class="keywordtype">int</span> length,<span class="keywordtype">int</span> count,CoordChooser chooser) {
<a name="l00358"></a>00358         <a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder</a> builder(data,length,count,chooser);
<a name="l00359"></a>00359     <span class="comment">//  moving only the necesarry data (pointers) into a new copy</span>
<a name="l00360"></a>00360         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classKDTree.html">Tree</a>(builder);
<a name="l00361"></a>00361     }
<a name="l00362"></a>00362     
<a name="l00364"></a>00364     <span class="keywordtype">int</span> choosePrecise(<span class="keywordtype">int</span> nodeIndex,<span class="keywordtype">int</span> *beginIDs,<span class="keywordtype">int</span> *endIDs,<span class="keywordtype">int</span> <span class="comment">/*depthLeft*/</span>) <span class="keyword">const</span>;
<a name="l00366"></a><a class="code" href="classKDBuilder.html#cabd700561ddc208513d7eda980d6b2e">00366</a>     <span class="keywordtype">int</span> chooseFast(<span class="keywordtype">int</span> <span class="comment">/*nodeIndex*/</span>,<span class="keywordtype">int</span>* <span class="comment">/*beginIDs*/</span>,<span class="keywordtype">int</span>* <span class="comment">/*endIDs*/</span>,<span class="keywordtype">int</span> depthLeft)<span class="keyword"> const</span>
<a name="l00367"></a>00367 <span class="keyword">        </span>{ <span class="keywordflow">return</span> depthLeft%length; }
<a name="l00369"></a><a class="code" href="classKDBuilder.html#3d1655a7dc952921b509d9c8585086cd">00369</a>     <span class="keywordtype">int</span> chooseRand(<span class="keywordtype">int</span> <span class="comment">/*nodeIndex*/</span>,<span class="keywordtype">int</span>* <span class="comment">/*beginIDs*/</span>,<span class="keywordtype">int</span>* <span class="comment">/*endIDs*/</span>,<span class="keywordtype">int</span> <span class="comment">/*depthLeft*/</span>)<span class="keyword"> const</span>
<a name="l00370"></a>00370 <span class="keyword">        </span>{ <span class="keywordflow">return</span> rand()%length; }
<a name="l00373"></a>00373     <span class="keywordtype">int</span> chooseApprox(<span class="keywordtype">int</span> nodeIndex,<span class="keywordtype">int</span>* <span class="comment">/*beginIDs*/</span>,<span class="keywordtype">int</span>* <span class="comment">/*endIDs*/</span>,<span class="keywordtype">int</span> depthLeft) <span class="keyword">const</span>;
<a name="l00374"></a>00374 }; <span class="comment">// KDBuilder class</span>
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 <span class="keyword">namespace </span>NOSPACE {
<a name="l00380"></a><a class="code" href="structNOSPACE_1_1MaxDiffCoord.html">00380</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct </span><a class="code" href="structNOSPACE_1_1MaxDiffCoord.html" title="Finds the longest coordinate of a bounding box, only to be used in for_each calls...">MaxDiffCoord</a> {
<a name="l00381"></a>00381         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder&lt;T&gt;::BoundsPair</a> BoundsPair;
<a name="l00382"></a>00382 
<a name="l00383"></a><a class="code" href="structNOSPACE_1_1MaxDiffCoord.html#2888885053153eb6fa8d57f0d2058d5f">00383</a>         T maxDiff;      
<a name="l00384"></a>00384         <span class="keywordtype">int</span> bestIndex   
<a name="l00385"></a><a class="code" href="structNOSPACE_1_1MaxDiffCoord.html#f135891984e23e6d8388930dd1b82018">00385</a>         , nextIndex;    
<a name="l00386"></a>00386 
<a name="l00388"></a><a class="code" href="structNOSPACE_1_1MaxDiffCoord.html#78dff4ce04b2d0349bccd610f80c5f56">00388</a>         <a class="code" href="structNOSPACE_1_1MaxDiffCoord.html" title="Finds the longest coordinate of a bounding box, only to be used in for_each calls...">MaxDiffCoord</a>(<span class="keyword">const</span> BoundsPair&amp; bounds0)
<a name="l00389"></a>00389         : maxDiff(bounds0[1]-bounds0[0]), bestIndex(0), nextIndex(1) {}
<a name="l00390"></a>00390 
<a name="l00392"></a><a class="code" href="structNOSPACE_1_1MaxDiffCoord.html#666c08f530c5f9b3037be7eb381760e4">00392</a>         <span class="keywordtype">void</span> <a class="code" href="structNOSPACE_1_1MaxDiffCoord.html#666c08f530c5f9b3037be7eb381760e4" title="To be called successively for indices from 1-st on.">operator()</a>(<span class="keyword">const</span> BoundsPair&amp; bounds_i) {
<a name="l00393"></a>00393             T diff= bounds_i[1]-bounds_i[0];
<a name="l00394"></a>00394             <span class="keywordflow">if</span> (diff&gt;maxDiff) {
<a name="l00395"></a>00395                 bestIndex= nextIndex;
<a name="l00396"></a>00396                 maxDiff= diff;
<a name="l00397"></a>00397             }
<a name="l00398"></a>00398             ++nextIndex;
<a name="l00399"></a>00399         }
<a name="l00400"></a>00400     };
<a name="l00401"></a>00401 }
<a name="l00402"></a>00402 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">int</span> <a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder&lt;T&gt;</a>
<a name="l00403"></a><a class="code" href="classKDBuilder.html#10054b8090a550e9b782cea11a3ea065">00403</a> <a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">::choosePrecise</a>(<span class="keywordtype">int</span> nodeIndex,<span class="keywordtype">int</span> *beginIDs,<span class="keywordtype">int</span> *endIDs,<span class="keywordtype">int</span>)<span class="keyword"> const </span>{
<a name="l00404"></a>00404     ASSERT( nodeIndex&gt;0 &amp;&amp; beginIDs &amp;&amp; endIDs &amp;&amp; beginIDs&lt;endIDs );
<a name="l00405"></a>00405 <span class="comment">//  temporary storage for computed bounding box</span>
<a name="l00406"></a>00406     BoundsPair boundsStorage[length];
<a name="l00407"></a>00407     <span class="keyword">const</span> BoundsPair *localBounds;
<a name="l00408"></a>00408 <span class="comment">//  find out the bounding box</span>
<a name="l00409"></a>00409     <span class="keywordflow">if</span> ( nodeIndex&gt;1 ) { <span class="comment">// compute the bounding box</span>
<a name="l00410"></a>00410         localBounds= boundsStorage;
<a name="l00411"></a>00411         getBounds( beginIDs, endIDs, boundsStorage );
<a name="l00412"></a>00412     } <span class="keywordflow">else</span> <span class="comment">// we are in the root -&gt; we can use already computed bounds</span>
<a name="l00413"></a>00413         localBounds= this-&gt;<a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>;
<a name="l00414"></a>00414 <span class="comment">//  find and return the longest coordinate</span>
<a name="l00415"></a>00415     MaxDiffCoord&lt;T&gt; mdc= for_each
<a name="l00416"></a>00416         ( localBounds+1, localBounds+length, MaxDiffCoord&lt;T&gt;(localBounds[0]) );
<a name="l00417"></a>00417     ASSERT( mdc.nextIndex == length );
<a name="l00418"></a>00418     <span class="keywordflow">return</span> mdc.bestIndex;
<a name="l00419"></a>00419 }
<a name="l00420"></a>00420 
<a name="l00421"></a><a class="code" href="classKDBuilder.html#27165e247c83cc9a2fa54869e50ac6f0">00421</a> <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">int</span> <a class="code" href="classKDBuilder.html" title="Derived type used to construct KDTree instances (makeTree static method).">KDBuilder&lt;T&gt;::chooseApprox</a>(<span class="keywordtype">int</span> nodeIndex,<span class="keywordtype">int</span>*,<span class="keywordtype">int</span>*,<span class="keywordtype">int</span>)<span class="keyword"> const </span>{
<a name="l00422"></a>00422     <span class="keyword">using namespace </span>FieldMath;
<a name="l00423"></a>00423     ASSERT(nodeIndex&gt;0);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425     <span class="keywordtype">int</span> myDepth= <a class="code" href="util_8h.html#97975b87cbe19485ff0af12d5972f54e" title="Returns ceil(log2(i)).">log2ceil</a>(nodeIndex+1)-1;
<a name="l00426"></a>00426     <span class="keywordflow">if</span> (!myDepth) { <span class="comment">// I'm in the root - copy the bounds</span>
<a name="l00427"></a>00427         ASSERT(nodeIndex==1);
<a name="l00428"></a>00428         chooserTmp= <span class="keyword">new</span> BoundsPair[length*(<a class="code" href="classKDTree.html#8bf98992fabd73eb9b85f051f5b626e9" title="The depth of the tree = log2ceil(::count).">depth</a>+1)]; <span class="comment">// allocate my temporary bound-array</span>
<a name="l00429"></a>00429         <a class="code" href="namespaceFieldMath.html#87fef7a11afc8c89d75842bb5349827a" title="Means b[i]=a[i]; Only meant for POD types.">assign</a>( <a class="code" href="classKDTree.html#b6b85f2f31cd7b77f34525142c1fc10e" title="The bounding box for all the data.">bounds</a>, length, chooserTmp );
<a name="l00430"></a>00430     }
<a name="l00431"></a>00431 
<a name="l00432"></a>00432     Bounds myBounds= chooserTmp+length*myDepth;
<a name="l00433"></a>00433     <span class="keywordflow">if</span> (myDepth) { <span class="comment">// I'm not the root - copy parent's bounds and modify them</span>
<a name="l00434"></a>00434         <span class="keyword">const</span> <span class="keyword">typename</span> Tree::Node &amp;parent= <a class="code" href="classKDTree.html#304690838aecbf6fe4bf55af6f942dd6" title="The array of the tree-nodes (heap-like topology of the tree).">nodes</a>[nodeIndex/2];
<a name="l00435"></a>00435         Bounds parentBounds= myBounds-length;
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (nodeIndex%2) {  <span class="comment">// I'm the right son -&gt; bounds on this level not initialized</span>
<a name="l00437"></a>00437             <a class="code" href="namespaceFieldMath.html#87fef7a11afc8c89d75842bb5349827a" title="Means b[i]=a[i]; Only meant for POD types.">assign</a>( parentBounds, length, myBounds );       <span class="comment">// copying parent bounds</span>
<a name="l00438"></a>00438             myBounds[parent.coord][0]= parent.threshold;    <span class="comment">// adjusting the lower bound</span>
<a name="l00439"></a>00439         } <span class="keywordflow">else</span> <span class="comment">// I'm the left son</span>
<a name="l00440"></a>00440             <span class="keywordflow">if</span> ( nodeIndex+1 &lt; count ) { <span class="comment">// almost the same as brother -&gt; only adjust the coordinate</span>
<a name="l00441"></a>00441                 myBounds[parent.coord][0]= parentBounds[parent.coord][0];
<a name="l00442"></a>00442                 myBounds[parent.coord][1]= parent.threshold;
<a name="l00443"></a>00443             } <span class="keywordflow">else</span> { <span class="comment">// I've got no brother</span>
<a name="l00444"></a>00444                 ASSERT( nodeIndex+1 == count );
<a name="l00445"></a>00445                 <a class="code" href="namespaceFieldMath.html#87fef7a11afc8c89d75842bb5349827a" title="Means b[i]=a[i]; Only meant for POD types.">assign</a>( parentBounds, length, myBounds );
<a name="l00446"></a>00446                 myBounds[parent.coord][1]= parent.threshold;
<a name="l00447"></a>00447             }
<a name="l00448"></a>00448     }
<a name="l00449"></a>00449 <span class="comment">//  find out the widest dimension</span>
<a name="l00450"></a>00450     MaxDiffCoord&lt;T&gt; mdc= for_each( myBounds+1, myBounds+length, MaxDiffCoord&lt;T&gt;(myBounds[0]) );
<a name="l00451"></a>00451     ASSERT( mdc.nextIndex == length );
<a name="l00452"></a>00452     <span class="keywordflow">return</span> mdc.bestIndex;
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 <span class="keyword">namespace </span>NOSPACE {
<a name="l00457"></a><a class="code" href="classNOSPACE_1_1IndexComparator.html">00457</a>     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classNOSPACE_1_1IndexComparator.html" title="Compares vectors (given by their indices) according to a given coordinate.">IndexComparator</a> {
<a name="l00458"></a><a class="code" href="classNOSPACE_1_1IndexComparator.html#ac1c7ac402f523967767c5d599ea16a2">00458</a>         <span class="keyword">const</span> T *<a class="code" href="classNOSPACE_1_1IndexComparator.html#ac1c7ac402f523967767c5d599ea16a2" title="pointer to the right coordinate of the first vector (of index 0)">data</a>;  
<a name="l00459"></a><a class="code" href="classNOSPACE_1_1IndexComparator.html#f934dbc8c5614ccf131f4fce72b2e80f">00459</a>         <span class="keywordtype">int</span> length;     
<a name="l00460"></a>00460     <span class="keyword">public</span>:
<a name="l00461"></a>00461         <a class="code" href="classNOSPACE_1_1IndexComparator.html" title="Compares vectors (given by their indices) according to a given coordinate.">IndexComparator</a>(<span class="keyword">const</span> T *data_,<span class="keywordtype">int</span> length_,<span class="keywordtype">int</span> index_)
<a name="l00462"></a>00462         : <a class="code" href="classNOSPACE_1_1IndexComparator.html#ac1c7ac402f523967767c5d599ea16a2" title="pointer to the right coordinate of the first vector (of index 0)">data</a>(data_+index_), length(length_) {}
<a name="l00463"></a>00463         <span class="keywordtype">bool</span> operator()(<span class="keywordtype">int</span> a,<span class="keywordtype">int</span> b)<span class="keyword"> const</span>
<a name="l00464"></a>00464 <span class="keyword">            </span>{ <span class="keywordflow">return</span> <a class="code" href="classNOSPACE_1_1IndexComparator.html#ac1c7ac402f523967767c5d599ea16a2" title="pointer to the right coordinate of the first vector (of index 0)">data</a>[a*length] &lt; <a class="code" href="classNOSPACE_1_1IndexComparator.html#ac1c7ac402f523967767c5d599ea16a2" title="pointer to the right coordinate of the first vector (of index 0)">data</a>[b*length]; }
<a name="l00465"></a>00465     };
<a name="l00466"></a>00466 }
<a name="l00467"></a>00467 <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keywordtype">void</span> <a class="code" href="classKDBuilder.html#2fd26932179526eb724378dcb28cebc1" title="Recursively builds node nodeIndex and its subtree of depth depthLeft (including leaves)...">KDBuilder&lt;T&gt;</a>
<a name="l00468"></a><a class="code" href="classKDBuilder.html#2fd26932179526eb724378dcb28cebc1">00468</a> <a class="code" href="classKDBuilder.html#2fd26932179526eb724378dcb28cebc1" title="Recursively builds node nodeIndex and its subtree of depth depthLeft (including leaves)...">::buildNode</a>(<span class="keywordtype">int</span> nodeIndex,<span class="keywordtype">int</span> *beginIDs,<span class="keywordtype">int</span> *endIDs,<span class="keywordtype">int</span> depthLeft) {
<a name="l00469"></a>00469     <span class="keywordtype">int</span> count= endIDs-beginIDs; <span class="comment">// owershadowing Tree::count</span>
<a name="l00470"></a>00470 <span class="comment">//  check we've got at least one vector and the depth&amp;count are adequate to each other</span>
<a name="l00471"></a>00471     ASSERT( count&gt;=2 &amp;&amp; powers[depthLeft-1]&lt;count &amp;&amp; count&lt;=powers[depthLeft] );
<a name="l00472"></a>00472     --depthLeft;
<a name="l00473"></a>00473 <span class="comment">//  find out where to split - how many items should be on the left to have the heap-shape</span>
<a name="l00474"></a>00474     <span class="keywordtype">bool</span> shallowRight= ( count &lt;= powers[depthLeft]+powers[depthLeft-1] );
<a name="l00475"></a>00475     <span class="keywordtype">int</span> *middle= shallowRight
<a name="l00476"></a>00476         ? endIDs-powers[depthLeft-1]
<a name="l00477"></a>00477         : beginIDs+powers[depthLeft];
<a name="l00478"></a>00478 <span class="comment">//  find out the dividing coordinate and find the "median" in this coordinate</span>
<a name="l00479"></a>00479     <span class="keywordtype">int</span> coord= (this-&gt;*chooser)(nodeIndex,beginIDs,endIDs,depthLeft);
<a name="l00480"></a>00480     nth_element( beginIDs, middle , endIDs, IndexComparator&lt;T&gt;(data,length,coord) );
<a name="l00481"></a>00481 <span class="comment">//  fill the node's data (dividing coordinate and its threshold)</span>
<a name="l00482"></a>00482     nodes[nodeIndex].coord= coord;
<a name="l00483"></a>00483     nodes[nodeIndex].threshold= data[*middle*length+coord]; <span class="comment">// min. value of the right son</span>
<a name="l00484"></a>00484 <span class="comment">//  recurse on both halves (if needed; fall-through switch)</span>
<a name="l00485"></a>00485     <span class="keywordflow">switch</span> (count) {
<a name="l00486"></a>00486     <span class="keywordflow">default</span>: <span class="comment">// we've got enough nodes - build both subtrees (fall through)</span>
<a name="l00487"></a>00487     <span class="comment">//  build the right subtree</span>
<a name="l00488"></a>00488         buildNode( 2*nodeIndex+1, middle, endIDs, depthLeft-shallowRight );
<a name="l00489"></a>00489     <span class="keywordflow">case</span> 3: <span class="comment">// only a pair in the first half</span>
<a name="l00490"></a>00490     <span class="comment">//  build the left subtree</span>
<a name="l00491"></a>00491         buildNode( 2*nodeIndex, beginIDs, middle, depthLeft );
<a name="l00492"></a>00492     <span class="keywordflow">case</span> 2: <span class="comment">// nothing needs to be sorted</span>
<a name="l00493"></a>00493         ;
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495 }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 <span class="preprocessor">#endif // KDTREE_HEADER_</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Aug 6 22:33:14 2009 for Fractal Image Compressor by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
